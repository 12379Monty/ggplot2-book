---
title: Tidy data
output: bookdown::html_chapter
bibliography: references.bib
---

```{r data, echo = FALSE, message = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
options(digits = 2, width = 60)
```

# Data analysis {#cha:data}

So far, every example in this book has started with a nice, tidy, dataset. This is great for learning ggplot2 because you don't want to struggle with getting data in the right shape at the same time as you learn how to use ggplot2. However, if you want to use ggplot2 with your own data, you'll need to learn some new techniques. In this chapter, you'll learn the principles of tidy data, which help you organise your data in a way that makes it easy for ggplot2 to work with. You'll also learn a little about about dplyr, which helps you manipulate tidy data, as is common during the course of a visualisation, and about broom, a package that turns models into tidy data.

Indeed, in my experience, visualisation is often the easiest part of this process: once you have tidy data, aggregated to the most useful level and modelled to discover the most important trends, the right visualisation is often quite easy.

The goal of this and the following two chapters is to show you how to integrate ggplot2 with other tools needed for a complete data analysis:

* ggplot2 makes it easy to map variables to visual properties, but it depends 
  on a particular way of storing your data. This form (or shape) is called tidy
  data. In XXX you'll learn the basics of tidy data and how you can make your
  messy data tidy with the __tidyr__ package.
  
* Most visualisations also require some data transformation whether it's 
  creating a new variable from existing variables, or performing simple 
  aggregations so you can see the forest for the tree. Section XXX will teach 
  how to use the __dplyr__ package to make this as easy as possible.
  
* If you're using R, you're almost certainly using it for it's fantastic
  modelling capabilities. While there's an R package for almost every type
  of model that you can think of, the results of these models can be hard to
  visualise. The __broom__ package, by David Robinson, makes your life easier 
  by converting model outputs into standard tidy datasets so you can easily
  integrate with ggplot2.

Data cleaning, manipulation and transformation is a big topic and this book only scratches the surface. I recommend the following references which go into considerably more depth on this topic:

* The documentation. I'll describe the most important arguments, but most
  functions have other arguments that help deal with less common situations.
  If you're struggling, make sure to read the documentation to see if there's
  an argument that might help you.

* "[Tidy data](http://www.jstatsoft.org/v59/i10/)", an article in the _Journal
  of Statistical Software_. It describes the ideas of tidy data in more depth
  and shows other types of messy data. Unfortunately the paper was written
  before tidyr existed, so to see how to use tidyr instead of reshape2, consult
  the 
  [tidyr vignette](http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html).

* The dplyr vignettes, which you can see with 
  `browseVignettes(package = "dplyr")`, go into considerably more depth into
  dplyr. There you'll learn how to also use dplyr with data frames, and how
  to work with multiple tables of data.

* The [broom README](https://github.com/dgrtwo/broom), gives a more detailed
  overview of broom and points you to the latest resources on where to learn 
  more.

## Tidy data {#sec:tidy-data}

The principle behind tidy data is simple: storing your data in a consistent way makes it easier to work with it. Tidy data is a mapping between statistical structure of a data frame (variables and observations) with the physical structure (columns and rows). Tidy data follows two main principles:

1. Variables go in columns.
1. Observations go in rows.

If you store data in this way, you'll find most data analysis tasks become easier.

Tidy data is particularly important for ggplot2 because the job of ggplot2 is to map variables to visual properties. ggplot2 assumes that variables are stored in columns, so if your data isn't tidy, you'll have a hard time visualising it.

Sometimes you'll find a dataset that you have no idea how to plot. That's normally because it's not tidy: the variables aren't provided as columns, so you can't tell ggplot2 what to plot. For example, take this data frame that contains monthly employment data for the United States:

```{r, echo = FALSE, message = FALSE}
library("lubridate")
ec2 <- 
  ggplot2::economics %>% 
  tbl_df() %>%
  transmute(year = year(date), month = month(date), rate = uempmed) %>%
  filter(year > 2000) %>%
  spread(year, rate)
knitr::kable(ec2)
```

(If it looks familiar it's because it's dervied from the `economics` dataset that you saw earlier.)

Imagine you want to plot a time series showing how unemployment has changed over the last 10 years. Can you picture the ggplot2 command you'd need to do it? What if you wanted to focus on the seasonal component of unemployment by putting months on the x-axis and drawing one line for each year? It's difficult to see how to create those plots because the data is not tidy. There are three variables, month, year and unemployment rate, but each variable is stored in a different way:

* `month` is stored in one column.
* `year` is spread across the first row.
* `rate` is the value of each cell.

To make it possible to plot this data we first need to tidy it. There are two important pairs of tools: 

* Spread & gather.
* Separate & unite.

## Spread and gather {#sec:spread-gather}

Take a look at the two tables below:

```{r, echo = FALSE}
keyed <- data.frame(
  w = c(1, 2, 3, 4, 3),
  x = c("a", "b", "c", "d", "c"),
  y = c("A", "D", "A", "C", "B"),
  z = c(1, 5, 4, 9, 10)
) %>% arrange(x, y)
matrix <- keyed %>% spread(y, z)

knitr::kable(keyed)
knitr::kable(matrix)
```

If you study them for a little while, you'll notice that they contain the same data, but in a different form. The first form is called __keyed__ data. The second form is called __matrix__ form.

(Note that we can't tell if these datasets are tidy or not. Either form could be tidying depending on what the values "A", "B", "C", "D" mean. Also note the missing values: missing values that are explicit in one form, maybe implicit in the other. An `NA` is the presence of an absense; but sometimes a missing value is the absense of a presence.)

Transforming from one form to the other always requires a _key_ and a _value_. When spreading, going from keyed to indexed forms, the key is the column that will become column names, and the value is the column that fills in the values. When gathering, going from indexed to keyed, the key is the name of the column that will be created from the row names, and the value is the name of the column that will be created from the cell values. To help you remember the verbs, gather takes many columns and gathers into a pair, spread takes a pair of variables and spreads into many.

The tidyr package provides the `spread()` and `gather()` functions to perform these operations. You also need to tell `gather()` which columns are in matrix form, and here I use `na.rm = TRUE` to make the missing values implicit.

```{r}
library(tidyr)
spread(keyed, key = y, value = z)
gather(matrix, key = y, value = z, A:D, na.rm = TRUE)
```

Don't worry if this seems a bit confusing at first. You'll get the hang of it as you work through some concrete examples.

To tidy the economics dataset shown above, you first need to identify the variables. Note that there's a pair of variables that are stored in the column names and in the cell values. This data is in matrix form and we need to put it in keyed form to make it tidy. This is the job of `gather()`. It takes four arguments:

* `data`: the dataset to modify
* `key`: the name of the variable in the column names
* `value`: the name of the variable in the cell values
* `...`: the columns to gather up. You can specify individually, `A, B, C, D`,
   or as a range `A:D`.

In this example, the key is `year`, the value is `unemp` and we want to select columns from `2001` to `2007`:

```{r}
gather(ec2, key = year, value = unemp, `2001`:`2007`)
```

Note that the columns have names that are not standard varible names in R (they don't start with a letter). This means that we need to surround them in backticks, `` `2001` `` to refer to them.

To be useful, we need two extra args:

```{r}
economics <- gather(ec2, year, rate, `2001`:`2007`, convert = TRUE, na.rm = TRUE)
```

We use `convert = TRUE` to automatically convert the years from character strings to numbers, and `na.rm = TRUE` to remove the months with no data. (In some sense the data isn't actually missing because it represents dates that haven't occured yet.)

Now we can easily visualise this to emphasise either the long term trend:

```{r}
ggplot(economics, aes(year + (month - 1) / 12, rate)) +
  geom_line()
```

Or the seasonal patterns:

```{r}
ggplot(economics, aes(month, rate, group = year)) +
  geom_line(aes(colour = year), size = 1)
```

Spreading is the opposite of gathering. You use it when you have a pair of columns that contain the name of a variable and its value. The following example dataset contains three variables (day, rain and temp), but rain and temp are stored in the obs-val pair. Spread allows us to turn the keyed form into a tidy matrix form:

```{r}
weather <- dplyr::data_frame(
  day = rep(1:3, 2),
  obs = rep(c("temp", "rain"), each = 3),
  val = c(c(23, 22, 20), c(0, 0, 5))
)
spread(weather, key = obs, value = val)
```

## Separate and unite {#sec:separate-unite}

Spread and gather help when the variables are in the wrong place in the dataset. Separate and unite help when multiple variables are crammed into one column, or spread across multiple columns. 

For example, the following dataset stores some information about the response to a medical treatment. There are three variables (time, treatment and value), but time and treatment are jammed in one variable together: 

```{r, echo = FALSE}
trt <- dplyr::data_frame(
  var = paste0(rep(c("start", "end"), each = 3), "_", rep(c("a", "b", "c"), 2)),
  val = c(1, 4, 2, 10, 5, 11)
)
```

The `separate()` function makes it easy to tease apart multiple variables stored in one column. It takes four arguments:

* `data`: the data frame to modify
* `col`: the name of the variable to split into pieces
* `into`: a character vector giving the names of the new variables
* `sep`: a description of how to split the variable apart. This can either be
  a regular expression, e.g. `_` to split by underscores, or `[^a-z]` to split 
  by any non-letter, or an integer giving a position.
  
```{r}
separate(trt, var, c("time", "treatment"), "_")
```

(If the variables are combined in a more complex form, have a look at `extract()` as a more complex form of `separate()`. Alternatively, you might need to create columns individually yourself using other calculations. A useful tool for this is `mutate()` which you'll learn about in the next chapter.)

`unite()` is the inverse of `separate()` - it joins together multiple columns into one column. This is much common, but it's important to recognise that tidying verbs always come in paris.

## Case studies {#sec:tidy-case-study}

For most real datasets, you'll need to use more than one tidying verb. There many be multiple ways to get there, but as long as each step makes the data tidier, you'll eventually get to a tidy dataset. However, as a general rule, typically you apply the functions in the same order: you might not use all of them, but most of time you use them in order of `gather()`, `separate()` and `tidy()`.

````{r}
# Pending OK from Barry Rowlingston

bpd <- readr::read_table("Name Age      Start  Week1  Week2  Week3  Week4
Anne  35 2014-03-27 100/80 140/70 100/75 120/90
 Ben  41 2014-03-09 110/65 115/80 100/65 135/70
Carl  33 2014-04-02 125/80 140/90   <NA>   <NA>
Debs  27 2014-04-01 100/65 115/85 120/80   <NA>
  Ed  22 2014-04-02 115/75  90/75 110/65 120/75
", na = "<NA>")

bpd %>%
  gather(week, bp, Week1:Week4) %>%
  separate(bp, c("sys", "dia"), "/", extra = "drop") %>%
  extract(week, "week", "(\\d+)", convert = TRUE)
```


```{r}
# Adapted from http://stackoverflow.com/questions/29775461
scores <- data_frame(
  person = rep(c("Greg", "Sally", "Sue"), each = 2),
  time   = rep(c("pre", "post"), 3),
  test1  = round(rnorm(6, mean = 80, sd = 4), 0),
  test2  = round(jitter(test1, 15), 0),
  test3  = round(5 + (test1 + test2) / 2)
)

scores %>% 
  gather(test, value, test1:test3) %>%
  spread(time, value) %>% 
  mutate(diff = post - pre)
```