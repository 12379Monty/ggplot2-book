---
title: Tidy data
output: bookdown::html_chapter
bibliography: references.bib
---

```{r data, echo = FALSE, message = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
options(digits = 2, width = 60)
```

# Data analysis {#cha:data}

So far, every example in this book has started with a nice, tidy, dataset. This is great for learning ggplot2 because you don't want to struggle with getting data in the right shape at the same time as you learn how to use ggplot2. However, if you want to use ggplot2 with your own data, you'll need to learn some new techniques. In this chapter, you'll learn the principles of tidy data, which help you organise your data in a way that makes it easy for ggplot2 to work with. You'll also learn a little about about dplyr, which helps you manipulate tidy data, as is common during the course of a visualisation, and about broom, a package that turns models into tidy data.

Indeed, in my experience, visualisation is often the easiest part of this process: once you have tidy data, aggregated to the most useful level and modelled to discover the most important trends, the right visualisation is often quite easy.

The goal of this chapter is to show you how to integrate visualisation with ggplot2 with the other parts of the data analysis process:

* ggplot2 makes it easy to map variables to visual properties, but it depends 
  on a particular way of storing your data. This form (or shape) is called tidy
  data. In XXX you'll learn the basics of tidy data and how you can make your
  messy data tidy with the __tidyr__ package.
  
* Most visualisations also require some data transformation whether it's 
  creating a new variable from existing variables, or performing simple 
  aggregations so you can see the forest for the tree. Section XXX will teach 
  how to use the __dplyr__ package to make this as easy as possible.
  
* If you're using R, you're almost certainly using it for it's fantastic
  modelling capabilities. While there's an R package for almost every type
  of model that you can think of, the results of these models can be hard to
  visualise. The __broom__ package, by David Robinson, makes your life easier 
  by converting model outputs into standard tidy datasets so you can easily
  integrate with ggplot2.

Data cleaning, manipulation and transformation is a big topic and this chapter only scratches the surface of topics closely related to ggplot2. I recommend the following references which go into considerably more depth on this topic:

* "[Tidy data](http://www.jstatsoft.org/v59/i10/)", an article in the _Journal
  of Statistical Software_. It describes the ideas of tidy data in more depth
  and shows other types of messy data. Unfortunately the paper was written
  before tidyr existed, so to see how to use tidyr instead of reshape2, consult
  the 
  [tidyr vignette](http://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html).

* The dplyr vignettes, which you can see with 
  `browseVignettes(package = "dplyr")`, go into considerably more depth into
  dplyr. There you'll learn how to also use dplyr with data frames, and how
  to work with multiple tables of data.

* The [broom README](https://github.com/dgrtwo/broom), gives a more detailed
  overview of broom and points you to the latest resources on where to learn 
  more.

  
## Tidy data {#sec:tidy-data}

The principle behind tidy data is simple: storing your data in a consistent way makes it easier to work with it. Tidy data is a mapping between statistical structure of a data frame (variables and observations) with the physical structure (columns and rows). Tidy data follows two main principles:

1. Variables go in columns.
1. Observations go in rows.

If you store data in this way, you'll find most data analysis tasks become easier Tidy data is particularly important for ggplot2 because the job of ggplot2 is to map variables to visual properties. Assuming a consistent way of accessing variables makes ggplot2 much easier to use.

Sometimes you'll find a dataset that you have no idea how to plot. That's normally because it's not tidy: the variables aren't provided as columns, so you have no way to tell ggplot2 what to plot. For example, take this data frame that contains monthly employment data for the United States:

```{r, echo = FALSE, message = FALSE}
library("lubridate")
ec2 <- 
  ggplot2::economics %>% 
  tbl_df() %>%
  transmute(year = year(date), month = month(date), rate = uempmed) %>%
  filter(year > 2000) %>%
  spread(year, rate)
knitr::kable(ec2)
```

(If it looks familiar it's because it's dervied from the `economics` dataset included in ggplot2.)

Imagine you want to plot a time series showing how unemployment has changed over the last 10 years? How would you do it? What if you wanted to focus on the seasonal component of unemployment by putting months on the x-axis and drawing one line for year? How would you do that? It's difficult to see how to create those plots from this data because it is not tidy. There are three variables, month, year and unemployment rate, but each variable is stored in a different way:

* `month` is stored in the rows.
* `year` is spread across the columns.
* `rate` is the value of each cell.

To make it possible to plot this data we first need to tidy it. There are two main tools needed for tidying messy data: spread and gather.

### Spread and gather {#sec:spread-gather}

Take a look at the two tables below:

```{r, echo = FALSE}
df <- data.frame(
  w = c(1, 2, 3, 4, 3),
  x = c("a", "b", "c", "d", "c"),
  y = c("A", "D", "A", "C", "B"),
  z = c(1, 5, 4, 9, 10)
) %>% arrange(x, y)

knitr::kable(df)
knitr::kable(df %>% spread(y, z))
```

If you study them closely, you'll notice that they contain the same data, but in a different form. The first form is called __keyed__ data. The second form is called __matrix__ form.

(Note that we can't tell if these datasets are tidy or not. Either form could be tidying dependiing on what the values "A", "B", "C", "D" mean. Also note the missing values: missing values that are explicit in one form, maybe implicit in the other. An `NA` is the presence of an absense; but sometimes a missing value is the absense of a presence.)

Transforming from one form to the other always requires a _key_ and a _value_. When spreading, going from keyed to indexed forms, the key is the column that will become column names, and the value is the column that fills in the values. When gathering, going from indexed to keyed, the key is the name of the column that will be created from the row names, and the value is the name of the column that will be created from the cell values.

Don't worry if this seems a bit confusing at first. You'll get the hang of it as you work through some concrete examples.

### Types of messiness {#sec:tidyr}

A tidy variable is a variable that's in a column; a messy variable is stored in some other way. There are three fundamental types of messy variable: column-spread, combined and row-spread. Any other types of messiness are just combinations of the three:

*   A pair of variables is spread across multiple columns. The 
    column names give the value one variable (the __key__), and the cell values 
    give the values of the other variable (the __value__).

    For example, the following dataset has three variables: month, year,
    and unemployment rate. Month is tidy, year and rate are spread across
    columns. Year gives the column name, and rate is the cell values.
    
    ```{r}
    ggplot2::economics %>% 
      tbl_df() %>%
      transmute(year = year(date), month = month(date), rate = uempmed) %>%
      filter(year > 2000) %>%
      spread(year, rate) %>% 
      head()
    ```

*   Combined: Multiple variables are stored in one column.

    ```{r, echo = FALSE}
    dplyr::data_frame(
      var = paste0(rep(c("start", "end"), each = 3), "_", rep(1:3, 2))
    )
    ```
    
    It's common to see a combination of row-spread and combine messiness 
    where the column names are a combination of multiple variables.
    
*   Row-spread: The rarest form of messiness is when a column contains the 
    variable names (the __key__) is paired with another column that gives the 
    values of the variable (the __value__).
    
    ```{r}
    dplyr::data_frame(
      obs = rep(c("temp", "rain"), each = 3),
      val = c(c(23, 22, 20), c(0, 0, 5))
    )
    ```

### Tidying messy variables

To tidy a messy data set, you first identify the variables, and the tidy them in the same order as above:

* Use `gather()` to combine col-spread variables into key and value 
  columns.

* Use `separate()` to turn combined variables into individual variables.
  
* Use `spread()` to turn a key-value pair of row-spread variables into 
  individual columns.

You always perform the operations (`spread()`, `separate()` and `gather()`) in the same order, but not every dataset requires all three operations. I haven't said anything about observations: if you focus on making sure each variable is in a column, then the observations will take care of themselves. (That said, once you've tidied the data it's worth thinking about exactly what a row of data represents.)

#### Spread

The inverse of spread is gather. So to tidy a 

We're going to use the __tidyr__ package. We're going to start with the `gather()` function. `gather()` takes variables that are spread across columns and values.

```{r}
ec3 <- 
  ec2 %>% 
  gather(year, rate, `2001`:`2007`, convert = TRUE, na.rm = TRUE)
```

We use `convert = TRUE` to automatically convert the years from character strings to numbers, and `na.rm = TRUE` to remove the months with no data. (In some sense the data isn't actually missing because it represents dates that haven't occured yet.)

Now we can easily visualise this to emphasise either the long term trend:

```{r}
ggplot(ec3, aes(year + (month - 1) / 12, rate)) +
  geom_line()
```

Or the seasonal patterns:

```{r}
ggplot(ec3, aes(month, rate, group = year)) +
  geom_line(aes(colour = year), size = 1)
```
