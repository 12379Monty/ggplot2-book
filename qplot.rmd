---
title: qplot
output: bookdown::html_chapter
bibliography: references.bib
---

# Getting started with ggplot2 {#cha:qplot}

## Introduction

The goal of this chapter is to get you producing useful graphics with ggplot2 as quickly as possible. You'll learn the basics of `ggplot()` and how to use it to make a wide variety of plots. `ggplot()` allows you to make complex plots with just a few lines of code because it's based on rich underlying theory, the grammar of graphics. You'll learn how to use the full expressive power of the grammar in later chapters. Here, we'll focus on some basic "recipes" so you can start using ggplot2 with a minimum of fuss.

In this chapter you'll learn:

* The basics of the diamonds dataset included with ggplot2, 
  [diamonds](#diamonds).

* The three key components of every plot: data, aesthetics and layers; 
  [Key components](#sec:basic-use).
  
* Using aesthetics to add additional variables to a plot, 
  [aesthetics](#aesthetics).

* How to create many different types of plots by specifying different geoms, 
  and how to combine multiple types in a single plot, 
  [geoms](#sec:plot-geoms).

* The use of faceting to repeat the same display for multiple subsets of your 
  data, [faceting](#sec:qplot-faceting).

## Fuel economy data {#sec:fuel-economy-data}

In this chapter we'll focus primarily on one data source bundled with ggplot2. The `mpg` dataset includes information about the fuel economy of popular car models in 1999 and 2008. You can access it by loading ggplot2:

```{r}
library(ggplot2)
dim(mpg)
head(mpg)
```

It records make, model, class, engine size, transmission and fuel economy for a selection of US cars in 1999 and 2008. It contains the 38 models that were updated every year, an indicator that the car was a popular model. These models include popular cars like the Audi A4, Honda Civic, Hyundai Sonata, Nissan Maxima, Toyota Camry and Volkswagen Jetta. This data comes from the EPA fuel economy website, <http://fueleconomy.gov>. \index{Data!mpg@\texttt{mpg}}

The variables are mostly self-explanatory:

* `cty` and `hwy` record miles per gallon (mpg) for city and highway driving.
* `displ` is the engine displacement in litres
* `drv` is the drive train: front wheel (f), rear wheel (r) or four wheel (4)

This dataset suggests many interesting questions.  How are engine size and fuel economy related?  Do certain manufacturers care more about economy than others? Has fuel economy improved in the last ten years?  We will try to answer some of these questions and in the process learn how to create some basic plots with ggplot2.

### Exercises

1.  What are five basic R tools that you could use to get more information 
    about this dataset?
    
1.  Apart from the US, most countries use fuel consumption (amount of fuel 
    needed to travel a fixed distance) rather than fuel economy (distance that
    fixed amount of fuel gets you). How could you convert `cty` and `hwy` into
    the European standard `l/100km`? 

## Key components {#sec:basic-use}

Every ggplot2 plot has three key components: a dataset, a set of __aesthetic__ mappings between variables in the data and visual properties, and some layers. Here's a simple example: \index{Scatterplot}

```{r qscatter}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()
```

This produces a scatterplot:

* It uses the `mpg` data frame.
* It maps engine displacement to x position and fuel consumption to y position.
* It uses a layer of points. __Geom__ is short for geometric object.

Pay attention to the structure of this function call: data and aesthetic mappings are supplied in the ggplot, and then layers (geoms) are added on with `+`. As you learn more about ggplot2 you'll construct increasingly sophisticated plots by adding more components.

The plot shows a strong correlation: as the engine size gets bigger, the fuel economy gets worse. There are also some interesting outliers: some cars with large engines get higher fuel economy than average.  What sort of cars do you think they are?

Almost every plot maps a variable to `x` and `y`, so naming these aesthetics is going to get tedious fast. For that reason, the first two unnamed arguments to `aes()` will be mapped to `x` and `y`. That means that following code is identical to the example above:

```{r, eval = FALSE}
ggplot(mpg, aes(displ, hwy) + 
  geom_point()
```

I'll stick to that style throughout the book, so remember that the first two arguments are mapped to position.

### Exercises

1.  How would you describe the relationship between `cty` and `hwy`?
  
1.  Describe the data, aesthetic mappings and layers used for each of the 
    following plots. You'll need to guess a little because you haven't learned
    what each of the different functions do, but you should be able to make
    an educated guess!
    
    1. `ggplot(mpg, aes(cty, hwy)) + geom_point()`
    1. `ggplot(diamonds, aes(carat, price)) + geom_point()`
    1. `ggplot(economics, aes(date, unemply)) + geom_line()`
    1. `ggplot(mpg, aes(cty)) + geom_histogram()`


## Colour, size, shape and other aesthetic attributes {#aesthetics}

To add additional variables to a plot, we need to use other aesthetics like colour, shape, or size. ggplot2 takes care of the details of converting a categorical variable in your data (e.g., 'apples', 'bananas', 'pears') into something that the graphics device knows how to display (e.g., 'red', 'yellow', 'green'). It also adds a legend to that gives the inverse mapping, showing how the displayed attributes can be converted back to the data values. This makes it particularly easier to add additional variables to a plot. \index{Aesthetics}

We could use the colour aesthetic to also display the categorical "class" variable:

```{r qplot-aesthetics}
ggplot(mpg, aes(displ, cty, colour = class)) + 
  geom_point()
```

(Note that while I use British spelling throughout this book, ggplot2 also accepts American spellings.)

This shows that the group of cars with unusually high fuel economy for their engine size are two seaters: cars with big engines, but lighter bodies. 

For every aesthetic attribute, there is a function, called a _scale_, which maps data values to valid values for that aesthetic. It is this scale that controls the appearance of the points and associated legend. For example, in the above plot, the colour scale maps I1 to red and VS2 to green. You'll learn more about how to overide the default scales with your own choices in [the scales chapter](#cha:scales). 

If you want to set an aesthetic to a fixed value, without scaling it, do so outside of `aes()`. Compare the following two plots:

```{r}
ggplot(dsmall, aes(carat, price)) + 
  geom_point(aes(colour = "blue"))
ggplot(dsmall, aes(carat, price)) + 
  geom_point(colour = "blue")
```

In the first plot, the value "blue" is scaled to a pinkish colour, and a legend is added. In the second plot, the points are given the R colour blue. This is explained in more detail in [setting vs. mapping](#sub:setting-mapping).

One aesthetic that it's useful to set (rather than map with a scale), is `alpha`, which controls transparency. For large datasets, like the diamonds data, semi-transparent points are often useful to alleviate some of the overplotting. To make a semi-transparent colour you can use the alpha aesthetic, which takes a value between 0 (completely transparent) and 1 (complete opaque).  It's often useful to specify the transparency as a fraction, e.g., `1/10` or `1/20`, as the denominator specifies the number of points that must overplot to get a completely opaque colour. \index{Aesthetics!setting} \indexf{I}

```{r qplot-set, fig.show = "hold", dev = "png", out.width = "0.32\\linewidth", fig.weight = 4, fig.height = 4}
ggplot(diamonds, aes(carat, price)) + 
  geom_point(alpha = 1 / 10)
ggplot(diamonds, aes(carat, price)) + 
  geom_point(alpha = 1 / 100)
ggplot(diamonds, aes(carat, price)) + 
  geom_point(alpha = 1 / 200)
```

Different types of aesthetic attributes work better with different types of variables. For example, colour and shape work well with categorical variables, while size works better with continuous variables. The amount of data also makes a difference: if there is a lot of data, like in the plots above, it can be hard to distinguish the different groups. An alternative solution is to use faceting.

### Exercises

1.  Experiemnt with the colour, shape and size aesthetics.

1.  What happens if you map a continuous variable to shape? Why? What happens
    if you map clarity to shape? Why?

## Faceting {#sec:qplot-faceting}

Another way of displaying additional categorical variables on a plot is facetting. Faceting creates tables of graphics by splitting the data into subsets and displaying the same graph for each subset in an arrangement that facilitates comparison. You'll learn more about faceting in [Faceting](#sec:faceting), but it's such a useful technique that it's worth learning right away.  \index{Faceting}

There are two types of facetting: grid and wrapped. Wrapped is the most useful, so we'll discuss it here, and you can learn about grid facetting later. To facet a plot you simply add a facetting specification:

```{r facet-hist, dev = "png"}
ggplot(diamonds, aes(log(carat), log(price))) + 
  geom_point() + 
  facet_wrap(~color)
```

To add facetting you either use `facet_grid(row_var ~ col_var)` or `facet_wrap(~ var)`. To facet on only one of columns or rows, use `.` as a place holder.  For example, `row_var ~ .` will create a single column with multiple rows. \indexf{facet_grid}

The following code illustrates this technique with two plots, sets of histograms showing the distribution of carat conditional on colour. 

You can learn more about the relatively advantages and disadvantages of using faceting instead of aesthetics in [grouping vs. faceting](#sub:group-vs-facet).

## Plot geoms {#sec:plot-geoms}

`?geom_smooth`.

`ggplot()` is not limited to scatterplots, but can produce almost any kind of plot by varying the `geom`. Geom, short for geometric object, describes the type of object that is used to display the data. Some geoms have an associated statistical transformation, for example, a histogram is a binning statistic plus a bar geom. These different components are described in the next chapter. Here we'll introduce the most common and useful geoms, organised by the dimensionality of data that they work with. The following geoms enable you to investigate two-dimensional relationships:

* `geom_smooth()` fits a smoother to the data and displays the smooth and its 
  standard error, see [adding a smoother to a plot](#sub:smooth).

* `geom_boxplot()` produces a box-and-whisker plot to summarise the distribution 
  of a set of points, see [boxplots and jittered points](#sub:boxplot).

* `geom_path()` and `geom_line()` draw lines between the data points.
  A line plot is constrained to produce lines that travel from left to right, 
  while paths can go in any direction, see 
  [time series with line and path plots](#sub:line). Lines are typically used 
  to explore relationships between time and another variable, and paths to join 
  observations connected in some other way.  

For 1d distributions, your choice of geoms is guided by the variable type:

* For continuous variables, `geom_histogram()` draws a histogram, and
  `geom_freqpoly()` a frequency polygon, 
  [histogram and frequency polygons](#sub:distribution).

* For discrete variables, use `geom_bar()` to make a bar chart, see 
  [bar charts](#sub:bar).

### Adding a smoother to a plot {#sub:smooth}

If you have a scatterplot with many data points, it can be hard to see exactly what trend is shown by the data. In this case you may want to add a smoothed line to the plot. This is easily done using the `smooth` geom as shown below. The geoms will be overlaid in the order in which they appear.  \index{Smoothing} \indexf{geom_smooth}

```{r qplot-smooth, fig.show = "hold", dev = "png"}
ggplot(diamonds, aes(carat, price)) + 
  geom_point() + 
  geom_smooth()
```

Despite overplotting, our impression of an exponential relationship between price and carat was correct. There are few diamonds bigger than three carats, and our uncertainty in the form of the relationship increases as illustrated by the point-wise confidence interval shown in grey. If you want to turn the confidence interval off, use `geom_smooth(se = FALSE)`.

There are many different smoothers you can choose between by using the `method` argument:

*   `method = "loess"`, the default for small n, uses a smooth local 
    regression.  More details about the algorithm used can be found in `?loess`.  
    The wiggliness of the line is controlled by the `span` parameter, which 
    ranges from 0 (exceedingly wiggly) to 1 (not so wiggly). \index{Model!loess}
      
    ```{r smooth-loess, fig.show = "hold"}
    ggplot(dsmall, aes(carat, price)) + 
      geom_point() + 
      geom_smooth(span = 0.2)
    
    ggplot(dsmall, aes(carat, price)) + 
      geom_point() + 
      geom_smooth(span = 1)
    ```
      
    Loess does not work well for large datasets (it's $O(n^2)$ in memory), so
    an alternative smoothing algorithm is used when $n$ is greater than 1,000. 

*   You could load the __mgcv__ library and use `method = "gam"` and 
    `formula = y ~ s(x)` to fit a generalised additive model. For large data, 
    use the formula `y ~ s(x, bs = "cs")`. This is used by default when there 
    are more than 1,000 points. 
    \index{Package!mgcv} \index{Model!generalised additive}

    ```{r smooth-gam}
    library(mgcv)
    ggplot(dsmall, aes(carat, price)) + 
      geom_point() + 
      geom_smooth(method = "gam", formula = y ~ s(x))
    ```

*   `method = "lm"` fits a linear model.  The default will fit a straight line 
    to your data, or you can specify `formula = y ~ poly(x, 2)` to specify a 
    2nd-degree polynomial, or better, load the __splines__ package and use a 
    natural spline: `formula = y ~ ns(x, 2)`. The second parameter is the 
    degrees of freedom: a higher number will create a wigglier curve. You are 
    free to specify any formula involving $x$ and $y$.  \index{Model!linear}

    ```{r smooth-lm, fig.show = "hold"}
    library(splines)
    
    # A linear model
    ggplot(dsmall, aes(carat, price)) + 
      geom_point() + 
      geom_smooth(method = "lm")
    
    # A natural spline with 5 degrees of freedom
    ggplot(dsmall, aes(carat, price)) + 
      geom_point() + 
      geom_smooth(method = "lm", formula = y ~ ns(x, 5))
    ```

  * `method = "rlm"` works like `lm()`, but uses a robust fitting algorithm so 
    that outliers don't affect the fit as much.  It's part of the __MASS__ 
    package, so remember to load that first. \index{Model!robust} 
    \index{Package!MASS}

### Boxplots and jittered points {#sub:boxplot}

When a set of data includes a categorical variable and one or more continuous variables, you will probably be interested to know how the values of the continuous variables vary with the levels of the categorical variable.  Box-plots and jittered points offer two ways to do this.  The following code explores how the distribution of price per carat varies with the colour of the diamond using jittering (`geom = "jitter"`, left) and box-and-whisker plots (`geom = "boxplot"`, right). \index{Boxplot} \index{Jittering} \indexf{geom_boxplot}

```{r jitter-boxplot, fig.show = "hold", dev = "png"}
# As the colour improves (from left to right) the spread of values decreases, 
# but there is little change in the centre of the distribution.
ggplot(diamonds, aes(color, price / carat)) + 
  geom_jitter()

ggplot(diamonds, aes(color, price / carat)) + 
  geom_boxplot()

ggplot(diamonds, aes(color, price / carat)) + 
  geom_violin()
```

Each method has its strengths and weaknesses. Boxplots summarise the bulk of the distribution with only five numbers, while jittered plots show every point but can suffer from overplotting. In the example here, both plots show the dependency of the spread of price per carat on diamond colour, but the boxplots are more informative, indicating that there is very little change in the median and adjacent quartiles.

For jittered points, `geom_jitter()` offers the same control over aesthetics as `geom_point()`: `size`, `colour`, `shape` and `alpha`. For `geom_boxplot()` and `geom_violin()`, you can control the outline `colour`, the internal `fill` colour and the `size` of the lines.

Another way to look at conditional distributions is to use faceting (described in [faceting](#sec:qplot-faceting)) to plot a separate histogram or density plot for each value of the categorical variable.

### Histograms and frequency polygons {#sub:distribution}

Histogram and freqency polygons show the distribution of a single variable.  They provide more information about the distribution of a single group than boxplots do, but it is harder to compare many groups (although we will look at one way to do so). \index{Histogram} \index{Density!plot} \indexf{geom_histogram} \indexf{geom_density}

```{r dist, fig.show = "hold", fig.width = 4, fig.height = 3}
ggplot(diamonds, aes(carat)) + 
  geom_histogram()
ggplot(diamonds, aes(carat)) + 
  geom_freqpoly()
```

Both both geoms, you can can controls the amount of smoothing by setting the bin width. (Break points can also be specified explicitly, using the `breaks` argument.) It is __very important__ to experiment with the bin width  You should always try many bin widths: You may find that gross features of the data show up well at a large bin width, while finer features require a very narrow width.

Below we experiment with three values of `binwidth`: 1.0, 0.1 and 0.01. It is only in the plot with the smallest bin width (right) that we see the striations we noted in an earlier scatterplot, most diamonds have a 'nice' numbers of carats:

```{r hist-binwidth, fig.show = "hold", fig.width = 4, fig.height = 3, out.width = "0.32\\linewidth"}
ggplot(diamonds, aes(carat)) + 
  geom_histogram(binwidth = 1) + 
  xlim(0, 3)

ggplot(diamonds, aes(carat)) + 
  geom_histogram(binwidth = 0.1) + 
  xlim(0, 3)

ggplot(diamonds, aes(carat)) + 
  geom_histogram(binwidth = 0.01) + 
  xlim(0, 3)
```

To compare the distributions of different subgroups, just add an aesthetic mapping, as in the following code:

```{r dist-fill, fig.show = "hold", fig.width = 4, fig.height = 3}
ggplot(diamonds, aes(price / carat)) + 
  geom_histogram(binwidth = 500)

ggplot(diamonds, aes(price / carat)) + 
  geom_histogram(aes(fill = color), binwidth = 500)
ggplot(diamonds, aes(price / carat)) + 
  geom_freqpoly(aes(color = color), binwidth = 500)
```

Mapping a categorical variable to an aesthetic will automatically split up the geom by that variable, so these commands instruct ggplot2 to draw a histogram and frequency polygon for each colour of diamond. It's easier to compare distributions when using the frequency polygon because the perceptual task is easier: you can compare the heights against a common baseline.

### Bar charts {#sub:bar}

The discrete analogue of histogram is the bar chart, `geom_bar()`. The bar geom counts the number of instances of each class so that you don't need to tabulate your values beforehand, as with `barplot()` in base R. If the data has already been tabulated or if you'd like to tabulate class members in some other way, such as by summing up a continuous variable, you can use the `weight` aesthetic. The first plot is a simple bar chart of diamond colour, and the second is a bar chart of diamond colour weighted by carat. \index{Barchart} \indexf{geom_bar}

```{r dist-bar, fig.show = "hold", fig.width = 4, fig.height = 2.4}
# Raw counts
ggplot(diamonds, aes(color)) + 
  geom_bar()

# Weighted by carat
ggplot(diamonds, aes(color)) + 
  geom_bar(aes(weight = carat)) + 
  scale_y_continuous("carat")
```

(Mention the other type of bar plot where the data is already summarised)

### Time series with line and path plots {#sub:line}

Line and path plots are typically used for time series data. Line plots join the points from left to right, while path plots join them in the order that they appear in the dataset (a line plot is just a path plot of the data sorted by x value).  Line plots usually have time on the x-axis, showing how a single variable has changed over time.  Path plots show how two variables have simultaneously changed over time, with time encoded in the way that the points are joined together.

Because there is no time variable in the diamonds data, we use the `economics` dataset, which contains economic data on the US measured over the last 40 years. The figure below shows two plots of unemployment over time, both produced using `geom = "line"`. The first shows an unemployment rate and the second shows the median number of weeks unemployed. We can already see some differences in these two variables, particularly in the last peak, where the unemployment percentage is lower than it was in the preceding peaks, but the length of unemployment is high. \index{Time series!bivariate} \indexf{geom_line} \indexf{geom_path}

```{r line-employment, fig.show = "hold", fig.width = 4, fig.height = 2.4}
ggplot(economics, aes(date, unemploy / pop)) +
  geom_line()
ggplot(economics, aes(date, uempmed)) +
  geom_line()
```

To examine this relationship in greater detail, we would like to draw both time series on the same plot. We could draw a scatterplot of unemployment rate vs. length of unemployment, but then we could no longer see the evolution over time. The solution is to join points adjacent in time with line segments, forming a _path_ plot.

Below we plot unemployment rate vs. length of unemployment and join the individual observations with a path. Because of the many line crossings, the direction in which time flows isn't easy to see in the first plot. In the second plot, we apply the `colour` aesthetic to the line to make it easier to see the direction of time.

```{r path-employ, fig.show = "hold", fig.width = 4, fig.height = 2.4}
ggplot(economics, aes(unemploy / pop, uempmed)) + 
  geom_path() +
  geom_point()

year <- function(x) as.POSIXlt(x)$year + 1900
ggplot(economics, aes(unemploy / pop, uempmed)) + 
  geom_path() +
  geom_point(aes(colour = year(date))) 
```

We can see that percent unemployed and length of unemployment are highly correlated, although in recent years the length of unemployment has been increasing relative to the unemployment rate.

With longitudinal data, you often want to display multiple time series on each plot, each series representing one individual. To do this you need to map the `group` aesthetic to a variable encoding the group membership of each observation. This is explained in more depth in [grouping](#sub:grouping). \index{Longitudinal data|see{Time series}} \index{Data!longitudinal}

### Exercises

1.  Facetting vs. aesthetics.

## `qplot()` shortcut


