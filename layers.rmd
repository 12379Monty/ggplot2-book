---
bibliography: references.bib
---

```{r layers, echo=FALSE}
source("common.r")
columns(1, 2 / 3)
```

# Build a plot layer by layer {#cha:layers}

## Introduction

One of the key ideas behind ggplot2 is that it allows you to easy iterate, building up a complex plot a layer at a time. Each layer can come from a different dataset and have a different aesthetic mappings, making it possible to create sophisticated plots that display data from multiple sources.

You've already created many layers with tools like `geom_point()` and `geom_histogram()`. In this chapter, we'll dive into the details of a layer, and how you can control all five components: data, the aesthetic mappings, the geom, stat, and position adjustments. The goal here is to give you the tools to build sophisticated plots tailored to the problem at hand. The next chapter, the "toolbox", uses these basic principles to solve specific visualisation problems. These two chapters are companions, with this chapter explaining the theory and the next chapter explaining the practical aspects of using layers to achieve your graphical goals.

## Building a plot

So far, whenever we've created a plot with `ggplot()`, we've immediately added on a layer with a geom function. But it's important to realise that there really are two distinct steps. First we create a plot with default dataset and aesthetic mappings:

```{r layer1, error = TRUE}
p <- ggplot(mpg, aes(displ, hwy))
p
```

The plot can't be displayed until we add a layer: there is nothing to see!

```{r}
p + geom_point()
```

The `geom_point()` code is a shortcut. Behind the scenes, `geom_point()` calls the `layer()` function to create a new layer:

```{r layer2, eval = FALSE}
p + layer(
  mapping = NULL, data = NULL,
  geom = "point", geom_params = list(),
  stat = "identity", stat_params = list(),
  position = "identity"
)
```

This fully specifies the five components to the layer:

*   __mapping__: A set of aesthetic mappings, specified using the 
    `aes()` function and combined with the plot defaults as described in 
    [aesthetic mappings](#sec:aes). If `NULL`, uses the default mapping
    set in `ggplot()`.

*   __data__: A dataset which overrides the default plot dataset. It usually
    omitted (set to `NULL`), in which case the layer will use the default plot 
    data specified in `ggplot()`. See [data](#sec:data).
  
*   __geom__ or __stat__: The name of the geometric object and statistical
    transformation to set. You only need to set one: every geom has a default 
    stat, and every stat a default geom. Both geoms and stats have additional 
    parameters. Geoms can take any aesthetic as a fixed value in which case it 
    will be set, rather than mapped, as explained in 
    [setting vs. mapping](#sub:setting-mapping) for more examples. Most stats 
    take additional parameters to specify the details of statistical 
    transformation.

    There are two ways to supply parameters to the geom or stat. You can either 
    supply them in `...` and ggplot2 will attempt to guess which parameters 
    belong to the stat and which to the geom. Alternatively, you can supply in 
    individual lists to arguments `geom_param` and `stat_param`.

*   __position__: Choose a method for adjusting overlapping objects, 
    as described in [position](#sec:position).

It's useful to understand the `layer()` function so you have a better mental model of the layer object. But because the full `layer()` call is so verbose, so you'll rarely use it. Instead, you'll use the shortcut `geom_` functions. `geom_point(mapping, data, ...)` is exactly equivalent to `layer(mapping, data, geom = "point", ...)`.

## Data {#sec:data}

Every layer must have some data associated with it, and that data must always be in a data frame. This is a strong restriction, but there are good reasons for it: \index{Data} \indexc{data.frame}

* Your data is very important, and it's best to be explicit about it

* A single data frame is also easier to save than a multitude of vectors, which 
  means it's easier to reproduce your results or send your data to someone else.  

* It enforces a clean separation of concerns: ggplot2 turns data frames into
  visualisations. Other packages can make data frames in the right format.
  
The data on each layer doesn't need to be the same, and it's often useful to combine multiple datasets in a single plot. To illustrate that idea I'm going to generate two new datasets related to the mpg dataset. First I'll fit a loess model and generate predictions from it. (This is what `geom_smooth()` does behind the scenes)

```{r loess-pred}
mod <- loess(hwy ~ displ, data = mpg)
grid <- data.frame(displ = seq(min(mpg$displ), max(mpg$displ), length = 50))
grid$hwy <- predict(mod, newdata = grid)

head(grid)
```

Next, I'll isolate observations that are particularly far away from their predicted value:

```{r loess-outlier}
std_resid <- resid(mod) / mod$s
outlier <- subset(mpg, abs(std_resid) > 1.5)
```

I've generated these datasets because it's common to enhance the display of raw data with a statistical summary and some annotations. With these new datasets, I can improve our initial scatterplot by overlaying a smoothed line, and labelling the particularly outlying points:

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_line(data = grid) + 
  geom_text(data = outlier, aes(label = model))
```

(The text labels aren't particularly easy to read, but you'll learn how to improve those in [polishing]{#cha:polishing}.)

In this example, every layer uses a different dataset. We could define it another way, omitting the default dataset:

```{r, eval = FALSE}
ggplot(mapping = aes(displ, hwy)) + 
  geom_point(data = mpg) + 
  geom_line(data = grid) + 
  geom_text(data = outlier, aes(label = model))
```

However, I don't particularly like this style because here it makes it less clear what the primary dataset is (and because of the way that the arguments to `ggplot()` are ordered, it actually requires more keypresses!).  However, you may prefer it in cases where there isn't clearly one primary datasets, or where the aesthetics also vary from layer to layer. Just remember that if you omit the data set in the call to `ggplot()` you must explicitly supply a dataset for every layer.

One caveat is related to faceting: you must specify a default dataset when you use faceting. Faceting is a global operation (i.e., it works on all layers) so it needs to have a base dataset that defines the set of facets for all datasets.  See [missing faceting variables](#sub:missing-faceting-columns) for more details. 

Note that the order of `data` and `mapping` arguments is switched between `ggplot()` and the layer functions. This is because you almost always specify data for the plot, and almost always specify aesthetics---but *not* data---for the layers. I recommend naming all other arguments rather than relying on positional matching. This makes the code more readable and is the style followed in this book.

### Exercises

1. 

## Aesthetic mappings {#sec:aes}

To describe the way that variables in the data are mapped to things that we can perceive on the plot (the 'aesthetics'), we use the `aes()` function.  The `aes()` function takes a list of aesthetic-variable pairs like these: \index{Mappings} \index{Aesthetics!mappings|see{Mappings}} \indexf{aes}

```{r layer11, eval=FALSE}
aes(x = displ, y = hwy, colour = class)
```

Here we are mapping x-position to weight, y-position to height and colour to age.  The first two arguments can be left without names, in which case they correspond to the x and y variables. 

```{r layer12, eval=FALSE}
aes(displ, hwy, colour = class)
```

(And if you're American, you can use _color_, behind the scenes ggplot2 will correct your spelling ;)

Avoid referring to variables outside the layer data (e.g., with `diamonds$carat`). This breaks containment, so that the plot no longer contains everything it needs. Generally, it's good practice to minimise data manipulation inside the plot. If you're doing complex transformations in the `aes()` call it's better to move them outside and explicitly create news (which you'll learn more about in XYZ). This is often faster (because you need only do the transformation once, not every time the plot is drawn), and makes it easier to check your work.

(This is a slight simplification: every ggplot object also has an environment associated with it, so you can use objects in that environment. However, it's best not to rely on this as it prevents the plot from being self-contained which can cause problems if you later re-use the plot in a different environment. Also ggplot2 was written before I fully understood non-standard evaluation in R, which means it's not as reliable as it could be.)

### Map in the plot vs. mapping in layers {#sub:plots-and-layers}

Aesthetic mappings can be supplied in the initial `ggplot()` call, in individual layers, or in some combination of both. All of these calls create the same plot specification:

```{r, eval = FALSE}
ggplot(mpg, aes(displ, hwy, colour = class)) + 
  geom_point()
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))
ggplot(mpg, aes(displ)) + 
  geom_point(aes(y = hwy, colour = class))
ggplot(mpg) + 
  geom_point(aes(displ, hwy, colour = class))
```

You can add, override, or remove mappings:

|Operation |Layer aesthetics    |Result                       |
|:---------|:-------------------|:----------------------------|
|Add       |`aes(colour = cyl)` |`aes(mpg, wt, colour = cyl)` |
|Override  |`aes(y = disp)`     |`aes(mpg, disp)`             |
|Remove    |`aes(y = NULL)`     |`aes(mpg)`                   |

If you only have one layer in the plot, the way you specify aesthetics doesn't make any difference. However, the distinction is important when you started adding additional layers. These two plots are both valid and interesting, but focus on quite different aspects of the data:

`r columns(2, 2 / 3)`

```{r, message = FALSE, warning = FALSE}
ggplot(mpg, aes(displ, hwy, colour = class)) + 
  geom_point() + 
  geom_smooth(se = FALSE)

ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) + 
  geom_smooth(se = FALSE)
```

Generally, you want to set up the mappings to illuminate the structure underlying the graphic and minimise typing. It may take some time before the best approach is immediately obvious to you. If you're iterated your way to a complex graphic, it may be worthwhile 

### Setting vs. mapping {#sub:setting-mapping}

Instead of mapping an aesthetic property to a variable, you can set it to a _single_ value by specifying it in the layer parameters. Aesthetics can vary for each observation being plotted, while parameters do not. We **map** an aesthetic to a variable (e.g., `aes(colour = cut)`) or **set**  it to a constant (e.g., `colour = "red"`).  For example, the following layer sets the colour of the points, using the colour parameter of the layer: \index{Aesthetics!setting|textbf}

`r columns(1, 1, 0.5)`
```{r layer15}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(colour = "darkblue") 
```

This sets the point colour to be dark blue instead of black. This is quite different than

```{r layer16}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(aes(colour = "darkblue"))
```

This **maps** (not sets) the colour to the value 'darkblue'. This effectively creates a new variable containing only the value 'darkblue' and then scales it with a colour scale.  Because this value is discrete, the default colour scale uses evenly spaced colours on the colour wheel, and since there is only one value this colour is pinkish. 

A third approach is to map the value, but override the default scale:

```{r}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(aes(colour = "darkblue")) + 
  scale_colour_identity()
```

This is most useful if you always have a column that contains colours. You'll learn more about that in [the identity scale](#sub:scale-identity).

It's sometimes useful to map aesthetics to constants. For example, if you want to display multiple layers with varying parameters, you can use this technique to automatically pick colours and create a legend:

`r columns(1, 2 / 3)`
```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  geom_smooth(aes(colour = "loess"), method = "loess", se = FALSE) + 
  geom_smooth(aes(colour = "lm"), method = "lm", se = FALSE)
```

You'll learn how to override the legend title in [legends and axes](#sec:guides).

## Geoms {#sec:geom}

Geometric objects, or **geoms** for short, perform the actual rendering of the layer, control the type of plot that you create.  For example, using a point geom will create a scatterplot, while using a line geom will create a line plot.  Table \ref{tbl:geoms} lists all of the geoms available in `ggplot`. 

Each geom has a set of aesthetics that it understands, and a set that are required for drawing.  For example, a point requires x and y position, and understands colour, size and shape aesthetics.  A bar requires height (`ymax`), and understands width, border colour and fill colour.  These are listed for all geoms in Table \ref{tbl:geom-aesthetics}. \indexf{geom_bar}

Some geoms differ primarily in the way that they are parameterised.  For example, the tile geom is specified in terms of the location of its centre and its height and width, while the rect geom is parameterised in terms of its top (`ymax`), bottom (`ymin`), left (`xmin`) and right (`right`) positions. \indexf{geom_rect}  Internally, the rect geom is described as a polygon, and its parameters are the locations of the four corners.  This is useful for non-Cartesian coordinate systems, as you will learn in [position](#cha:position). \index{Geoms!parameterisation}

Every geom has a default statistic, and every statistic a default geom.  For example, the bin statistic defaults to using the bar geom to produce a histogram.  These defaults are listed in Table \ref{tbl:geom-aesthetics}.  Overriding these defaults will still produce valid plots, but they may violate graphical conventions.  See examples in [combining geoms and stats](#sub:new-plot-types). \index{Geoms!defaults}

<!-- 
\input{tbls/geoms}
\input{tbls/geom-aesthetics}
-->

## Stat {#sec:stat}

A statistical transformation, or **stat**, transforms the data, typically by summarising it in some manner.  For example, a useful stat is the smoother, which calculates the mean of y, conditional on x, subject to some restriction that ensures smoothness. All currently available stats are listed in Table \ref{tbl:stats}.  To make sense in a graphic context a stat must be location-scale invariant: $\mbox{f}(x + a) = \mbox{f}(x) + a$ and $\mbox{f}(b \cdot x) = b \cdot \mbox{f}(x)$.  This ensures that the transformation stays the same when you change the scales of the plot.

\input{tbls/stats}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aliased geom & Base geom & Changes in default \\
    \midrule
    area      & ribbon & \verb!aes(min = 0, max = y), position = "stack"!  \\
    density   & area   & \verb!stat = "density"!    \\
    freqpoly  & line   & \verb!stat = "bin"!        \\
    histogram & bar    & \verb!stat = "bin"!        \\
    jitter    & point  & \verb!position = "jitter"! \\
    quantile  & line   & \verb!stat = "quantile"!   \\
    smooth    & ribbon & \verb!stat = "smooth"!     \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms that were created by modifying the defaults of another geom.}
  \label{tbl:aliased-geoms}
\end{table}

### Generated variables

A stat takes a dataset as input and returns a dataset as output, and so a stat can add new variables to the original dataset.  It is possible to map aesthetics to these new variables.  For example, `stat_bin`, the statistic used to make histograms, produces the following variables: \index{Stats!creating new variables} \indexf{stat_bin}

* `count`, the number of observations in each bin
* `density`, the density of observations in each bin (percentage of total / bar width)
* `x`, the centre of the bin

These generated variables can be used instead of the variables present in the original dataset.  For example, the default histogram geom assigns the height of the bars to the number of observations (`count`), but if you'd prefer a more traditional histogram, you can use the density (`density`).   The following example shows a density histogram of `carat` from the diamonds dataset.

```{r hist}
ggplot(diamonds, aes(carat)) + 
  geom_histogram(aes(y = ..density..), binwidth = 0.1)
```

The names of generated variables must be surrounded with `..` when used.  This prevents confusion in case the original dataset includes a variable with the same name as a generated variable, and it makes it clear to any later reader of the code that this variable was generated by a stat.  Each statistic lists the variables that it creates in its documentation. \indexc{..}

## Position adjustments {#sec:position}

Position adjustments apply minor tweaks to the position of elements within a layer.  Table \ref{fig:position} lists all of the position adjustments available within `ggplot`.  Position adjustments are normally used with discrete data.  Continuous data typically doesn't overlap exactly, and when it does (because of high data density) minor adjustments, like jittering, are usually insufficient to fix the problem. \index{Position adjustments} \index{Adjustments!position}  \index{Positioning!position adjustments}

\input{tbls/position}

The different types of adjustment are best illustrated with a bar chart.  Figure \ref{fig:position-bar} shows stacking, filling and dodging.  Stacking puts bars on the same x on top of one another; filling does the same, but normalises height to 1; and dodging places the bars side-by-side.  Dodging is rather similar to faceting, and the advantages and disadvantages of each method are described in [dodging vs. faceting](#sub:dodge-vs-facet). For these operations to work, each bar must have the same width and not overlap with any others.  The identity adjustment (i.e., do nothing) doesn't make much sense for bars, but is shown in Figure \ref{fig:position-identity} along with a line plot of the same data for reference. \index{Dodging} \index{Side-by-side|see{Dodging}} \index{Stacking} \indexf{position_dodge} \indexf{position_fill}  \indexf{position_stack} \indexf{geom_bar}

`r columns(3, 2 / 3)`
```{r position-bar}
dplot <- ggplot(diamonds, aes(clarity, fill = cut)) + 
  theme(legend.position = "none")
dplot + geom_bar(position = "stack")
dplot + geom_bar(position = "fill")
dplot + geom_bar(position = "dodge")
```

The identity positon adjustment is not useful for bars, because each bar obscures the bars behind. A frequency polygon is a better technique here.

`r columns(2, 2 / 3)`
```{r position-identity}
dplot + geom_bar(position = "identity")

ggplot(diamonds, aes(clarity, colour = cut)) + 
  geom_freqpoly(aes(group = cut)) + 
  theme(legend.position = "none")
```

## Pulling it all together {#sec:pull-together}

Once you have become comfortable with combining layers, you will be able to create graphics that are both intricate and useful.  The following examples demonstrate some of the ways to use the capabilities of layers that have been introduced in this chapter.  These are just to get you started. You are limited only by your imagination!

### Combining geoms and stats {#sub:new-plot-types}

By connecting geoms with different statistics, you can easily create new graphics. The code below creates three variations on a histogram. They all use the same statistical transformation underlying a histogram (the bin stat), but use different geoms to display the results: the area geom, the point geom and the tile geom.  \index{Geoms!combining with stats} \index{Stats!combining with geoms}

A number of the geoms available in `ggplot` were derived from other geoms in a process like the one just described, starting with an existing geom and making a few changes in the default aesthetics or stat.  For example, the jitter geom is simply the point geom with the default position adjustment set to jitter.  Once it becomes clear that a particular variant is going to be used a lot or used in a very different context, it makes sense to create a new geom. Table \ref{tbl:aliased-geoms} lists these ``aliased'' geoms. \index{Geoms!aliases}

### Varying aesthetics and data {#sub:different-aesthetics}

One of the more powerful capabilities of `ggplot` is the ability to plot different datasets on different layers. This may seem strange: Why would you want to plot different data on the same plot?  In practice, you often have related datasets that should be shown together.  A very common example is supplementing the data with predictions from a model.  While the smooth geom can add a wide range of different smooths to your plot, it is no substitute for an external quantitative model that summarises your understanding of the data.
