---
title: layers
output: bookdown::html_chapter
bibliography: references.bib
---

```{r layers, echo=FALSE}
library("ggplot2")
```

# Build a plot layer by layer {#cha:layers}

## Introduction

Layering is the mechanism by which additional data elements are added to a plot. Each layer can come from a different dataset and have a different aesthetic mapping, making it possible to create sophisticated plots that display data from multiple sources.

This chapter focusses on the basics of how layers, geoms, statistics and position adjustments work: how you call and customise them. The next chapter, the "toolbox", describes how you can use different geoms and stats to solve particular visualisation problems. These two chapters are companions, with this chapter explaining the theory and the next chapter explaining the practical aspects of using layers to achieve your graphical goals.

So far, whenever we've created a plot with `ggplot()`, we've immediately added on a geom. But it's possible to break that up into two steps: first defining the plot, then adding layers:

```{r layer1, error = TRUE}
p <- ggplot(mpg, aes(displ, hwy))
p
```

This plot object cannot be displayed until we add a layer: there is nothing to see!

```{r}
p + geom_point()
```

The above code is a shortcut. Behind the scenes, `geom_point()` calls the `layer()` function to create a new layer:

```{r layer2, eval = FALSE}
p + layer(
  mapping = NULL, data = NULL,
  geom = "point", geom_params = list(),
  stat = "identity", stat_params = list(),
  position = "identity"
)
```

This fully specifies the five components to the layer:

*   __mapping__: A set of aesthetic mappings, specified using the 
    `aes()` function and combined with the plot defaults as described in 
    [aesthetic mappings](#sec:aes). If `NULL`, uses the default mapping
    set in `ggplot()`.

*   __data__: A dataset which overrides the default plot dataset. It usually
    omitted (set to `NULL`), in which case the layer will use the default plot 
    data specified in `ggplot()`. See [data](#sec:data).
  
*   __geom__ or __stat__: The name of the geometric object and statistical
    transformation to set. You only need to set one: every geom has a default 
    stat, and every stat a default geom. Both geoms and stats have additional 
    parameters. Geoms can take any aesthetic as a fixed value in which case it 
    will be set, rather than mapped, as explained in 
    [setting vs. mapping](#sub:setting-mapping) for more examples. Most stats 
    take additional parameters to specify the details of statistical 
    transformation.

    There are two ways to supply parameters to the geom or stat. You can either 
    supply them in `...` and ggplot2 will attempt to guess which parameters 
    belong to the stat and which to the geom. Alternatively, you can supply in 
    individual lists to arguments `geom_param` and `stat_param`.

*   __position__: Choose a method for adjusting overlapping objects, 
    as described in [position](#sec:position).

It's useful to understand the `layer()` function so you have a better mental model of the layer object itself. The full specification is verbose, so you'll rarely use it. Instead, you'll use the shortcut `geom_` functions.

## Specifying layers

Note that the order of `data` and `mapping` arguments is switched between `ggplot()` and the layer functions. This is because you almost always specify data for the plot, and almost always specify aesthetics---but *not* data---for the layers. I recommend naming all other arguments rather than relying on positional matching. This makes the code more readable and is the style followed in this book.

## Data {#sec:data}

The restriction on the data is simple: it must be a data frame. \index{Data} \indexc{data.frame} This is restrictive, and unlike other graphics packages in R.  Lattice functions can take an optional data frame or use vectors directly from the global environment.  Base methods often work with vectors, data frames or other R objects.  However, there are good reasons for this restriction. Your data is very important, and it's better to be explicit about exactly what is done with it.  It also allows a cleaner separation of concerns so that `ggplot()` deals only with plotting data, not wrangling it into different forms, for which you might find the dplyr, tidyr and broom packages helpful. A single data frame is also easier to save than a multitude of vectors, which means it's easier to reproduce your results or send your data to someone else.  

If you use two datasets in a plot, there are two basic ways to specify the plot:

```{r, eval = FALSE}
ggplot(df1, aes(x, y)) + 
  geom_point() + 
  geom_point(data = df2)

ggplot(mapping = aes(x, y)) + 
  geom_point(data = df1) + 
  geom_point(data = df2)
```

If you have multiple layers, use the first form, and set the default dataset to the most commonly used plot. Otherwise, I think it's clearer to use the second form. If the default dataset is omitted, every layer must supply its own data.

One caveat is relate to faceting: you must specify a default dataset when you use faceting. Faceting is a global operation (i.e., it works on all layers) so it needs to have a base dataset that defines the set of facets for all datasets.  See [missing faceting variables](#sub:missing-faceting-columns) for more details. 

## Aesthetic mappings {#sec:aes}

To describe the way that variables in the data are mapped to things that we can perceive on the plot (the 'aesthetics'), we use the `aes()` function.  The `aes()` function takes a list of aesthetic-variable pairs like these: \index{Mappings} \index{Aesthetics!mappings|see{Mappings}} \indexf{aes}

```{r layer11, eval=FALSE}
aes(x = displ, y = hwy, colour = class)
```

Here we are mapping x-position to weight, y-position to height and colour to age.  The first two arguments can be left without names, in which case they correspond to the x and y variables. 

```{r layer12, eval=FALSE}
aes(displ, hwy, colour = class)
```

(And if you're American, you can use _color_, behind the scenes ggplot2 will correct your spelling ;)

Avoid referring to variables outside the layer data (e.g., with `diamonds$carat`). This breaks containment, so that the plot no longer contains everything it needs. Generally, it's good practice to minimise data manipulation inside the plot. If you're doing complex transformations in the `aes()` call it's better to move them outside and explicitly create news (which you'll learn more about in XYZ). This is often faster (because you need only do the transformation once, not every time the plot is drawn), and makes it easier to check your work.

### Map in the plot vs. mapping in layers {#sub:plots-and-layers}

Aesthetic mappings can be supplied in the initial `ggplot()` call, in individual layers, or in some combination of both. All of these calls create the same plot specification:

```{r, eval = FALSE}
ggplot(mpg, aes(displ, hwy, colour = class)) + 
  geom_point()
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))
ggplot(mpg, aes(displ)) + 
  geom_point(aes(y = hwy, colour = class))
ggplot(mpg) + 
  geom_point(aes(displ, hwy, colour = class))
```

You can add, override, or remove mappings:

|Operation |Layer aesthetics    |Result                       |
|:---------|:-------------------|:----------------------------|
|Add       |`aes(colour = cyl)` |`aes(mpg, wt, colour = cyl)` |
|Override  |`aes(y = disp)`     |`aes(mpg, disp)`             |
|Remove    |`aes(y = NULL)`     |`aes(mpg)`                   |

If you only have one layer in the plot, the way you specify aesthetics doesn't make any difference. However, the distinction is important when you started adding additional layers. These two plots are both valid and interesting, but focus on quite different aspects of the data:

```{r, message = FALSE, warning = FALSE}
ggplot(mpg, aes(displ, hwy, colour = class)) + 
  geom_point() + 
  geom_smooth(se = FALSE)

ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) + 
  geom_smooth(se = FALSE)
```

Generally, you want to set up the mappings to illuminate the structure underlying the graphic and minimise typing. It may take some time before the best approach is immediately obvious to you. If you're iterated your way to a complex graphic, it may be worthwhile 

### Setting vs. mapping {#sub:setting-mapping}

Instead of mapping an aesthetic property to a variable, you can set it to a _single_ value by specifying it in the layer parameters. Aesthetics can vary for each observation being plotted, while parameters do not. We **map** an aesthetic to a variable (e.g., `aes(colour = cut)`) or **set**  it to a constant (e.g., `colour = "red"`).  For example, the following layer sets the colour of the points, using the colour parameter of the layer: \index{Aesthetics!setting|textbf}

```{r layer15}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(colour = "darkblue") 
```

This sets the point colour to be dark blue instead of black. This is quite different than

```{r layer16}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(aes(colour = "darkblue"))
```

This **maps** (not sets) the colour to the value 'darkblue'. This effectively creates a new variable containing only the value 'darkblue' and then scales it with a colour scale.  Because this value is discrete, the default colour scale uses evenly spaced colours on the colour wheel, and since there is only one value this colour is pinkish. 

A third approach is to map the value, but override the default scale:

```{r}
ggplot(mpg, aes(cty, hwy)) + 
  geom_point(aes(colour = "darkblue")) + 
  scale_colour_identity()
```

This is most useful if you always have a column that contains colours. You'll learn more about that in [the identity scale](#sub:scale-identity).

It's sometimes useful to map aesthetics to constants. For example, if you want to display multiple layers with varying parameters, you can use this technique to automatically pick colours and create a legend:

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  geom_smooth(aes(colour = "loess"), method = "loess", se = FALSE) + 
  geom_smooth(aes(colour = "lm"), method = "lm", se = FALSE)
```

You'll learn how to override the legend title in [legends and axes](#sec:guides).

### Grouping {#sub:grouping}

Geoms can be roughly divided into individual and collective geoms. An individual geom has a distinct graphical object for each row (observation). For example, the point geom has a single point for each observation. On the other hand, collective geoms display multiple observations with one geometric object. This may be a result of a statistical summary, or may be fundamental to the display of the geom, as with polygons.  Lines and paths fall somewhere in between:  each overall line is composed of a set of straight segments, but each segment represents two points. How do we control which observations go in which individual graphical element?  This is the job of the `group` aesthetic.  \index{Grouping}

By default, the `group` is set to the interaction of all discrete variables in the plot.  This often partitions the data correctly, but when it does not, or when no discrete variable is used in the plot, you will need to explicitly define the grouping structure, by mapping group to a variable that has a different value for each group.

There are three common cases where the default is not enough, and we will consider each one below. In the following examples, we will use a simple longitudinal dataset, `Oxboys`, from the **nlme** package.  It records the heights (`height`) and centered ages (`age`) of 26 boys (`Subject`), measured on nine occasions (`Occasion`). \index{Package!nlme}

```{r oxboys}
data(Oxboys, package = "nlme")
head(Oxboys)
```

#### Multiple groups, one aesthetic

In many situations, you want to separate your data into groups, but render them in the same way.  When looking at the data in aggregate you want to be able to distinguish individual subjects, but not identify them.  This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots. For example, the following plot shows the growth trajectory for each boy (each `Subject`): \index{Data!longitudinal}    \indexf{geom_line}

```{r oxboys-line}
ggplot(Oxboys, aes(age, height, group = Subject)) + 
  geom_line()
```

If you incorrectly specify the grouping variable, you'll get a characteristic sawtooth appearance:

```{r oxboys-line-bad}
ggplot(Oxboys, aes(age, height)) + 
  geom_line()
```

If a group isn't defined by a single variable, but instead by a combination of multiple variables, you can use `interaction()` to combine them, e.g. `aes(group = interaction(school_id, student_id))`.

#### Different groups on different layers

Sometimes we want to plot summaries based on different levels of aggregation. Different layers might have different group aesthetics, so that some display individual level data while others display summaries of larger groups. \indexf{geom_smooth}

Building on the previous example, suppose we want to add a single smooth line to the plot just created, based on the ages and heights of *all* the boys.  If we use the same grouping in both layers, we get one smooth per boy:

```{r layer18}
ggplot(Oxboys, aes(age, height, group = Subject)) + 
  geom_line() + 
  geom_smooth(method = "lm", se = FALSE)
```

This is not what we wanted; we have inadvertently added a smoothed line for each boy. Instead of setting the grouping aesthetic in `ggplot()`, where it will apply to all layers, we instead set it in `geom_line()` so it affects the lines, but not the smooths:

```{r layer19, eval = FALSE}
ggplot(Oxboys, aes(age, height)) + 
  geom_line(aes(group = Subject)) + 
  geom_smooth(method = "lm", size = 2, se = FALSE)
```

#### Overriding the default grouping

The plot has a discrete scale but you want to draw lines that connect *across* groups. This is the strategy used in interaction plots, profile plots, and parallel coordinate plots, among others.

For example, imagine we've drawn boxplots of height at each measurement occasion: \indexf{geom_boxplot}

```{r oxbox}
ggplot(Oxboys, aes(Occasion, height)) + 
  geom_boxplot()
```

There is no need to specify the group aesthetic here; the default grouping works because occasion is a discrete variable. Now we want to overlay lines that connect each individual boy. Simply adding `geom_line()` does not work:

```{r oxbox-line-bad}
ggplot(Oxboys, aes(Occasion, height)) + 
  geom_boxplot() +
  geom_line(colour = "#3366FF", alpha = 0.5)
```

The default grouping uses `Occasion` because it's categorical. To get the plot we want, we need to override the grouping:

```{r oxbox-line}
ggplot(Oxboys, aes(Occasion, height)) + 
  geom_boxplot() +
  geom_line(aes(group = Subject), colour = "#3366FF", alpha = 0.5)
```

I changed the line colour in the second layer to make it easier to distinguish lines from boxplots. This is another example of setting an aesthetic to a fixed value. \index{Aesthetics!setting}

### Matching aesthetics to graphic objects {#sub:matching}

Another important issue with collective geom is how the aesthetics of the individual observations are mapped to the aesthetics of the complete entity.  For individual geoms, this isn't a problem, because each observation is represented by a single graphical element.  However, high data densities can make it difficult (or impossible) to distinguish between individual points and in some sense the point geom becomes a collective geom, a single blob of points. \index{Aesthetics!matching to geoms}

Lines and paths operate on an off-by-one principle: there is one more observation than line segment, and so the aesthetic for the first observation is used for the first segment, the second observation for the second segment and so on.  This means that the aesthetic for the last observation is not used, as shown in Figure \ref{fig:matching-lines}.  An additional limitation for paths and lines is that that line type must be constant over each individual line, in R there is no way to draw a line which has varying line type. \indexf{geom_line} \indexf{geom_path}

```{r}
df <- data.frame(x = 1:3, y = 1:3, colour = c(1,3,5))

ggplot(df, aes(x, y, colour = factor(colour))) + 
  geom_line(aes(group = 1), size = 2) +
  geom_point(size = 5)

ggplot(df, aes(x, y, colour = colour)) + 
  geom_line(aes(group = 1), size = 2) +
  geom_point(size = 5)
```

You could imagine a more complicated system where segments smoothly blend from one aesthetic to another. This would work for continuous variables like size or colour, but not for line type, and is not used in ggplot2. If this is the behaviour you want, you can perform the linear interpolation yourself:

```{r matching-lines2}
xgrid <- with(df, seq(min(x), max(x), length = 50))
interp <- data.frame(
  x = xgrid,
  y = approx(df$x, df$y, xout = xgrid)$y,
  colour = approx(df$x, df$colour, xout = xgrid)$y  
)
ggplot(interp, aes(x, y, colour = colour)) + 
  geom_line(size = 2) +
  geom_point(data = df, size = 5)
```

For all other collective geoms, like polygons, the aesthetics from the individual components are only used if they are all the same, otherwise the default value is used. This makes sense for fill as it is a property of the entire object: it doesn't make sense to think about having a different fill colour for each point on the border of the polygon. \indexf{geom_polygon}

These issues are most relevant when mapping aesthetics to continuous variables, because, as described above, when you introduce a mapping to a discrete variable, it will by default split apart collective geoms into smaller pieces. This works particularly well for bar and area plots, because stacking the individual pieces produces the same shape as the original ungrouped data:

```{r bar-split}
ggplot(mpg, aes(class)) + 
  geom_bar()
ggplot(mpg, aes(class, fill = drv)) + 
  geom_bar()
```

### Exercises

1.  Simplify

1.  When illustrating the difference between mapping continuous and discrete
    colours to a line, the discrete example needed `aes(group = 1)`. Why?
    What happens if that is ommitted?

1.  Create a bar chart of class, with filled by highway mpg. What two aesthetics
    do you need to set?

## Geoms {#sec:geom}

Geometric objects, or **geoms** for short, perform the actual rendering of the layer, control the type of plot that you create.  For example, using a point geom will create a scatterplot, while using a line geom will create a line plot.  Table \ref{tbl:geoms} lists all of the geoms available in `ggplot`. 

Each geom has a set of aesthetics that it understands, and a set that are required for drawing.  For example, a point requires x and y position, and understands colour, size and shape aesthetics.  A bar requires height (`ymax`), and understands width, border colour and fill colour.  These are listed for all geoms in Table \ref{tbl:geom-aesthetics}. \indexf{geom_bar}

Some geoms differ primarily in the way that they are parameterised.  For example, the tile geom is specified in terms of the location of its centre and its height and width, while the rect geom is parameterised in terms of its top (`ymax`), bottom (`ymin`), left (`xmin`) and right (`right`) positions. \indexf{geom_rect}  Internally, the rect geom is described as a polygon, and its parameters are the locations of the four corners.  This is useful for non-Cartesian coordinate systems, as you will learn in [position](#cha:position). \index{Geoms!parameterisation}

Every geom has a default statistic, and every statistic a default geom.  For example, the bin statistic defaults to using the bar geom to produce a histogram.  These defaults are listed in Table \ref{tbl:geom-aesthetics}.  Overriding these defaults will still produce valid plots, but they may violate graphical conventions.  See examples in [combining geoms and stats](#sub:new-plot-types). \index{Geoms!defaults}

<!-- 
\input{tbls/geoms}
\input{tbls/geom-aesthetics}
-->

## Stat {#sec:stat}

A statistical transformation, or **stat**, transforms the data, typically by summarising it in some manner.  For example, a useful stat is the smoother, which calculates the mean of y, conditional on x, subject to some restriction that ensures smoothness. All currently available stats are listed in Table \ref{tbl:stats}.  To make sense in a graphic context a stat must be location-scale invariant: $\mbox{f}(x + a) = \mbox{f}(x) + a$ and $\mbox{f}(b \cdot x) = b \cdot \mbox{f}(x)$.  This ensures that the transformation stays the same when you change the scales of the plot.

\input{tbls/stats}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aliased geom & Base geom & Changes in default \\
    \midrule
    area      & ribbon & \verb!aes(min = 0, max = y), position = "stack"!  \\
    density   & area   & \verb!stat = "density"!    \\
    freqpoly  & line   & \verb!stat = "bin"!        \\
    histogram & bar    & \verb!stat = "bin"!        \\
    jitter    & point  & \verb!position = "jitter"! \\
    quantile  & line   & \verb!stat = "quantile"!   \\
    smooth    & ribbon & \verb!stat = "smooth"!     \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms that were created by modifying the defaults of another geom.}
  \label{tbl:aliased-geoms}
\end{table}


### Generated variables

A stat takes a dataset as input and returns a dataset as output, and so a stat can add new variables to the original dataset.  It is possible to map aesthetics to these new variables.  For example, `stat_bin`, the statistic used to make histograms, produces the following variables: \index{Stats!creating new variables} \indexf{stat_bin}

* `count`, the number of observations in each bin
* `density`, the density of observations in each bin (percentage of total / bar width)
* `x`, the centre of the bin

These generated variables can be used instead of the variables present in the original dataset.  For example, the default histogram geom assigns the height of the bars to the number of observations (`count`), but if you'd prefer a more traditional histogram, you can use the density (`density`).   The following example shows a density histogram of `carat` from the diamonds dataset.

```{r hist}
ggplot(diamonds, aes(carat)) + 
  geom_histogram(aes(y = ..density..), binwidth = 0.1)
```

The names of generated variables must be surrounded with `..` when used.  This prevents confusion in case the original dataset includes a variable with the same name as a generated variable, and it makes it clear to any later reader of the code that this variable was generated by a stat.  Each statistic lists the variables that it creates in its documentation. \indexc{..}

## Position adjustments {#sec:position}

Position adjustments apply minor tweaks to the position of elements within a layer.  Table \ref{fig:position} lists all of the position adjustments available within `ggplot`.  Position adjustments are normally used with discrete data.  Continuous data typically doesn't overlap exactly, and when it does (because of high data density) minor adjustments, like jittering, are usually insufficient to fix the problem. \index{Position adjustments} \index{Adjustments!position}  \index{Positioning!position adjustments}

\input{tbls/position}

The different types of adjustment are best illustrated with a bar chart.  Figure \ref{fig:position-bar} shows stacking, filling and dodging.  Stacking puts bars on the same x on top of one another; filling does the same, but normalises height to 1; and dodging places the bars side-by-side.  Dodging is rather similar to faceting, and the advantages and disadvantages of each method are described in [dodging vs. faceting](#sub:dodge-vs-facet). For these operations to work, each bar must have the same width and not overlap with any others.  The identity adjustment (i.e., do nothing) doesn't make much sense for bars, but is shown in Figure \ref{fig:position-identity} along with a line plot of the same data for reference. \index{Dodging} \index{Side-by-side|see{Dodging}} \index{Stacking} \indexf{position_dodge} \indexf{position_fill}  \indexf{position_stack} \indexf{geom_bar}

```{r position-bar}
dplot <- ggplot(diamonds, aes(clarity, fill = cut))
dplot + geom_bar(position = "stack")
dplot + geom_bar(position = "fill")
dplot + geom_bar(position = "dodge")
```

The identity positon adjustment is not useful for bars, because each bar obscures the bars behind. A frequency polygon is a better technique here.

```{r position-identity}
dplot + geom_bar(position = "identity")

ggplot(diamonds, aes(clarity, colour = cut)) + 
  geom_freqpoly(aes(group = cut))
```

## Pulling it all together {#sec:pull-together}

Once you have become comfortable with combining layers, you will be able to create graphics that are both intricate and useful.  The following examples demonstrate some of the ways to use the capabilities of layers that have been introduced in this chapter.  These are just to get you started. You are limited only by your imagination!

### Combining geoms and stats {#sub:new-plot-types}

By connecting geoms with different statistics, you can easily create new graphics. The code below creates three variations on a histogram. They all use the same statistical transformation underlying a histogram (the bin stat), but use different geoms to display the results: the area geom, the point geom and the tile geom.  \index{Geoms!combining with stats} \index{Stats!combining with geoms}

A number of the geoms available in `ggplot` were derived from other geoms in a process like the one just described, starting with an existing geom and making a few changes in the default aesthetics or stat.  For example, the jitter geom is simply the point geom with the default position adjustment set to jitter.  Once it becomes clear that a particular variant is going to be used a lot or used in a very different context, it makes sense to create a new geom. Table  \ref{tbl:aliased-geoms} lists these ``aliased'' geoms. \index{Geoms!aliases}

### Varying aesthetics and data {#sub:different-aesthetics}

One of the more powerful capabilities of `ggplot` is the ability to plot different datasets on different layers. This may seem strange: Why would you want to plot different data on the same plot?  In practice, you often have related datasets that should be shown together.  A very common example is supplementing the data with predictions from a model.  While the smooth geom can add a wide range of different smooths to your plot, it is no substitute for an external quantitative model that summarises your understanding of the data.
