\input{_header.tex}

\chapter{Writing your own}
\label{cha:writing-your-own}

\section{Introduction}

As you use \ggplot more, you may discover some of the limitations of the built in geom, stats and scales need to write your own.  This chapter provides a detailed description of how these objects work, including an introduction to \code{proto}, the object-oriented system that underlies \ggplot.

To get started, the first thing you should do is download a copy of the source code.  You can get this from CRAN: \url{http://cran.r-project.org/web/packages/ggplot2}.  Unpack it and familiarise yourself with the contents.  Each geom, stat and scale lives in it's own file, named the same way as the function.  

\section{Prototype based OO} % (fold)
\label{sec:proto}

One thing to note is that all ggplot2 objects (with the exception of the main plot object) are proto objects.  Proto is a package which implements the prototype-style of object-oriented programming.  There are some major differences between this and the typical S3 or S4 style of OO in R, but the good news is that you only need to worry about them if you want to develop your own extensions to ggplot2.  For everyday use, the proto objects are hidden behind a facade which makes them act like normal R objects.


References.
Prototype based inheritance.  IO, Javascript

Equivalence between new call and defaults.

Clone method to make behave like usual R objects.

Objname.

\section{Geoms}
\label{sec:own-geom}

\ggplot uses grid graphics, so to be able to create new geom functions you will need some familiarity with basic grid functions.  I'd recommend that you have a copy of Paul Murrell's ``R Graphics'' on hand, so that you can answer any question you have about the grid system.

The most important feature of the geom subclasses is the \f{draw} method.  This takes a dataset and some parameters, and produces a grid grob for rendering on the plot.  Everything else is documentation and defaults.  The listing below shows a slightly simplify version of the \f{draw} method from \code{geom_point}.  It's basically a thin wrapper around the grid method \f{pointsGrob}, mapping the aesthetics to the appropriate parameters.

% LISTING
% 
% draw <- function(., data, scales, coordinates, ...) {    
%   with(data, pointsGrob(
%       x, y, size = unit(size, "mm"), pch = shape, 
%       gp = gpar(col = colour, fill = fill, fontsize = size * .pt))
%   )
% }
\input{_include/46269db7257412d7f98ae3798cb8a7f0.tex}
% END

Grid uses points (a typographic unit of measure, there are 72 points to an inch) for font and line size, while \ggplot uses millimetres.  Multiplying the   measurement in mm by \code{.pt} converts it to points.  

This simplified version neglects two extra features that you'll see if you look at the actual source code.  You can ignore both of these issues while you are experimenting and getting the geom to work, but if you want others to be able to use your geom in a wide range of situations you'll need to give them some though.  You also need to:

\begin{itemize}
  \item Transform the components of the geom so that it works in any coordinate system: \verb|coordinates$transform(data, scales)|.  A lot of the time you can avoid doing this work by calling basic geoms that already do this work.  For example, see \f{geom_boxplot} or \f{geom_smooth}.  This is an important pattern: many complex geoms are aggregates of simpler geoms.  This was discussed in depth in Section~\ref{sub:coord-transformation}.

  \item Name the grid grob, so that it's possible to modify it after drawing.  This is sometimes necessary for advanced customisation, as discussed in Section~\ref{sec:grid-existing}.  You can use the \f{ggname} convenience function that gives the new grob a name consistent with the rest of \ggplot.
\end{itemize}

% LISTING
% 
% draw <- function(., data, scales, coordinates, ...) {    
%   with(coordinates$transform(data, scales), 
%     ggname(.$my_name(), pointsGrob(x, y, size=unit(size, "mm"), pch=shape, 
%     gp=gpar(col=colour, fill = fill, fontsize = size * .pt)))
%   )
% }
\input{_include/ac8ba20aeb951058dfd88e083ee7b22a.tex}
% END

The draw method has arguments:

\begin{itemize}
  \item Data.  By this point in the plotting pipeline, 

  \item Scales, a list with named components x and y, representing the position scales for the x and y axes.  It's unlikely you will need to use these, but it's useful if your geom needs to know exactly how big the plotting space is (e.g. abline, vline and hline).  These are explained in a little bit more detail below, but the method you are most likely to need is \f{output_set}, which gives the range of the output.

  \item Coordinates.  You will always need to \f{transform} the data.

  \item Any other parameters of the geom.  These aren't use very often.  For examples see geoms boxplot, step and crossbar.
\end{itemize}

Minimal complete example of GeomPoint.


\subsection{Dealing with coordinate systems}

The most complicated part of geoms is dealing with coordinate systems. If you are writing the geom for your own use, you can skip this section unless you are routinely using coordinate systems other than Cartesian.  You can also use the draw routines from other geoms (point, line and polygon) so that you don't need to worry about dealing with the coordinate system yourself.  If 

\paragraph{Reparameterising.} For geoms with aesthetics that give dimensions (width and height), it is necessary to reparameterise into locations (xmin, xmax, ymin, ymax).  This is  also important for position scales, so that they can allocate the correct amount of space.

\paragraph{Munching.} You can check if munching is necessary by looking at the boolean return value of \f{muncher}. 

\subsection{Defaults}
\label{sub:defaults}

\begin{itemize}
  \item \f{default_stat}, the default stat associated with the geom.
  
  \item \f{default_position}, the default position adjustment associated with the geom.

  \item \f{default_aes}, default aesthetic values
  
  \item \code{required_aes}, a vector of aesthetic names that are required in addition to the defaults.  Most geoms require at least x and y aesthetics.
  
\end{itemize}
% subsection defaults (end)

\subsection{The legend}
\label{sub:the_legend}

Each geom has a geom associated with it that is used for drawing the legend.  The name of this geom should be returned by the \f{guide_geom} method.  For example, the bar, tile and ribbon plots all use the same legend, which is provided by \code{geom_tile}.

The geom that draws the legend needs one additional method: \f{draw_legend}.  This method takes a data frame in same format as the draw method that contains a single observation and returns a grid grob representing the legend key for that element.  The grid grob should make no assumptions about the size of the space in which it will be drawn, and use the npc unit for positioning.

The legends provided \code{geom_path}, \code{geom_point}, and \code{geom_tile} provide the majority of legends in \ggplot.  They are all good places to start.  For examples of a more complicated legends see \code{geom_boxplot} and \code{geom_smooth}.

\subsection{Accessor methods}



\section{Statistical transformations}
\label{sec:own-stat}

Stat objects have a very similar structure to geoms, except here the main method is called \f{calculate}.  Most \f{calculate} methods are much more complicated than the \f{draw} methods.  This is because the transformations need to be able to work in a wide range of circumstances (necessitating checking for many special cases), and often have considerable logic for choosing good default parameter values.

The arguments for the \f{calculate} are same as \f{draw}, but there are a few differences

\begin{itemize}
  \item Data. By this point in the pipeline, all discrete variables have been converted to integers, so use \f{is.integer} if it's important whether a variable is continuous or discrete
  
  \item Scales.  Useful if you want to ensure that all .  This is important for stats like bin and density, where the values need to line up.  It is also an option to geom smooth: by default the smooth will only interpolate within a single group, not cover the full range of the data.

  \item Additional parameters are much more common in statistics than in geoms.
\end{itemize}

\section{Scales}
\label{sec:own-scale}

Continuous vs discrete.  

You need to provide the conversion function, \f{map}, as well as methods to choose the 

Lay out naming convention.

% breaks_user
% breaks_auto
% labels_user
% labels_auto ?

\f{output_breaks}

\f{labels}

\section{Documentation}
\label{sec:documentation}

If you fill out these fields informatively, you can easily generate html or rdoc documentation with the methods \f{rdoc_page_create} and \f{html_page_create}.

If you want to contribute your

\begin{itemize}
  \item \f{icon}
  \item \f{desc}
  \item \f{details}
  \item \f{desc_params}
  \item \f{desc_outputs}
  \item \f{seealso}
\end{itemize}

\input{_footer.tex}
