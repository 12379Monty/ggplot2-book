\input{_header.tex}

\chapter{Writing your own}

\section{Introduction}

As you use \ggplot more, you may discover some of the limitations of the built in geom, stats and scales need to write your own.  This chapter provides a detailed description of how these objects work, including an introduction to \code{proto}, the object-oriented system that underlies \ggplot.

To get started, the first thing you should do is download a copy of the source code.  You can get this from CRAN: \url{http://cran.r-project.org/web/packages/ggplot2}.  Unpack it and familiarise yourself with the contents.  Each geom, stat and scale lives in it's own file, named the same way as the function.  

\section{Prototype based OO} % (fold)
\label{sec:proto}

References.
Prototype based inheritance.  IO, Javascript

\section{Registration and documentation}

\section{Geoms}
\label{sec:own-geom}

\ggplot uses grid graphics, so to be able to create new geom functions you will need some familiarity with basic grid functions.  I'd recommend that you have a copy of Paul Murrell's ``R Graphics'' on hand, so that you can answer any question you have about the grid system.

The most important feature of the geom subclasses is the \f{draw} method.  This takes a dataset and some parameters, and produces a grid grob for rendering on the plot.  Everything else is documentation and defaults.  The listing below shows a slightly simplify version of the \f{draw} method from \code{geom_point}.  It's basically a thin wrapper around the grid method \f{pointsGrob}, mapping the aesthetics to the appropriate parameters.

% LISTING
% 
% draw <- function(., data, scales, coordinates, ...) {    
%   with(data, pointsGrob(
%       x, y, size = unit(size, "mm"), pch = shape, 
%       gp = gpar(col = colour, fill = fill, fontsize = size * .pt))
%   )
% }

Grid uses points (a typographic unit of measure, there are 72 points to an inch) for font and line size, while \ggplot uses millimetres.  Multiplying the   measurement in mm by \code{.pt} converts it to points.  

This simplified version neglects two extra features that you'll see if you look at the actual source code.  You can ignore both of these issues while you are experimenting and getting the geom to work, but if you want others to be able to use your geom in a wide range of situations you'll need to give them some though.  You also need to:

\begin{itemize}
  \item Transform the components of the geom so that it works in any coordinate system: \verb|coordinates$transform(data, scales)|.  A lot of the time you can avoid doing this work by calling basic geoms that already do this work.  For example, see \f{geom_boxplot} or \f{geom_smooth}.  This is an important pattern: many complex geoms are aggregates of simpler geoms.  This was discussed in depth in Section~\ref{sub:coord-transformation}.

  \item Name the grid grob, so that it's possible to modify it after drawing.  This is sometimes necessary for advanced customisation, as discussed in Section~\ref{sec:grid-existing}.  You can use the \f{ggname} convenience function that gives the new grob a name consistent with the rest of \ggplot.
\end{itemize}

% draw <- function(., data, scales, coordinates, ...) {    
%   with(coordinates$transform(data, scales), 
%     ggname(.$my_name(), pointsGrob(x, y, size=unit(size, "mm"), pch=shape, 
%     gp=gpar(col=colour, fill = fill, fontsize = size * .pt)))
%   )
% }

\subsection{Dealing with coordinate systems}

The most complicated 

\subsection{Defaults}
\label{sub:defaults}

\begin{itemize}
  \item \f{default_stat}, the default stat associated with the geom.
  
  \item \f{default_position}, the default position adjustment associated with the geom.

  \item \f{default_aes}, default aesthetic values
  
  \item \code{required_aes}, a vector of aesthetic names that are required in addition to the defaults.  Most geoms require at least x and y aesthetics.
  
\end{itemize}
% subsection defaults (end)

\subsection{The legend}
\label{sub:the_legend}

Each geom has a geom associated with it that is used for drawing the legend.  The name of this geom should be returned by the \f{guide_geom} method.  For example, the bar, tile and ribbon plots all use the same legend, which is provided by \code{geom_tile}.

The geom that draws the legend needs one additional method: \f{draw_legend}.  This method takes a data frame in same format as the draw method that contains a single observation and returns a grid grob representing the legend key for that element.  The grid grob should make no assumptions about the size of the space in which it will be drawn, and use the npc unit for positioning.

The legends provided \code{geom_path}, \code{geom_point}, and \code{geom_tile} provide the majority of legends in \ggplot.  They are all good places to start.  For examples of a more complicated legends see \code{geom_boxplot} and \code{geom_smooth}.

\subsection{Documentation} 
\label{sub:documentation}

If you fill out these fields informatively, you can easily generate html or rdoc documentation with the methods \f{rdoc_page_create} and \f{html_page_create}.

\subsection{Accessor methods}



\section{Statistical transformations}
\label{sec:own-stat}

\section{Scales}
\label{sec:own-scale}



\input{_footer.tex}
