\input{_header.tex}
\addcontentsline{toc}{part}{Appendices}
\chapter{Translating between different syntaxes}
\label{cha:translating}

\section{Introduction}

\ggplot does not exist in isolation, but is part of long history of graphical tools in R and elsewhere.  This chapter describes how to convert between \ggplot commands and other plotting systems:

\begin{itemize}
  \item Within \ggplot, between the \f{qplot} and \f{ggplot} syntaxes, \secref{sec:qplot-ggplot}
  
  \item From base graphics, \secref{translate-base}.

  \item From lattice graphics, \secref{translate-lattice}.
  
  \item From \sc{gpl}, \secref{translate-gpl}.
\end{itemize} 

Each section gives a general outline on how to convert between the difference types, followed by a number of examples.

\section{Translating between qplot and ggplot}
\label{sec:qplot-ggplot}

Within \ggplot, there are two basic methods to create plots, with \f{qplot} and \f{ggplot}.  \f{qplot} is designed primarily for interactive use: it makes a number of assumptions that speed most cases, but when designing multi-layered plots with different data sources it can get in the way.  This section describes what those defaults are, and how they map to the fuller 
\f{ggplot} syntax.  

By default, \f{qplot} assumes that you want a scatterplot, i.e.\ you want to use \f{geom_point}.

\begin{alltt}
qplot(x, y, data = data)
ggplot(data, aes(x, y)) + geom_point()
\end{alltt}

\subsection{Aesthetics}

If you map additional aesthetics, these will be added to the defaults.  With \f{qplot} there is no way to use different aesthetic mappings (or data) in different layers.

\begin{alltt}
qplot(x, y, data = data, shape = shape, colour = colour)
ggplot(data, aes(x, y, shape = shape, colour = colour)) + geom_point()
\end{alltt}

Aesthetic parameters in \f{qplot} always try and map the aesthetic to a variable.  If the argument is not a variable but a value, effectively a new column is added to the original dataset with that value.  To set an aesthetic to a value and override the default appearance, you surround the value with \f{I} in \f{qplot}, or pass it as a parameter to the layer.  Section~\ref{sec:setting-mapping} expands on the differences between setting and mapping.

\begin{alltt}
qplot(x, y, data = data, colour = I("red"))
ggplot(data, aes(x, y)) + geom_point(colour = "red")
\end{alltt}

\subsection{Layers}

Changing the geom parameter changes the geom added to the plot:

\begin{alltt}
qplot(x, y, data = data, geom = "line")
ggplot(data, aes(x, y)) + geom_line()
\end{alltt}

If a vector of multiple geom names is supplied to the geom argument, each geom will be added in turn:

\begin{alltt}
qplot(x, y, data = data, geom = c("point", "smooth"))
ggplot(data, aes(x, y)) + geom_point() + geom_smooth()
\end{alltt}

Unlike the rest of \ggplot, stats and geoms are independent:

\begin{alltt}
qplot(x, y, data = data, stat = "bin")
ggplot(data, aes(x, y)) + geom_point(stat = "bin")  
\end{alltt}

Any layer parameters will be passed on to all layers.  Most layers will ignore parameters that they don't need.

\begin{alltt}
qplot(x, y, data = data, geom = c("point", "smooth"), method = "lm")
ggplot(data, aes(x, y)) + 
  geom_point(method = "lm") + geom_smooth(method = "lm")
\end{alltt}

\subsection{Scales and axes}

You can control basic properties of the x and y scales with the \code{xlim}, \code{ylim}, \code{xlab} and \code{ylab} arguments:

\begin{alltt}
qplot(x, y, data = data, xlim = c(1, 5), xlab = "my label")
ggplot(data, aes(x, y)) + geom_point() + 
  scale_x_continuous("my label", limits = c(1, 5))

qplot(x, y, data = data, xlim = c(1, 5), ylim = c(10, 20))
ggplot(data, aes(x, y)) + geom_point() + 
  scale_x_continuous(limits = c(1, 5))
  scale_y_continuous(limits = c(10, 20))
\end{alltt}

Like \f{plot}, \f{qplot} has a convenient way of log transforming the axes.  There are many other possible transformations that are not accessible from within \f{qplot}, see Section~\ref{sec:transformers} for more details.

\begin{alltt}
qplot(x, y, data = data, log="xy")
ggplot(data, aes(x, y)) + geom_point() + scale_x_log10() + scale_y_log10()
\end{alltt}

\subsection{Plot options}

\f{qplot} recognise the same options as plot does, and converts them to their \ggplot equivalents.  Section~\ref{sec:plot_options} lists all possible plot options and their effects.

\begin{alltt}
qplot(x, y, data = data, main="title", asp = 1)
ggplot(data, aes(x, y)) + geom_point() + 
  opts(title = "title", aspect.ratio = 1)
\end{alltt}

\section{Base graphics}
\label{sec:translate-base}

There are two types of graphics functions in base graphics, those that draw complete graphics and those that add to existing graphics.  

\subsection{High-level plotting commands}

\f{qplot} has been designed to mimic \f{plot}, and can do the job of all other high-level plotting commands.  There are only two graph types from base graphics that can not be replicated with \ggplot: \f{filled.countour} and \f{persp}

\begin{alltt}
plot(x, y);  dotchart(x, y); stripchart(x, y)
qplot(x, y)

plot(x, y, type = "l")
qplot(x, y, geom = "line")

plot(x, y, type = "s")
qplot(x, y, geom = "step")

plot(x, y, type = "b")
qplot(x, y, geom = c("point", "line"))

boxplot(x, y)
qplot(x, y, geom = "boxplot")

hist(x)
qplot(x, geom = "histogram")

cdplot(x, y)
qplot(x, fill = y, geom = "density", position = "fill")

coplot(y ~ x | a + b)
qplot(x, y, facets = a ~ b)
\end{alltt}

Many of the geoms are parameterised differently to base graphics.  For example, \f{hist} is parameterised in terms of the number of bins, while \f{geom_histogram} is parmeterised in terms of the width of each bin.  

\begin{alltt}
hist(x, bins = 100)
qplot(x, geom = "histogram", binwidth = 1)
\end{alltt}

\f{qplot} often requires data in a slightly different format to the base graphics functions.  For example, the bar geom works with untabulated data, not tabulated data like \f{barplot}; the tile and contour geoms expect data in a data frame, not a matrix like \f{image} and \f{contour}.

\begin{alltt}
barplot(table(x))
qplot(x, geom = "bar")

barplot(x)
qplot(names(x), x, geom = "bar", stat = "identity")

image(x)
qplot(X1, X2, data = melt(x), geom = "tile", fill = value)

contour(x)
qplot(X1, X2, data = melt(x), geom = "contour", fill = value)
\end{alltt}

% fourfoldplot -> geom_bar(width=1) + coord_polar()
% pie -> geom_bar(width = 1) + coord_polar()
% stars -> geom_polygon() + coord_polar()

Generally, the base graphics function work with individual vectors, not data frames like \ggplot.  \f{qplot} will try and construct a data frame if one is not specified, but it is not always possible.  If you get strange errors, you may need to create the data frame yourself.

\begin{alltt}
with(df, plot(x, y))
qplot(x, y, data = df)
\end{alltt}

By default, \f{qplot} map values to aesthetics with a scale.  To override this behaviour and set aesthetics, overriding the defaults, you need to use \f{I}.

\begin{alltt}
plot(x, y, col = "red", cex = 1)
qplot(x, y, colour = I("red"), size = I(1))
\end{alltt}

matplot and groups

\subsection{Low-level drawing}

% lines -> geom_line
% rect -> geom_rect()
% rug -> geom_rug()
% points -> geom_point()
% polygon -> geom_polygon()
% segments -> geom_segment()
% text -> geom_text()
% lines(loess(x, y))  -> + geom_smooth()
% abline(lm(y ~ x)) -> + geom_smooth(method = "lm")
% lines(density(x))  -> + geom_density()
% curve -> geom_curve

\subsection{Legends, axes and grid lines} 

In \ggplot, the appearance of legends and axes are controlled by the scales.  In base graphics, legends are never displayed automatically, and gain more control over axes you typically do \code{xaxs = F} in the main plot call, and then add the axes yourself with \f{axis} or \f{Axis}.

\begin{itemize}
  \item \code{limits} controls the range of the axis or legend.
  \item \code{breaks} controls which labels appear on the axis or legend.
  \item \code{labels} controls the text of each label.
  \item \code{name} controls the axis or legend title.
\end{itemize}

Because the legend is derived automatically from the plot, there is much less you can do to control it than in base graphics.  Many of the aspects of its appearance can be changed with plot themes, Section~\ref{sec:themes}, while what is displayed in the legend is controlled by the scales, Section~\ref{sec:guides}.

The appearance of grid lines are controlled by the \code{grid.major} and \code{grid.minor} options, and there position by the breaks of the x and y scales.

\subsection{Colour palettes}

% rainbow -> scale_hue
% grays -> scale_grey

\subsection{Graphical parameters}

The majority of \code{par} settings have some analogue within the theme system, or in the defaults of the geoms and scales.  The appearance plot border drawn by \f{box} can be controlled in a similar way by the \code{panel.background} and \code{plot.background} theme elements.  Instead of using \f{title}, the plot title is set with the \code{title} option.


\subsection{Specialised graphics} 

Unlike \f{plot}, \f{qplot} doesn't know how to plot anything other than data frames: there is no equivalent to \code{plot(lm)}.  This is a deliberate design decision, to better force the separation between the functions that extract useful data from objects and the functions that plot that data.

% 
% mtext -> grid
% matplot -> melt
% identify, locator -> no equivalent yet
% coplot -> facet_grid
% 
% Changing titles: plot title, legend title, axis title

\section{Lattice graphics}
\label{sec:translate-lattice}
% 
% group -> categorical value on any aesthetic, or if no styling desired, group
% x | g1 * g2 -> facet_wrap(~ g1 + g2)
% scales = list(log = T) -> scale_x_log(), scale_y_log()
% scales = list(relation = "free") -> facet_grid()
% shingle -> no equivalent
% y1 + y2 -> melt
% panel -> + geom_point() + geom_line() ...
% aspect -> opts(aspect.ratio = 1)
% axs = i
% 
% 
% From Jim Holtman:
% 
% require(reshape)
% cases.melt <- melt(cases[, -ncol(cases)])
% 
% # plot cases/store/day on a box plot
% boxplot(value ~ X2, data=cases.melt, main="Cases Per Day Per Store")
% 
% -----------------------------------------------------------------------------------------
% 
% # partition by section and show the number of picks from each location
% x.m <- melt(table(Aisle, Quad, Section))
% 
% # add in the counts for each section
% col.l <- colorRampPalette(c('white', 'green', 'red'))(100)
% require(lattice)
% x.m$counts <- paste(x.m$Section, " (", ave(x.m$value, x.m$Section,
% FUN=sum), ")", sep="")
% print(levelplot(value ~ Aisle + Quad | counts, x.m, col.regions=col.l,
%    main="Visits Per Section Per Pick Slot (6 Days of Orders)"))

\section{GPL}
\label{sec:translate-gpl}

The Grammar of Graphics uses two specifications.  A concise format is used to caption figures, and a more detailed xml format stored on disk.  The following example of the concise format is adapted from \citet[][Figure 1.5, page 13]{wilkinson:2006}.

\begin{verbatim}
DATA: source("demographics")
DATA: longitude, latitude = map(source("World"))
TRANS: bd = max(birth - death, 0)
COORD: project.mercator()
ELEMENT: point(position(lon * lat), size(bf), color(color.red))
ELEMENT: polygon(position(longitude * latitude))
\end{verbatim}

This is relatively simple to adapt to the syntax of ggplot:

\begin{itemize}
  
  \item {\tt ggplot()} is used to specify the default data and default aesthetic mappings.  {\tt aes} is short for aesthetic mapping and specifies which variables in the data should be mapped to which aesthetic attributes.
  
  \item Data is provided as standard R data.frames existing in the global environment; it does not need to be explicitly loaded.  We also use a slightly different world data set, with columns lat and long.  This lets us use the same aesthetic mappings for both datasets. Layers can override the default data and aesthetic mappings provided by the plot. 
  
  \item We replace {\sf TRANS} with an explicit transformation by R code.

  \item {\sf ELEMENT}s are replaced with layers, which explicitly specify where the data comes from.  Each geom has a default statistic which is used to transform the data prior to plotting.  For the geoms in this example, the default statistic is the identity function.  Fixed aesthetics (the colour red in this example) are supplied as additional arguments to the layer, rather than as special constants.

  \item The {\sf SCALE} component has been omitted from this example (so that the defaults are used)In both the ggplot and GoG examples, scales are defined by default.  In ggplot you can override the defaults by adding a scale object, e.g. {\tt scale\_colour} or {\tt scale\_size}

  \item {\sf COORD} uses a slightly different format.  In general, most of the components specifications in ggplot are slightly different to those in GoG, in order to be more familiar to R users.

  \item Each component is added together with $+$ to create the final plot

\end{itemize}

This gives us:

\begin{verbatim}
demographics <- transform(demographics, bd = max(birth - death, 0))

ggplot(data = demographic, mapping = aes(x = lon, y = lat)) + 
layer(geom = "point", mapping = aes(size = bd), colour="red") +
layer(geom = "polygon", data = world) +
coord_map(projection = "mercator")
\end{verbatim}
\input{_footer.tex}