\input{_header.tex}
\addcontentsline{toc}{part}{Appendices}
\chapter{Translating between different syntaxes}
\label{cha:translating}

\section{Introduction}


Each section gives general outlines on how to convert between the difference syntaxes, followed by examples of common plot types


\section{Translating between qplot and ggplot}
\label{sec:qplot-ggplot}


To clarify the role of each of these elements, here are a couple of simple examples, taken from Chapter 2.  First, we'll start with a bubble chart of price by carat, with size proportional to the clarity of the diamond.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, size=clarity)
% })

This plot has one layer, three scales and a cartesian coordinate system.  To make these parts more clear, we can instead create the plot using these commands:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, aes(x = carat, y = price, size = clarity),
  geom = "point", stat = "identity"
)
\end{alltt}

This makes the single layer obvious, it uses a point geom and the identity transformation, but where are the definitions of the scales and the coordinate system?  By default, ggplot automatically adds sensible scales and the default coordinate system, however, we can be more explicit and add them ourselves:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price, colour = clarity),
  geom = "point", stat = "identity"
) + 
scale_size() + 
scale_y_continuous() + 
scale_x_continuous() + 
coord_cartesian()
\end{alltt}

Compared to the initial qplot example, this is extremely verbose, but perfectly explicit.  We  can clearly see the single layer, the three scales (x position, y position and size) and the coordinate system.  

The next example includes multiple layers, and demonstrates the effect of modifying the scale parameters.  This is another example from chapter two: a scatterplot of price vs carat, with logged axes and a linear smooth layered on top.  The qplot code is shown below.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, geom=c("smooth", "point"), method="lm", log="xy")
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     method = "lm", log = "xy")

\end{alltt}
% >>>

Here we have two layers, two scales and the same Cartesian coordinate system:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price),
  geom = "point", stat = "identity"
) + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price),
  geom = "smooth", stat = "smooth", method = "lm"
  
) + 
scale_y_log10() + 
scale_x_log10() + 
coord_cartesian()
\end{alltt}

There is some duplication in this example, which we can reduce by using plot defaults.

\begin{alltt}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) + 
layer(geom = "point", stat = "identity") + 
layer(geom = "smooth", stat = "smooth", method = "lm") + 
scale_y_log10() + 
scale_x_log10() + 
coord_cartesian()
\end{alltt}x

The following chapters describe each piece in more detail, and provide suggestions as to how to use them in a data analysis.


\begin{alltt}
qplot(x, y, data, shape=shape, colour = colour)
ggplot(data, aes(x, y, shape=shape, colour = colour)) + geom_point()
\end{alltt}

\begin{alltt}
qplot(x, y, data, shape=shape, colour = I("red"))
ggplot(data, aes(x, y, shape=shape)) + geom_point(colour="red")
\end{alltt}

The differences between setting and mapping are described in more detail in Section~\ref{sec:setting-mapping}.

\begin{alltt}
qplot(x, y, data, geom=c("line", "smooth"))
ggplot(data, aes(x, y)) + geom_line() + geom_smooth()
\end{alltt}

\begin{alltt}
qplot(x, y, data, geom=c("line", "smooth"), method="lm")
ggplot(data, aes(x, y)) + geom_line() + geom_smooth(method="lm")
\end{alltt}


\begin{alltt}
qplot(x, y, data, log="xy")
ggplot(data, aes(x, y)) + scale_x_log10() + scale_y_log10()
\end{alltt}

Section~\ref{sec:transformers} describes more possible transformations of the x and y scales.

\begin{alltt}
qplot(x, y, data, main="title", asp = 1)
ggplot(data, aes(x, y)) + opts(title = "title", aspect.ratio = 1)
\end{alltt}

Section~\ref{sec:plot_options} lists all possible plot options and their effects.


\section{Base graphics}
\label{sec:base_graphics}

Use qplot.

matplot and groups

\begin{itemize}
  \item plot
  \item points, lines, vline/hline/abline
  \item loess, abline(lm())
  \item hist
  \item coplot
  \item plot(lm)
\end{itemize}

Legend, axis/Axis
box -> opts(panel.border)
grid -> opts(grid.major, grid.minor) + x & y scales
title -> opts(title = "")

barplot -> geom_bar(stat="identity")
boxplot -> geom_boxplot()
contour -> geom_contour
cdplot -> geom_density(position = "fill")
dotchart -> geom_point() with discrete x
filled.countour -> not available
curve -> geom_curve
fourfoldplot -> geom_bar(width=1) + coord_polar()
image -> geom_tile
lines -> geom_line
pie -> geom_bar(width = 1) + coord_polar()
points -> geom_point()
polygon -> geom_polygon()
rect -> geom_rect()
rug -> geom_segment()
segments -> geom_segment()
stars -> geom_polygon() + coord_polar()
stripchart -> geom_point()
text -> geom_text()

rainbow -> scale_hue
grays -> scale_grey

persp -> no equivalent

mtext -> grid
matplot -> melt
identify, locator -> no equivalent yet
coplot -> facet_grid

par
axs = i = 

Changing titles: plot title, legend title, axis title

\section{Lattice graphics}
\label{sec:lattice_graphics}

group -> categorical value on any aesthetic, or if no styling desired, group
x | g1 * g2 -> facet_wrap(~ g1 + g2)
scales = list(log = T) -> scale_x_log(), scale_y_log()
scales = list(relation = "free") -> facet_grid()
shingle -> no equivalent
y1 + y2 -> melt
panel -> + geom_point() + geom_line() ...
aspect -> opts(aspect.ratio = 1)
axs = i


From Jim Holtman:

require(reshape)
cases.melt <- melt(cases[, -ncol(cases)])

# plot cases/store/day on a box plot
boxplot(value ~ X2, data=cases.melt, main="Cases Per Day Per Store")

-----------------------------------------------------------------------------------------

# partition by section and show the number of picks from each location
x.m <- melt(table(Aisle, Quad, Section))

# add in the counts for each section
col.l <- colorRampPalette(c('white', 'green', 'red'))(100)
require(lattice)
x.m$counts <- paste(x.m$Section, " (", ave(x.m$value, x.m$Section,
FUN=sum), ")", sep="")
print(levelplot(value ~ Aisle + Quad | counts, x.m, col.regions=col.l,
   main="Visits Per Section Per Pick Slot (6 Days of Orders)"))

\section{Wilkinson's grammar of graphics}

The biggest difference between Lee's grammar and mine is how the grammar is written; the syntax of the grammars are quite different.  The Grammar of Graphics uses two specifications.  A concise format is used to caption figures, and a more detailed xml format stored on disk.  The following example of the concise format is adapted from \citet[][Figure 1.5, page 13]{wilkinson:2006}.

\begin{verbatim}
DATA: source("demographics")
DATA: longitude, latitude = map(source("World"))
TRANS: bd = max(birth - death, 0)
COORD: project.mercator()
ELEMENT: point(position(lon * lat), size(bf), color(color.red))
ELEMENT: polygon(position(longitude * latitude))
\end{verbatim}

This is relatively simple to adapt to the syntax of ggplot:

\begin{itemize}
  
  \item {\tt ggplot()} is used to specify the default data and default aesthetic mappings.  {\tt aes} is short for aesthetic mapping and specifies which variables in the data should be mapped to which aesthetic attributes.
  
  \item Data is provided as standard R data.frames existing in the global environment; it does not need to be explicitly loaded.  We also use a slightly different world data set, with columns lat and long.  This lets us use the same aesthetic mappings for both datasets. Layers can override the default data and aesthetic mappings provided by the plot. 
  
  \item We replace {\sf TRANS} with an explicit transformation by R code.

  \item {\sf ELEMENT}s are replaced with layers, which explicitly specify where the data comes from.  Each geom has a default statistic which is used to transform the data prior to plotting.  For the geoms in this example, the default statistic is the identity function.  Fixed aesthetics (the colour red in this example) are supplied as additional arguments to the layer, rather than as special constants.

  \item The {\sf SCALE} component has been omitted from this example (so that the defaults are used)In both the ggplot and GoG examples, scales are defined by default.  In ggplot you can override the defaults by adding a scale object, e.g. {\tt scale\_colour} or {\tt scale\_size}

  \item {\sf COORD} uses a slightly different format.  In general, most of the components specifications in ggplot are slightly different to those in GoG, in order to be more familiar to R users.

  \item Each component is added together with $+$ to create the final plot

\end{itemize}

This gives us:

\begin{verbatim}
demographics <- transform(demographics, bd = max(birth - death, 0))

ggplot(data = demographic, mapping = aes(x = lon, y = lat)) + 
layer(geom = "point", mapping = aes(size = bd), colour="red") +
layer(geom = "polygon", data = world) +
coord_map(projection = "mercator")
\end{verbatim}
\input{_footer.tex}