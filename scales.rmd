---
bibliography: references.bib
---

```{r scales-chap, include=FALSE}
source("common.R")
columns(1, 2 / 3)
```

# Scales, axes and legends {#cha:scales}

## Introduction

Scales control the mapping from data to aesthetics. They take your data and turn it into something that you can perceive visually, like size, colour, position or shape. Scales also provide the tools you use to read the plot: the axes and legends.

Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The domain of each scale corresponds to the range of the variable supplied to the scale, and can be continuous or discrete, ordered or unordered. The range is the concrete aesthetics that you can perceive and that R can understand: position, colour, shape, size, line type, and so on. 

You can generate many plots without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control. Default scales and how to override them are described in [scale usage](#sec:scale-usage). 

Scales can be roughly divided into four categories: position scales, colour scales, the manual scale and the identity scale. The common options and most important uses are described in [scale details](#sec:scale-details). The section focusses on giving you a high-level overview of the options available, rather than expanding on every detail in depth. Details about individual parameters are included in the online documentation.

The other important role of each scale is to produce a **guide** that allows the viewer to perform the inverse mapping, from aesthetic space to data space, and read values off the plot. For position aesthetics, the axes are the guides; for all other aesthetics, legends do the job. Most aspects of the guides are controlled by parameters of the scale, but you can also use the `guides()` function to modify guides without messing with the scales directly. You'll learn more about that in [legends and axes](#sec:guides).

The process of scaling takes place in three steps, transformation, training and mapping, and is described in [how scales work](#sec:how-scales-work). 

## Default scales {#sec:scale-usage}

Without a scale, there is no way to go from the data to aesthetics, so a scale is required for every aesthetic used on the plot. Default scales are named according to the aesthetic and the variable type: `scale_y_continuous()`, `scale_colour_discrete()`, etc.

It would be tedious to manually add a scale every time you used a new aesthetic, so ggplot2 automatically adds a default for you. This means that the following two plot specifications are equivalent: 

`r columns(2, 2/3)`
```{r default-scales, eval = FALSE}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))

ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_continuous() + 
  scale_y_continuous() + 
  scale_colour_discrete()
```

### Exercises

## Gudes: legends and axes {#sec:guides}

The component of a scale that you're most likely to want to modify is the __guide__, the axis or legend associated with the scale. Guides allow you to read observations from the plot and map them back to their original values. 

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\linewidth]{diagrams/scale-guides}
  \caption{The components of the axes and legend.}
  \label{fig:labelled-guides}
\end{figure}

There are natural equivalents between the legend and the axis: the legend title and axis label are equivalent and determined by the scale name; the legend keys and tick labels are both determined by the scale breaks. \index{Guides} \index{Legend}

| Scale          | Axis              | Legend
|----------------|-------------------|---------------              
| `name`         | Label             | Title
| `breaks`       | Ticks & grid line | Key         
| `labels`       | Tick label        | Key label
| `minor_breaks` | Minor grid line   |          

In ggplot2, legends and axes are produced automatically based on the scales and geoms that you used in the plot. This is different than how legends work in most other plotting systems, where you are responsible for adding them. In ggplot2, you don't corrently control the legend; instead you set up the data so that there's a clear mapping between data and aesthetics, and a legend is generated for you automatically.  This can be frustrating when you first start using ggplot2, but once you get the hang of it, you'll find that it saves you time, and there is little you cannot do. 

If you blinked when you read that scales map data both to position and colour, you are not alone. The notion that the same kind of object is used to map data to positions and symbols strikes some people as unintuitive. However, you will see the logic and power of this notion as you read further in the chapter.

The appearance of the axes and legends are controlled by arguments to the scale functions, as described below.

### Scale title

The first argument to the scale function, `name`, is the name of the scale, the label that will appear on the axis or legend. You can supply text strings (using `\n` for line breaks) or mathematical expressions (as described by `?plotmath`):  \index{Axis!labels} \index{Legend!title}  \index{Scales!names}
    
`r columns(2, 1 / 2)`
```{r guide-names}
df <- data.frame(x = 1:2, y = 1, z = "a")
p <- ggplot(df, aes(x, y)) + geom_point()
p + scale_x_continuous("X axis")
p + scale_x_continuous(quote(a + mathematical ^ expression))
```

Because tweaking these labels is such a common task, there are three 
helper functions to save you some typing: `xlab()`, `ylab()` and `labs()`:

```{r guide-names-helper}
p <- ggplot(df, aes(x, y)) + geom_point(aes(colour = z))
p + 
  xlab("X axis") + 
  ylab("Y axis")
p + labs(x = "X axis", y = "Y axis", colour = "Colour\nlegend")
```

There are two ways to remove the axis label. Setting it to `""` removes it, but still allocates space; `NULL` removes the label and its space. Look closely at the left and bottom borders of these plots. I've changed the plot background to grey to make it easier to see the difference.

```{r guide-names-remove}
p <- ggplot(df, aes(x, y)) + 
  geom_point() + 
  theme(plot.background = element_rect(fill = "grey90"))
p + labs(x = "",  y = "")
p + labs(x = NULL, y = NULL)
```

### Breaks and labels

The `breaks` argument controls which values appear as tick marks on axes and keys on legends. Each break has an associated label, controlled by the `labels` argument. If you set `labels`, you must also set `breaks`: otherwise, if data changes, the breaks will no longer align with the labels. \index{Axis!breaks} \index{Axis!labels} \index{Legend!keys}

`r columns(3, 1)`
```{r breaks-labels}
df <- data.frame(x = (1:5) * 1000, y = 1)
p <- ggplot(df, aes(x, y)) + 
  geom_point(size = 5) + 
  labs(x = NULL, y = NULL)

p
p + scale_x_continuous(breaks = c(2000, 4000))
p + scale_x_continuous(breaks = c(2000, 4000), labels = c("2k", "4k"))
```

To suppress breaks (including grid lines), or label, set them to `NULL`:

```{r breaks-hide}
p + scale_x_continuous(breaks = NULL)
p + scale_x_continuous(labels = NULL)
```

Additionally, you can supply a function to `breaks` or `labels`. The `breaks` function should accept a numeric vector of length two (the axis limits) and return a numeric vector of breaks. The `labels` function should accept a numeric vector of breaks and return a character of the same length. The scales package provides a number of useful labelling functions:

```{r breaks-functions}
p + scale_y_continuous(labels = scales::percent)
p + scale_x_continuous(labels = scales::unit_format("k", 1/1000))
p + scale_y_continuous(labels = scales::dollar_format("$"))
```

Other functions include:

* `scales::comma()`: adds commas for large numbers.
* `scales::unit_format(unit, scale)`: adds a unit suffix, optionally scaling.
* `scales::dollar_format(prefix, suffix)`: 
   displays currency values, rounding to 2 decimal places and adding prefix
   or suffix.
* `scales::wrap_format()`: wraps long labels into multiple lines.

See the documentation of the scales package for more details.

You can adjust the minor breaks (the faint grid lines that appear between the major grid lines) with the `minor_breaks` argument. By default minor grid lines are spaced evenly in the original data space: this gives the common behaviour of log-log plots where major grid lines are evenly spaced on the log scale, and minor grid lines are evenly spaced on the log scale.

### "Adding" scales

The use of `+` to "add" scales to a plot is a little misleading. When you `+` a scale, you're not actually adding it to the plot, but overriding the existing scale. This means that the following two specifications are equivalent: \indexc{+} 

```{r multiple-scales, fig.show = "hide", message = TRUE}
ggplot(df, aes(x, y)) + 
  geom_point() + 
  scale_x_continuous(breaks = 1:5) + 
  scale_x_continuous(labels = 1:5)

ggplot(df, aes(x, y)) + 
  geom_point() + 
  scale_x_continuous(labels = 1:5)
```

Note the message: if you see this in your own code, you need to reorganse the plot specification so you only add a single scale per aesthetic.

### Layers and guides

To draw the legend, the plot must collect information about how each aesthetic is used: for what data and what geoms. The scale breaks are used to determine the values of the legend keys and a list of the geoms that use the aesthetic  is used to determine how to draw the keys. For example, if you use the point geom, then you will get points in the legend; if you use the lines geom, you will get lines. If both point and line geoms are used, then both points and lines will be drawn in the legend:

`r columns(1, 1/3, 1)`
```{r legend-geom, echo = FALSE}
df <- data.frame(x = 1:4, y = 1:4, z = letters[1:4])
p <- ggplot(df, aes(x, y, colour = z, group = 1))
draw_legends(
  p + geom_point(),
  p + geom_line(), 
  p + geom_point() + geom_line(), 
  p + geom_bar(aes(fill = z), stat = "identity")
)
```

You can override whether or not a layer appears in the legend with `show_guide` argument to the layer. Its default value is `NA`: that means it will appear in the legend if the corresponding aethetic is mapped to a variable in the data. You can use `FALSE` to prevent it from ever appearing in the legend or `TRUE` to force it to appear when it otherwise wouldn't. Using `TRUE` can be useful if you've used the following trick to make points stand out:

`r columns(2, 2/3)`
```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
ggplot(df, aes(x, y)) + 
  geom_point(size = 6, colour = "grey20") +
  geom_point(aes(colour = z), size = 3) 
ggplot(df, aes(x, y)) + 
  geom_point(size = 6, colour = "grey20", show_guide = TRUE) +
  geom_point(aes(colour = z), size = 3) 
```

### Combining legends

ggplot2 tries to use the smallest possible number of legends that accurately conveys the aesthetics used in the plot. It does this by combining legends if a variable is used with more than one aesthetic. The figure below shows how this works for points: if both colour and shape are mapped to the same variable, then only a single legend is necessary. 

`r columns(1, 1/3, 1)`
```{r legend-merge, echo = FALSE}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
p <- ggplot(df, aes(x, y)) + geom_point()
draw_legends(
  p + aes(colour = z),
  p + aes(shape = z),
  p + aes(shape = z, colour = z)
)
```

In order for legends to be merged, they must have the same `name`. For this reason, if you change the name of one of the merged legends, you'll need to change it for all of them.

### Theme settings

A number of settings that affect the overall display of the legends are controlled through the theme system.  You'll learn more about that in [themes](#sec:themes), but for now, all you need to know is that you modify theme settings with the `theme()` function.

The position and justification of legends are controlled by the theme setting `legend.position`, and the value can be "right", "left", "top", "bottom", "none" (no legend), or a numeric vector of length two. \index{Legend!position} A numeric position gives (in values between 0 and 1) the position of the corner given by `legend.justification`, a numeric vector of length two. Top right = `c(1, 1)`, bottom left = `c(0, 0)`. This can be useful if there's a lot of blank space in your plot, but position the legend exactly where you want it requires a lot of trial and error. 

`r columns(2, 2/3)`
```{r legend-position}
df <- data.frame(x = 1:3, y = 1:3, z = c("a", "b", "c"))
base <- ggplot(df, aes(x, y)) + 
  geom_point(aes(colour = z), size = 3) + 
  coord_equal()

base + theme(legend.position = "right") # the default 
base + theme(legend.position = "bottom")
base + theme(legend.position = "none")
base + theme(legend.position = c(0.15, 0.75))
```

Other theme settings that control the how the legends are laid out include `legend.direction`, `legend.justification`, `legend.box`, `legend.box.just`, `legend.margin`. You should be able to use these settings to arrange the legends in whatever way you need.

Other theme settings adjust how individual elements of the guides are drawn:

* `axis.title` 
* `axis.ticks` (`axis.ticks.x` & `axis.ticks.y`)
* `axis.ticks.length`, `axis.ticks.margin`
* `axis.line` (`axis.line.x` & `axis.line.y`)
* `axis.text` (`axis.text.x` & `axis.text.y`)
* `legend.background`
* `legend.key`
* `legend.key.size`
* `legend.title`
* `legend.text`
* `panel.grid`, `panel.grid.major`, `panel.grid.minor` (with `.x` and 
  `.y` variants)

You'll learn how to modify those in the theme section.

### The guide

There are two types of legend: `guide_legend()` and `guide_colourbar()`. 

Some overlap 

Common properties

* `title.position`, `title.theme`, `title.hjust`, `title.vjust`
* `label.position`, `label.theme`, `label.hjust`, `label.vjust`
* `reverse`
* `direction`
* `order`

Legend:

* `keywidth`, `keylength`, `default.unit`
* `override.aes`
* `nrow` and `ncol`
* `byrow`

Colour bar:

* `barwidth`, `barheight`, `default.unit`
* `nbin`

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = c("a", "b", "c"))
ggplot(df, aes(x, y)) + 
  geom_bar(aes(fill = z), stat = "identity", colour = "black") 

ggplot(df, aes(x, y)) + 
  geom_bar(aes(fill = z), stat = "identity", colour = "black") +
  guides(fill = guide_legend(override.aes = list(colour = NA)))
```

### Exercises


## Limits 

The limits, or domain, of a scale are usually derived from the range of the data. However it can be to useful to manually specify limits to remove data you don't want displayed in a plot (i.e., setting limits that are smaller than the full range of data), or to ensure that limits are consistent across multiple plot of the same data  (i.e., setting limits that are larger than some of the default ranges).\index{Axis!limits} \index{Scales!limits}

It's most natural to think about the limits of position scales: they map directly to the data ranges of the axes. But limits also apply to scales that have legends instead of axes, like colour, size, and shape. This is particularly useful if you want colours to match up across multiple plots that don't all show the same information.


A common task for all position axes is changing the axis limits. Because this is such a common task, ggplot2 provides a couple of helper functions to save you some typing: `xlim()`, `ylim()` and `limits()`. These functions inspect their input and then create the appropriate scale, as follows: \index{Axis!limits} \index{Scales!limits} \indexf{xlim}  \indexf{ylim} \index{Limits|see{Axis, limits}}

* `xlim(10, 20)`: a continuous scale from 10 to 20
* `ylim(20, 10)`: a reversed continuous scale from 20 to 10
* `xlim("a", "b", "c")`: a discrete scale
* `xlim(as.Date(c("2008-05-01", "2008-08-01")))`: a date scale from May 1 to August 1 2008.

There are three ways to control what data is shown on the plot. Each works slightly differently

* Subset the data.
* Set the limits in the scale.
* Set the limits in coordinate system.

These limits do not work in the same way as `xlim` and `ylim` in base or lattice graphics.  In ggplot2, to be consistent with the other scales, any data outside the limits is converted to missing values. This means that setting the limits is not the same as visually zooming in to a region of the plot.  To do that, you need to use the `xlim` and `ylim` arguments to `coord_cartesian()`, described in [cartesian coordinate systems](#sub:cartesian).  This performs purely visual zooming and does not affect the underlying data. \index{Zooming}

The limits are controlled primarily via the `limits` argument:

* For continuous scales, this should be a numeric vector of length two. 
  If you only want to set the upper or lower limit, you can set the other value
  to `NA`
  
* For discrete scales, this is a character vector which enumerates all possible
  values.
  
Like for labels, there are helpers that save typing for the most common use cases: `xlim()`, `ylim()` and `lims()`.

A related function is `expand_limits()` it ensures that the data points in the call are always included (i.e. it only ever expands the limits, never decreases them).

There are a handful of other arguments that affect the behaviour of `limits` in some way:

*   `expand`: By default, the limits of position scales extend a little past 
    the range of the data. This ensures that the data does not overlap the 
    axes. You can control the amount of expansion with the `expand` argument. 
    This parameter should be a numeric vector of length two. The first element 
    gives the multiplicative expansion, and the second the additive expansion.  
    If you don't want any extra space, use `expand = c(0, 0)`. 
    \index{Axis!expansion}
    
    ```{r, eval = FALSE}
    range + c(-1, 1) * (diff(range) * mul + add)
    ```

*   `oob`: By default, any value not in the domain of the scale is replaced 
    with a missing value. You can override with the `oob` (out of bounds) 
    argument to the scale. The default is `scales::censor()` which replaces any
    value outside the limits with `NA`. Another option is `scales::squish()` 
    which squishes all values into the range:
  
    ```{r}
    df <- data.frame(x = 1:5)
    p <- ggplot(df, aes(x, 1)) + geom_tile(aes(fill = x), colour = "white")
    p
    p + scale_fill_gradient(limits = c(2, 4))
    p + scale_fill_gradient(limits = c(2, 4), oob = scales::squish)
    ```

*   `na.value`: by default, colour scales display `NA` values as grey: this
    is often distinguishable from the other valeus on the scale. It's possible 
    to override this (or set it for other scales), with `na.value()`.
    
    ```{r}
    df <- data.frame(x = 1:5)
    p <- ggplot(df, aes(x, 1)) + geom_point(aes(colour = x), size = 10)
    p
    p + scale_colour_gradient(limits = c(2, 4))
    p + scale_colour_gradient(limits = c(2, 4), na.value = NA)
    ```

### Exercises

1.  How does `expand_limits()` work?  Read the source code.

## Other scales {#sec:scale-details}


Scale functions have a common naming scheme:

1. `scale`
1. `_`
1. The name of the aesthetic (e.g., `colour`, `shape` or `x`)
1. `_`
1. The name of the scale (e.g., `gradient`, `hue` or `manual`). 

For example, the name of the default scale for the colour aesthetic based on discrete data is `scale_colour_hue()`, and the name of the Brewer colour scale for fill colour is `scale_fill_brewer()`. \index{Scales!adding}

Every aesthetic has four scales: continuous, default, identity and manual.

* Colour and file
  * Discrete: brewer, grey, hue
  * Continuous: distiller, **gradient**, gradient2, gradientn
* Positition:
  * Discrete: **discrete**
  * Continuous: **continuous**, log10, sqrt
* Shape (only discrete): __shape__
* Line type (only discrete): __linetype__
* Size (only continuous): __size__, radius

To adjust the properties of a scale, you add a scale function with the parameters you want to modify, as you'll see in the following sections.


Scales can be divided roughly into four separate groups:

* Position scales, used to map continuous, discrete and date-time variables 
  onto the plotting region and to construct the corresponding axes.

* Colour scales, used to map continuous and discrete variables to colours.

* Manual scales, used to map discrete variables to your choice of symbol size, 
  line type, shape or colour, and to create the corresponding legend.

* The identity scale, used to plot variable values directly to the aesthetic 
  rather than mapping them.  For example, if the variable you want to map to 
  symbol colour is itself a vector of colours, you want to render those values 
  directly rather than mapping them to some other colours.

This section describes each group in more detail. Precise details about individual scales can be found in the documentation, e.g., `?scale_fill_discrete`.

### Position scales {#sub:scale-position}

Every plot must have two position scales, one for the horizontal position (the x scale) and one for the vertical position (the y scale). \index{Scales!position} \index{Positioning!scales} There are three types of position scales: 

* continuous: for numeric (double) and integer variables.

* discrete: for factor, character and logical variables.

* date scales: for Date and POSIXct (datetime) variables.

The following sections describe each type in more detail. 

#### Continuous {#ssub:scale-continuous}

The most common continuous position scales are `scale_x_continuous()` and `scale_y_continuous()`, which linearly map data to the x and y axis. \index{Scales!position!continuous} 

The most interesting variations are produced using transformations. Every continuous scale takes a `trans` argument, allowing the specification of a variety of transformations, both linear and non-linear. 

EXAMPLE

The transformation is carried out by a "transformer", which describes the transformation, its inverse, and how to draw the labels. The following table lists the most common variants: \index{Transformation!scales} \indexf{scale_x_continuous} \indexf{scale_y_continuous} \index{Scales!continuous}

---------- ------------------------- -----------------------
Name       Function $f(x)$           Inverse $f^{-1}(y)$
asn        $\tanh^{-1}(x)$           $\tanh(y)$
exp        $e ^ x$                   $\log(y)$
identity   $x$                       $y$
log        $\log(x)$                 $e ^ y$
log10      $\log_{10}(x)$            $10 ^ y$
log2       $\log_2(x)$               $2 ^ y$
logit      $\log(\frac{x}{1 - x})$   $\frac{1}{1 + e(y)} $
pow10      $10^x$                    $\log_{10}(y) $
probit     $\Phi(x)$                 $\Phi^{-1}(y)$
recip      $x^{-1}$                  $y^{-1}$
reverse    $-x$                      $-y$
sqrt       $x^{1/2}$                 $y ^ 2$
---------- ------------------------- -----------------------

There are short cuts for the most common scales: `scale_x_log10()`, `scale_x_sqrt()` and `scale_x_reverse()` (and similarly for `y`.) \index{Log transform} \indexf{scale_x_log10} \indexf{scale_y_log10}

Of course, you can also perform the transformation yourself. For example, instead of using `scale_x_log10()`, you could plot `log10(x)`. That produces an identical result inside the plotting region, but the axis and tick labels won't be the same. If you use a transformed scale, the axes will be labelled in the original data space. In both cases, the transformation occurs before the statistical summary.

```{r trans}
ggplot(msleep, aes(log10(brainwt), log10(bodywt))) + 
  geom_point() + 
  geom_smooth()
  
ggplot(msleep, aes(brainwt, bodywt)) + 
  geom_point() + 
  geom_smooth() +
  scale_x_log10() + 
  scale_y_log10()
```

Transformers are also used in `coord_trans()`, where the transformation occurs after the statistic has been calculated, and affects the shape of the graphical object drawn on the plot. See [cartesian coordinate systems](#sub:cartesian) for more details.

#### Date and time {#ssub:scale-date}

Dates and date times are continuous values with special ways of labelling the axes. Your dates must be stored as `date` (for dates) and `POSIXct` (for date times). If your dates are in a different format you will need to convert them with `as.Date()` or `as.POSIXct()`. \index{Date} \index{Time} \index{Scales!date-time} \indexf{scale_x_datetime}

Like all other scales, the `breaks`, `minor_breaks` and `labels` arguments control the appearance and location of the ticks. The scales package provides some break and label functions particularly useful for dates:

* `scales::date_breaks(width)`: specify the position of major and minor breaks 
  in terms of date units, years, months, weeks, days, hours, minutes and 
  seconds, and can be combined with a multiplier.  For example, 
  `breaks = scales::date_breaks("2 weeks")` will place a major tick mark every 
  two weeks.

* `scales::date_labels(format)` to display components of a date. You 
   can use the following special statements:
   
    -------------- ----------------------------------------
    Code           Meaning
    `%S`           second (00-59)
    `%M`           minute (00-59)
    `%l`           hour, in 12-hour clock (1-12)
    `%I`           hour, in 12-hour clock (01-12)
    `%H`           hour, in 24-hour clock (00-23)
    `%a`           day of the week, abbreviated (Mon-Sun)
    `%A`           day of the week, full (Monday-Sunday)
    `%e`           day of the month (1-31)
    `%d`           day of the month (01-31)
    `%m`           month, numeric (01-12)
    `%b`           month, abbreviated (Jan-Dec)
    `%B`           month, full (January-December)
    `%y`           year, without century (00-99)
    `%Y`           year, with century (0000-9999)
    -------------- ----------------------------------------
    
    For example, if you wanted to display dates of the form 14/10/1979, you
    would use the string `"%d/%m/%y"`. \index{Time series!date formatting}

The code below illustrates some of these parameters.

`r columns(2, 1 / 2)`
```{r date-scale}
plot <- ggplot(economics, aes(date, psavert)) + geom_line() +
  labs(x = NULL, y = NULL)
# Default breaks and labels
plot
plot + scale_x_date(
  labels = scales::date_format("%Y"),
  breaks = scales::date_breaks("5 years")
)
plot + scale_x_date(
  limits = as.Date(c("2004-01-01", "2005-01-01")),
  labels = scales::date_format("%Y-%m-%d"),
  minor_breaks = scales::date_breaks("month")
)
```

#### Discrete {#ssub:scale-discrete}

Discrete position scales map the unique values of their input to integers.  The order of the result can be controlled by the `breaks` argument, and levels can be dropped with the `limits` argument (or by using `xlim()` or `ylim()`). 

Because it is often useful to place labels and other annotations on intermediate positions on the plot, discrete position scales also accept continuous values.  You can use `position_nudge()` to tweak the position of labels: placed on integers starting at 1. \index{Scales!position!discrete} \indexf{scale_x_discrete} \indexf{scale_y_discrete} \index{Scales!discrete}

`r columns(2, 2/3)`
```{r}
df <- data.frame(trt = c("a", "b", "c"), value = c(1, 3, 2))
ggplot(df, aes(trt, value)) + 
  geom_point() + 
  geom_text(aes(label = value))

ggplot(df, aes(trt, value)) + 
  geom_point() + 
  geom_text(aes(label = value), nudge_x = 0.1)
```

### Colour {#sub:scale-colour}

After position, probably the most commonly used aesthetic is colour. There are quite a few different ways of mapping values to colours: three different gradient based methods for continuous values, and two methods for mapping discrete values. But before we look at the details of the different methods, it's useful to learn a little bit of colour theory. Colour theory is complex because the underlying biology of the eye and brain is complex, and this introduction will only touch on some of the more important issues. An excellent more detailed exposition is available online at <http://tinyurl.com/clrdtls>. \index{Colour} \index{Scales!colour}

At the physical level, colour is produced by a mixture of wavelengths of lights. To know a colour completely we need to know the complete mixture of wavelengths, but fortunately for us the human eye only has three different colour receptors, and so we can summarise any colour with just three numbers. You may be familiar with the rgb encoding of colour space, which defines a colour by the intensities of red, green and blue light needed to produce it. One problem with this space is that it is not perceptually uniform: the two colours that are one unit apart may look similar or very different depending on where they are in the colour space. This makes it difficult to create a mapping from a continuous variable to a set of colours.  There have been many attempts to come up with colours spaces that are more perceptually uniform.  We'll use a modern attempt called the hcl colour space, which has three components of **h** ue, **c** hroma and **l** uminance: \index{Colour!spaces}

* Hue is a number between 0 and 360 (an angle) which gives the ``colour'' of 
  the colour: like blue, red, orange, etc.

* Luminance is the lightness of the colour.  A luminance of 0 produces black, 
  and a luminance of 1 produces white.

* Chroma is the purity of a colour.  A chroma of 0 is grey, and the maximum 
  value of chroma varies with luminance.

The combination of these three components does not produce a simple geometric shape.  Figure \ref{fig:hcl} attempts to show the 3d shape of the space.  Each slice is a constant luminance (brightness) with hue mapped to angle and chroma to radius.  You can see the centre of each slice is grey and the colours get more intense as they get closer to the edge.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=\linewidth]{diagrams/hcl-space}
  \caption{The shape of the hcl colour space.  Hue is mapped to angle, chroma to radius and each slice shows a different luminance.  The hcl space is a pretty odd shape, but you can see that colours near the centre of each slice are grey, and as you move towards the edges they become more intense.  Slices for luminance 0 and 100 are omitted because they would, respectively, be a single black point and a single white point.}
  \label{fig:hcl}
\end{figure}

An additional complication is that many people (~10% of men) do not possess the normal complement of colour receptors and so can distinguish fewer colours than usual. \index{Colour!blindness} In brief, it's best to avoid red-green contrasts, and to check your plots with systems that simulate colour blindness. Visicheck is one online solution. Another alternative is the **dichromat** package [@dichromat] which provides tools for simulating colour blindness, and a set of colour schemes known to work well for colour-blind people. You can also help people with colour blindness in the same way that you can help people with black-and-white printers: by providing redundant mappings to other aesthetics like size, line type or shape.

All of the scales discussed in the following sections work with border (`colour`) and fill (`fill`) colour aesthetics.

#### Discrete {#ssub:colour-discrete}

There are two colour scales for discrete data, one which chooses colours in an automated way, and another which makes it easy to select from hand-picked sets.

Ordered vs. unordered.

The default colour scheme, `scale_colour_hue()`, picks evenly spaced hues around the hcl colour wheel.  This works well for up to about eight colours, but after that it becomes hard to tell the different colours apart.  Another disadvantage of the default colour scheme is that because the colours all have the same luminance and chroma, when you print them in black and white, they all appear as an identical shade of grey. \index{Colour!discrete scale} \indexf{scale_colour_hue}

`scale_colour_grey()`

An alternative to this algorithmic scheme is to use the ColorBrewer colours, <http://colorbrewer2.org/>. These colours have been hand picked to work well in a wide variety of situations, although the focus is on maps and so the colours tend to work better when displayed in large areas. For categorical data, the palettes most of interest are 'Set1' and 'Dark2' for points and 'Set2', 'Pastel1', 'Pastel2' and 'Accent' for areas. Use `RColorBrewer::display.brewer.all()` to list all palettes. \index{Colour!Brewer} \indexf{scale_colour_brewer}

Not that one set of colours is not uniformly good: bright colours work well for points, but are overwhelming on bars. Subtle colours work well for bars, but are hard to see on points."

```{r brewer-pal}
df <- data.frame(x = 1:3 + runif(30), y = runif(30), z = c("a", "b", "c"))
point <- ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z))  + 
  theme(legend.position = "bottom") +
  labs(x = NULL, y = NULL)
point + scale_colour_brewer(palette = "Set1")
point + scale_colour_brewer(palette = "Set2")  
point + scale_colour_brewer(palette = "Pastel1")

df <- data.frame(x = 1:3, y = 3:1, z = c("a", "b", "c"))
area <- ggplot(df, aes(x, y)) + 
  geom_bar(aes(fill = z), stat = "identity") + 
  theme(legend.position = "bottom") +
  labs(x = NULL, y = NULL)
area + scale_fill_brewer(palette = "Set1")
area + scale_fill_brewer(palette = "Set2")
area + scale_fill_brewer(palette = "Pastel1")
```

If you have your own discrete colour scale, you can use `scale_colour_manual()`, as described below.


#### Continuous {#ssub:colour-continuous}

There are three types of continuous colour gradients, based on the number of colours in the gradient: \index{Colour!gradients} \index{Scales!colour!gradient}

* `scale_colour_gradient()` and `scale_fill_gradient()`: a two-colour gradient, 
  low-high.  Arguments `low` and `high` control the colours at either end of 
  the gradient. \indexf{scale_colour_gradient} \indexf{scale_fill_gradient}

* `scale_colour_gradient2()` and `scale_fill_gradient2()`: a three-colour 
  gradient, low-med-high.  As well as `low` and `high` colours, these scales 
  also have a `mid` colour for the colour of the midpoint.  The midpoint 
  defaults to 0, but can be set to any value with the `midpoint` argument.
  This is particularly useful for creating diverging colour schemes.
  \indexf{scale_colour_gradient2} \indexf{scale_fill_gradient2}

* `scale_colour_gradientn()` and `scale_fill_gradientn()`: a custom n-colour 
  gradient.  This scale requires a vector of colours in the `colours` argument.  
  Without further arguments these colours will be evenly spaced along the 
  range of the data.  If you want the values to be unequally spaced, use the 
  `values` argument, which should be between 0 and 1 if `rescale` is true 
  (the default), or within the range of the data is `rescale` is false.

Colour gradients are often used to show the height of a 2d surface.  In the following example we'll use the surface of a 2d density estimate of the `faithful` dataset [@azzalini:1990], which records the waiting time between eruptions and during each eruption for the Old Faithful geyser in Yellowstone Park. The following code shows three different examples with different colours:

`r columns(3, 1)`
```{r}
f2d <- MASS::kde2d(faithful$eruptions, faithful$waiting,  h = c(1, 10), n = 100)
df <- data.frame(expand.grid(eruptions = f2d$x, waiting = f2d$y), density = as.vector(f2d$z))
erupt <- ggplot(df, aes(waiting, eruptions, fill = density)) +
  geom_raster() +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) +
  theme(legend.position = "none")
erupt + scale_fill_gradient()
erupt + scale_fill_gradient(low = "white", high = "black") 
erupt + scale_fill_gradient2(midpoint = 0.01) 
```

To create your own custom gradient, use `scale_colour_gradientn()`. This is useful if you have colours that are meaningful for your data (e.g., black body colours or standard terrain colours), or you'd like to use a palette produced by another package. The following code shows palettes generated from routines in the **colorspace** package. [@zeileis:2008] describes the philosophy behind these palettes and provides a good introduction to some of the complexities of creating good colour scales. \index{Colour!palettes} \indexf{scale_colour_gradientn} \indexf{scale_fill_gradientn}

```{r colorspace}
erupt + scale_fill_gradientn(colours = colorspace::rainbow_hcl(7))
erupt + scale_fill_gradientn(colours = colorspace::diverge_hcl(7))
erupt + scale_fill_gradientn(colours = colorspace::heat_hcl(7))
```

* `scale_colour_distiller()`

### The manual discrete scale {#sub:scale-manual}

The discrete scales, `scale_linetype()`, `scale_shape()` and `scale_size_discrete()` basically have no options (although for the shape scale you can choose whether points should be filled or solid). These scales are just a list of valid values that are mapped to each factor level in turn. \index{Shape!scale} \index{Line type!scale} \index{Size!scale}

If you want to customise these scales, you need to create your own new scale with the manual scale: `scale_shape_manual()`, `scale_linetype_manual()`, `scale_colour_manual()`, etc. The manual scale has one important argument, `values`, where you specify the values that the scale should produce. If this vector is named, it will match the values of the output to the values of the input, otherwise it will match in order of the levels of the discrete variable. You will need some knowledge of the valid aesthetic values, which are described in [specifications](#cha:specifications). The following code demonstrates the use of `scale_manual`, with results shown in Figure \ref{fig:scale-manual} \indexf{scale_shape_manual} \indexf{scale_colour_manual} \indexf{scale_linetype_manual}

`r columns(2, 2/3)`
```{r scale-manual}
plot <- ggplot(msleep, aes(brainwt, bodywt)) + 
  scale_x_log10() + 
  scale_y_log10()
plot + 
  geom_point(aes(colour = vore)) + 
  scale_colour_manual(values = c("red", "orange", "green", "blue"), na.value = "grey50")

colours <- c(carni = "red", insecti = "orange", herbi = "green", omni = "blue")
plot + 
  geom_point(aes(colour = vore)) + 
  scale_colour_manual(values = colours)
```

The following example shows a creative use of `scale_colour_manual()`, when you want to display multiple variables on the same plot, and show a useful legend. In most other plotting systems, you'd just colour the lines as below, and then add a legend that describes which colour corresponds to which variable.  That doesn't work in `ggplot` because it's the scales that are responsible for drawing legends, and the scale doesn't know how the lines should be labelled.

`r columns(1, 1/2, 0.6)`
```{r huron}
huron <- data.frame(year = 1875:1972, level = LakeHuron)
ggplot(huron, aes(year)) +
  geom_line(aes(y = level + 5), colour = "red") +
  geom_line(aes(y = level - 5), colour = "blue") 
```

What you need to do is tell the colour scale about the two different lines by creating a mapping from the data to the colour aesthetic. There's no variable present in the data, so you'll have to create one:

```{r huron2}
ggplot(huron, aes(year)) +
  geom_line(aes(y = level + 5, colour = "above")) +
  geom_line(aes(y = level - 5, colour = "below")) 
```

This gets us basically what we want, but the legend isn't labelled correctly, and has the wrong colours.  That can be fixed with `scale_colour_manual()`:

```{r huron3}
ggplot(huron, aes(year)) +
  geom_line(aes(y = level + 5, colour = "above")) + 
  geom_line(aes(y = level - 5, colour = "below")) + 
  scale_colour_manual("Direction", values =
                      c("above" = "red", "below" = "blue"))
```

See [multiple time series](#sub:time-series) for an alternative approach to the problem.

### The identity scale {#sub:scale-identity}

The identity scale is used when your data is already in a form that the plotting functions in R understand, i.e., when the data and aesthetic spaces are the same.  This means there is no way to derive a meaningful legend from the data alone, and by default a legend is not drawn.  If you want one, you can still use the `breaks` and `labels` arguments to set it up yourself. \index{Scales!identity} \indexf{scale_identity}

Figure \ref{fig:scale-identity} shows one sort of data where `scale_identity()` is useful. Here the data themselves are colours, and there's no way we could make a meaningful legend.  The identity scale can also be useful in the case where you have manually scaled the data to aesthetic values.  In that situation, you will have to figure out what breaks and labels make sense for your data. A plot of R colours in Luv space.  A legend is unnecessary, because the colour of the points represents itself: the data and aesthetic spaces are the same.

```{r scale-identity}
luv <- as.data.frame(convertColor(t(col2rgb(colors())), "sRGB", "Luv"))
luv$col <- colors()
head(luv)

ggplot(luv, aes(u, v)) + 
  geom_point(aes(colour = col), size = 3) + 
  scale_color_identity() + 
  coord_equal()
```

## How scales work {#sec:how-scales-work}

To describe how scales work, we will first describe the domain (the data space) and the range (the aesthetic space), and then outline the process by which one is mapped to the other.

Since an input variable is either discrete or continuous, the domain is either a set of values (stored as a factor, character vector or logical vector) \indexf{Discrete variables} or an interval on the real line (stored as a numeric vector of length 2). For example, in the mammals sleep dataset (`msleep`), the domain of the discrete variable `vore` is \{carni, herbi, omni, insecti\}, and the domain of the continuous variable `bodywt` is $[0.005, 6654]$.  We often think of these as data ranges, but here we are focussing on their nature as input to the scale, i.e., as a domain of a function. \index{Data!msleep@\texttt{msleep}}

The range can also be discrete or continuous. For discrete scales, it is a vector of aesthetic values corresponding to the input values. For continuous scales, it is a 1d path through some more complicated space. For example, a colour gradient interpolates linearly from one colour to another. The range is either specified by the user when the scale is created, or by the scale itself.

The process of mapping the domain to the range includes the following stages:

*   __transformation__: (for continuous domain only). It is often useful to 
    display a transformation of the data, such as a logarithm or square root.
    Transformations are described in more depth in 
    [position scales](#sub:scale-position). \index{Scales!transformation}

    After any transformations have been applied, the statistical summaries for 
    each layer are computed based on the transformed data. This ensures that a 
    plot of $\log(x)$ vs. $\log(y)$ on linear scales looks the same as 
    $x$ vs. $y$ on log scales.

*   __training__:  During this key stage, the domain of the scale is learned
    from the data. Sometimes learning the domain of a scale is extremely 
    straightforward: In a plot with only one layer, representing only raw data, 
    it consists of determining the minimum and maximum values of a continuous 
    variable (after transformation), or listing the unique levels of a 
    categorical variable.  However, often the domain must reflect multiple
    layers across multiple datasets in multiple panels.  For example, imagine 
    a scale that will be used to create an axis; the minimum and maximum 
    values of the raw data in the first layer and the statistical summary in 
    the second layer are likely to be different, but they must all eventually 
    be drawn on the same plot. \index{Scales!training}
 
    The domain can also be specified directly, overriding the training process, 
    by manually setting the domain of the scale with the `limits` argument, 
    as described in [scale usage](#sec:scale-usage).  Any values outside of the
    domain of the scale will be mapped to `NA`.

*   __mapping__:  We now know the domain and we already knew the range before 
    we started this process, so the last thing to do is to apply the scaling 
    function that maps data values to aesthetic values.  \index{Scales!mapping}

We have left a few stages out of this description of the process for simplicity.  For example, we haven't discussed the role faceting plays in training, and we have also ignored position adjustments.  Nevertheless this description is accurate, and you should come back to it if you are confused about what scales are doing in your plot.
