\input{_header.tex}
\chapter{Scales, axes and legends}

\section{Introduction}

Scales control the mapping between data and aesthetics.  They convert abstract data values into concrete aesthetics that can be perceived, such position, colour, shape, size, and line type.  Each aesthetic has a default scale for continuous and discrete data types (described in Section~\ref{sec:vartypes}).  To override these defaults you must add your own scale.  

This chapter:

\begin{itemize}
  \item How scales work
  \item How to use scales
  \item Transformations
  \item Two special scales
  \item How to customise axes and legends
\end{itemize}

This section describes the basic operation of a scale, the details of all the different scales and instructions on how to make your own.

\section{How scales work}

As the job of the scale is to map between data (the domain) and aesthetic spaces (the range), it needs to know exactly what the domain of the data is. For continuous variables, the domain is a range (a numeric vector of length 2, indicating a interval on the real line), and for discrete variables it is a character vector of values.  

The each scale also has range.  For discrete scales, this is just a vector of aesthetic values corresponding to the input values.  For continuous scales, this will typically be a 1d path.  For example, the continuous colour scales have a range which is a path through colour space.

The process by a scale learns the domain is called training, and takes place in three steps:

\begin{itemize}
	\item  {\bf Transform}. Scale transformation occurs before statistical transformation so that statistics are computed on the scale-transformed data.  This ensures that a plot of $log(x)$ vs $log(y)$ on linear scales looks the same as $x$ vs $y$ on log scales.  See Section~\ref{sec:trans} for more details. Transformation is only necessary for non-linear scales, because statistics are defined to be location-scale invariant.

	\item {\bf Train}. After the statistics are computed, each scale is trained on every faceted dataset (a plot can contain multiple datasets, e.g.\ raw data and predictions from a model).  The training operation combines the ranges of the individual datasets to get the range of the complete data.  If scales were applied locally, comparisons would only be meaningful within a facet.
	
	Training can be overridden by manually setting the domain of the scale with the {\tt limits} argument.  Any values outside of the domain will be dropped.

	\item {\bf Map}. Finally the scales map the data values into aesthetic values.  Nothing needs to be done for some scales: for example, for continuous position scales, all the difficult work has already been done by the transformation step.
	
	Given that we end up with an essentially identical structure you might wonder why we don't simply split up the final result.  There are several reasons for this.  It makes writing statistical transformation functions easier, as they only need to operate on a single facet of data, and some need to operate on a single subset, for example, calculating a percentage.  Also, in practice we may have a more complicated training scheme for the position scales so that different columns or rows can have different $x$ and $y$ scales.  
	
\end{itemize}

\section{Using scales}

\subsection{Default scales}
\label{sub:default_scales}

The following example shows the difference between the default discrete and continuous scales for colour, as well as how to override the default scale.

\begin{alltt}
  qplot(mpg, wt, data=mtcars, colour=cyl)
  qplot(mpg, wt, data=mtcars, colour=factor(cyl))
  qplot(mpg, wt, data=mtcars, colour=factor(cyl)) + scale_colour_brewer(pal="Set1")
\end{alltt}

The default colour scale for discrete values uses equally spaced hues, the default scale for continuous values uses a gradient of colours between blue and yellow, and the Brewer colour scale uses colours selected to work well in a variety of situations (see \url{http://colorbrewer.org} for more detail).

If you want to use the default scale, but change some options the scale name is {\tt continuous} or {\tt discrete} according to the type of variable.  Having to specify the type of variable (continuous or discrete) seems like extra work: why can't ggplot2 figure that out by itself?  Well, it can't because you can create the scales independently of (and before) the plot.  Allows you to create scales independently of the plot.  Chapter~\ref{chp:strategy} shows some examples of these.

\subsection{Scale names}
\label{sub:scale_names}

Scales have a common naming scheme, made up of three pieces separated by ``{\tt \_}'':

\begin{itemize}
  \item {\tt scale}
  \item {\tt aesthetic name}
  \item {\tt scale name}
\end{itemize}

Table~\ref{tbl:scale_list} lists all built-in scales.  Remember to create the name you will use within R, you need to combine together the three parts described above.  For example, to use the Brewer colour scale for fill, you would add on {\tt scale\_fill\_brewer}.  

\input{scale-desc}

\subsection{Common arguments}
\label{sub:scale_arguments}

As well as having a common naming scheme, all scales share a set of common arguments.  These arguments control the basic operation of the scale and are described below.

\begin{itemize}
  \item {\bf name}:  the label which will appear on the axis or legend. You can supply text strings (using ``$\backslash$n'' for line breaks) or mathematical expressions (as described by \verb|?plotmath|):
  
  \begin{figure}[htbp]
    \centering
      \includegraphics[width=0.32\textwidth]{scales-name-1}
      \includegraphics[width=0.32\textwidth]{scales-name-2}
      \includegraphics[width=0.32\textwidth]{scales-name-3}
    \caption{Legends with names given by (from left to right): {\tt "Tip rate"}, {\tt "The amount of the tip$\backslash$ndivided by the total bill"} and {\tt expression(frac(tip, total\_bill)} }
    \label{fig:label}
  \end{figure}
  
  % decumar<<< 
  % interweave({
  % p <- qplot(tip, total_bill, data=tips, colour=tip/total_bill)
  % p + scale_colour_hue("Tip rate")
  % p + scale_colour_hue("The amount of the tip\ndivided by the total bill")
  % p + scale_colour_hue(expression(frac(tip, total_bill))
  % })
  % |||
  % >>>

  \item {\bf limits}: fixes the domain of the data.  if not set, will be computed from the data.    Continuous scales take a numeric vector of length two.  Discrete scales take a character vector.  {\tt xlim} and {\tt ylim} shortcuts.  If limits are set, no training of the data will be performed.  Particularly useful for zooming (limits smaller than range of data), and ensuring that limits are consistent across multiple plots (limits larger than range of some subsets of data).  
  
  Any value not in the domain of the scale is not displayed (i.e.\ for an observation to be displayed it must be in the domain of every scale on the plot)

  \item {\bf breaks} and {\bf labels}: control where tick marks appear on the axis or what values appear on the legend.  If {\tt labels} is set, you must also specify {\tt breaks}, so that the two can be matched up correctly.  Breaks differs from limits in that it affects what appears on the guide, not what appears on the plot.  This is illustrated by Figure~\ref{fig:breaks_vs_legends}.
  
  % Alternatively, both breaks and labels can be a function with a single  argument, range, that returns a numeric vector (for breaks) or a character vector (for labels) with desired break positions and labels.
\end{itemize}

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.32 \textwidth]{scales-unlimited}
    \includegraphics[width=0.32 \textwidth]{scales-breaks}
    \includegraphics[width=0.32 \textwidth]{scales-limits}
  \caption{The difference between breaks and legends.  (Left) default plot.  (Middle)  {\tt breaks = c(4.5,5.5)} and (right) {\tt limits = c(4.5,5.5)}.}
  \label{fig:breaks_vs_legends}
\end{figure}

There are many other arguments to individual scales, described by the documentation for the individual scales.  You can use the either the R (e.g.\ {\tt ?scale\_brewer}), or the online documentation (\url{http://had.co.nz/ggplot2}).  The online documentation includes output.

\section{Special scales}
\label{sec:scale_special}

There are two special types of scales that work for all aesthetics.  They are the manual and identity scale.  

The identity scale is used when your data is already in a form that the plotting functions in R understand: size in mm, colour as \verb|"#RRGGBB"| etc. Because there are no labels associated with such data, the identity scale will not draw a legend unless you also provide labels and breaks, as described above. 

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.5\textwidth]{scale-identity}
  \caption{A plot of R colours in Luv space.  Points are coloured according to their colour, with .  A legend is unnecessary, because the colour of the points represents itself.}
  \label{fig:scale-identity}
\end{figure}

The manual scale is useful for creating your own discrete scales.  It has one important argument, \verb|values| in which you specify the values that the scale should produce.  If this vector is named, it will match the values of the output to the values of the input, otherwise it will match in order of the levels of the discrete variable.  If you use \verb|scale_manual| be careful to ensure that they are perceptually well founded.

\section{Transformers}
\label{sec:trans}

Every continuous scale takes a {\tt trans} argument.  This argument allows to specify a non-linear transformation.  The transformation is carried out by a transformer, which describes the transformation, it's inverse and where to place labels. Table~\ref{tbl:common-trans} lists some of the more common transformers. A complete list is available in the documentation for {\tt transformation}.

\begin{table}
  \centering
  \begin{tabular}{lll}
    \toprule
    Name & Function $f(x)$ & Inverse $f^{-1}(x)$ \\
    \midrule
    asn       & $\tanh^{-1}(x)$ & $\tanh(x)$ \\
    exp       & $e ^ x$         & $\log(x)$  \\
    identity  & $x$             & $x$        \\
    log       & $\log(x)$       & $e ^ x$    \\
    log10     & $\log_{10}(x)$  & $10 ^ x$   \\
    log2      & $\log_2(x)$     & $2 ^ x$    \\
    logit     & $\frac{1}{1 + e(x)} $ & $\log(\frac{x}{1 - x})$ \\
    pow10     & $10^x$          & $\log_{10}(x) $ \\
    probit    & $\Phi(x)$       & $\Phi^{-1}(x)$ \\
    recip     & $x^{-1}$        & $x^{-1}$ \\
    reverse   & $-x$            & $-x$     \\
    sqrt      & $x^{1/2}$       & $x ^ 2$  \\
    % power     & $\frac{x^p - 1}{p * sgn(values - 1)}$ & $|values| * p + 1 $ 
    \bottomrule
  \end{tabular}
  \caption{List of built transformers.}
  \label{tbl:common-trans}
\end{table}

Because transformations are so commonly used to modify position scales, there is a shortcut for x, y, and z scales: \verb|scale_x_continuous(trans = "log10")| can be written as \verb|scale_x_log10()|.

You can also perform the transformation by hand.  For example instead of adding {\tt scale\_x\_log}, you could plot {\tt log(x)}.  These produce identical graphics except for one difference: the axis labels.  If you use a transformed scale, the axes will be labelled with the original values.  Figure~\ref{fig:trans} illustrates this difference.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.49\linewidth]{trans-scale}
    \includegraphics[width=0.49\linewidth]{trans-data}
  \caption{A scatterplot of diamond price vs carat illustrating the difference between log transforming the scale (left) and log transforming the data (right).  The plots are identical, but the axis labels are different.}
  \label{fig:trans}
\end{figure}

Scale transformation occurs before the statistic is calculated.  Transformers are also used in \verb|coord_trans|, where the transformation occurs after the statistic has been calculated, and affect the shape of the grob.  \verb|coord_trans| is described in more detail in Section XXX.

Section XXX describes how to write your own transformers.

\section{Legends and axes}
\label{sec:legends_and_axes}

In ggplot2, legends and axes are produced automatically based on the scales.  This section describes how legends are produced from the scales and the geoms that use them, as well as ways that you can customise them.

\begin{figure}[htbp]
  \centering
  \caption{Figure containing axis and legends, with pieces labelled.  }
  \label{fig:label}
\end{figure}

Because all information about what is on the plot is stored in the plot object, ggplot2 can normally do a very good job of anticipating what legend you want.  

This requires collecting information about how each aesthetic is used from a couple of different places.  Firstly, we need information from the scale about the values in the original data, and their presentation on the plot.  The scale returns a list of ``keys'' (analogous to ticks on the axis), which associated the data values with their aesthetic appearance.  Then we figure out which geoms have used that aesthetic - we need this information so that we can display the aesthetics in the correct way.  For example, the point geom has points in the legend key and the lines geom has lines.  If both points and lines are used then both will be drawn.

\begin{itemize}
  \item For each aesthetic used in the plot, list all geoms that use that aesthetic. 
  \item 
\end{itemize}

This process requires a few (not unreasonable) assumptions:

\subsection{Customising appearance}

While ggplot2 will generally do a pretty good job at figuring out what the legend should look like, sometimes you will need to do some tweaking to get the legends looking exactly the way that you want.  Described below are some of the useful scale arguments and theme parameters that affect the appearance of legends.  

\begin{itemize}
  \item The {\tt breaks} and {\tt labels} arguments, described above, are particularly important because they control what tick marks appear on the axis and what keys appear on the legend.  If the breaks chosen by default are not appropriate (or you want to use more informative labels) setting these arguments will adjust the appearance of the legend keys and axis tick marks.  
  
  \item The theme settings {\tt axis.text}, {\tt axis.box}, ... control the visual appearance of the legend.  For more details on how to manipulate these settings, see Section~\ref{sec:theming}.

  \item The internal grid lines are controlled by the breaks and minor breaks arguments.  By default minor grid lines are spaced evenly in the original data space - this gives the common behaviour of log-log plots where major grid lines are multiplicative and minor grid lines are additive.  You can override the minor grid lines with the {\tt minor\_breaks} argument.
  
  \item Position of legends.  Plot level option setting: {\tt legend.position}, can be one of right, left, top or bottom; or none to not display the legend; or a numeric vector of length 2.  {\tt legend.justification}
  
  \item Position scales also have the {\bf expand} argument, which controls the amount of extra space added to the limits.  This is a numeric vector of length two: the first number is the multiplicative and the second is additive.  Default for continuous scale is {\tt c(0.05, 0)} (i.e.\ add 5\% extra space on each end) and for discrete {\tt c(0, 0.75)}).  Set to {\tt c(0, 0)} to have no extra space.  This is added on top of any specified limits.
  
\end{itemize}

\subsection{Legend merging}

ggplot2 tries to minimise the number of legends that are displayed.  It does this by combining legends for the same variable.  Figure~\ref{fig:legend-merge} shows an example of this.  In order for legends to be merged, they must have the same title.  For this reason, if you change the title of one of the merged legends you'll need to change it for all of them.

\begin{figure}[htbp]
  \centering
  \caption{Colour legend, shape legend, colour + shape legend.}
  \label{fig:legend-merge}
\end{figure}

A legend will be drawn for each aesthetic attribute.  Every geom that uses that aesthetic will appear in the legend in some way.

\input{_footer.tex}