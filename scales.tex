\input{_header.tex}
\chapter{Scales, axes and legends}
\label{cha:scales}

% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.33\linewidth COL: 3 
%   INLINE: FALSE
%   CACHE: TRUE
% 

% END

\section{Introduction}

Scales control the mapping from data to aesthetics. Each scale is a function from a region in data space (the domain) to a region in aesthetic space (the range).  The domain, as we already know, can be continuous or discrete, ordered or unordered.  The range consists of concrete aesthetics that you can perceive and that R can understand, such as position, colour, shape, size, and line type.  

If you blinked when you read that scales map data both to position and colour, you are not alone.  The notion that the same kind of object is used to map data to positions and symbols strikes some people as unintuitive.  However, you will see the logic and power of this notion as you read further in the chapter.

For each scale there is also a {\bf guide} which allows the viewer to perform the inverse mapping, from aesthetic space to data space.  For position aesthetics, the axes are the guides; for all other aesthetics, the legends do that job.

When a scale (and guide) are needed, ggplot automatically adds them using default values, so you can generate quite a lot of plots without knowing how scales work.  However, understanding scales and learning how to manipulate them gives you much more control over your plots.

% Add example showing an axis and legend(s?) for the same variable mapped to different aesthetics

This chapter covers:

\begin{itemize}
  \item How scales work, \secref{sec:how-scales-work}.
  \item Using scales: their names, arguments and roles, \secref{sec:scale-usage}.
  \item More details about individual scales, \secref{sec:more-details}.
  \item Controlling the appearance of axes and legends, \secref{sec:guides}.
\end{itemize}

\section{How scales work}
\label{sec:how-scales-work}

To describe how scales work, we will first describe the domain (the data space) and the range (the aesthetic space), and then outline the process by which one is mapped to the other.

Since an input variable is either discrete or continuous, the domain is either a set of values (stored as a factor, character vector, or logical vector) or an interval on the real line (stored as a numeric vector of length 2). For example, in the mammals sleep dataset, the domain of the discrete variable \var{vore} is \{carni, herbi, omni\}, and the domain of the continuous variable \var{bodywt} is $[0.005, 6654]$.

The range can also be discrete or continuous.  For discrete scales, it is a vector of aesthetic values corresponding to the input values. For continuous scales, it is a 1d path through some more complicated space.  For example, the continuous colour scales have a range which is a path through colour space.

%  'path through colour space' could use some elaboration

The range is either specified by the user when the scale is created, or by the scale itself.

The process of mapping the domain to the range often includes the following stages:

\begin{itemize}

  \item {\bf transformation}: For continuous variables, it is often useful to display a transformation of the data, such as a logarithm or square root.  This ensures that a plot of $\log(x)$ vs. $\log(y)$ on linear scales looks the same as $x$ vs. $y$ on log scales.  Transformations are described in more depth in Section~\ref{sub:scale-position}.

  After any transformations have been applied, the statistical summaries for each layer are computed based on the transformed data.

  \item {\bf training}:  During this key stage, the domain is learned.  Sometimes learning the domain of a scale is extremely straightforward: In a plot with only one layer, representing only raw data, it may consist simply of determining the minimum and maximum values of a continuous variable (after transformation), or listing the unique levels of a categorical variable.  However, sometimes the domain must reflect multiple layers.  For example, imagine a scale that will be used to create an axis; the minimum and maxiumum values of the raw data in the first layer and the statistical summary in the second layer are likely to be different, but they must all eventually be drawn on the same plot.

  The domain can also be specified directly, overriding the training process, by manually setting the domain of the scale with the {\tt limits} argument, as described in Section~\ref{sec:scale-usage}.  Any data values outside of the domain of the scale will be set to \code{NA}.

  \item {\bf mapping:}  The global domain has now been determined, and we already knew the range before we started this process.  The last thing to do, then, is to apply the scaling function that maps data values to aesthetic values.  Nothing needs to be done for some scales: For example, for continuous position scales, all the difficult work has already been done by the transformation step.

\end{itemize}

We have left a few stages out of this description of the process for simplicity.  For example, we haven't discussed the role faceting plays in training, and we have also ignored position adjustments.

\section{Usage}
\label{sec:scale-usage}

Every aesthetic has a default scale that is added to the plot whenever you use that aesthetic in a layer.  These are listed in Table~\ref{tbl:default-scales}.   To add a different scale or to modify some features of the default scale, you must first construct a new scale and then add it to the plot (using \code{+}). 

Default scales are added when you initialise the plot and when you add new layers.  This means it is possible to get a mismatch between the variable type and the scale type.  When this happens you need to add the correct scale yourself.

All scale constructors have a common naming scheme.  They start with \code{scale_}, followed by the name of the aesthetic (e.g., \code{colour_}, \code{shape_}, or \code{x_}), and finally by the name of the scale (e.g., \code{gradient}, \code{hue}, or \code{discrete}). For example, the name of the default scale for the colour aesthetic based on discrete data is {\tt scale\_colour\_hue()}, and the name of the Brewer colour scale for filled points is {\tt scale\_fill\_brewer()}.

Discrete variables include:

\begin{itemize}
  \item factors
  \item logical
  \item character
\end{itemize}


\begin{table}
  \begin{center}
  \begin{tabular}{p{1in}p{1in}p{1in}}
    \toprule
    Aesthetic & Discrete & Continuous \\
    \midrule
    Colour and fill & brewer \newline \textbf{hue} \newline identity \newline manual & \textbf{gradient} \newline gradient2 \newline gradientn \newline grey \\[0.5em]
    Position (x, y) & discrete & continuous \\[0.5em]
    Shape & \textbf{shape} \newline identity \newline manual &  \\[0.5em]
    Line type & \textbf{linetype} \newline identity \newline manual &  \\[0.5em]
    Size & \textbf{size\_discrete} \newline identity \newline manual & size \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Scales, by aesthetic and variable type.  Default scales are emboldened. The default scale varies depending on whether the variable is continuous or discrete.  Shape and line type do not not have a default continuous scale; size does not have a default discrete scale.}
  \label{tbl:default-scales}
\end{table}

The following code illustrates this process.  Note the use of breaks and labels arguments to control what appears on the legend.  These will be described in more detail in shortly. The default colour scale for discrete values uses equally spaced hues, the default scale for continuous values uses a gradient of colours between blue and yellow, and there are a number of Brewer colour scales designed to work well in a variety of situations (see \url{http://colorbrewer.org} for more detail).

% INTERWEAVE
% 
% p <- qplot(sleep_total, sleep_cycle, data=msleep, colour=vore)
% p 
% p + scale_colour_hue("What does\nit eat?", 
%    breaks = rev(c("herbi", "carni", "omni", NA)), 
%    labels = rev(c("plants", "meat", "both", "don't know")))
% p + scale_colour_brewer(pal="Set1")
\input{_include/52641849dfe6aaa081d2c76329d6af38.tex}
% END

As well as referring to scales explicitly by name, you can also refer to the default scales by their type:  {\tt discrete} or {\tt continuous}.  For example, the default discrete colour scale (hue) can be referred to as \code{scale_colour_discrete}.  It is possible to change the default scales with \f{set_default_scale}, described in Section~\ref{sub:customise-scales}.

% Having to specify the type of variable (continuous or discrete) seems like extra work: why can't ggplot2 figure that out by itself?  Well, it can't because you can create the scales independently of (and before) the plot.  Allows you to create scales independently of the plot.  

\section{Common arguments}
\label{sec:scale-arguments}

As well as having a common naming scheme, all scales share a set of common arguments.  These arguments control the basic operation of the scale and are described below.

\begin{itemize}
  \item {\bf name}:  sets the label which will appear on the axis or legend. You can supply text strings (using ``$\backslash$n'' for line breaks) or mathematical expressions (as described by \verb|?plotmath|).  The plots in the following figure are produced using this code:

  % LISTING
  % 
  % p <- qplot(tip, total_bill, data=tips, colour=tip/total_bill)
  % p + scale_colour_gradient("Tip rate")
  % p + scale_colour_gradient("The amount of the tip\ndivided by the total bill")
  % p + scale_colour_gradient(expression(frac(tip, total_bill)))
  \input{_include/19da2bba1759804ff8c1e077fc36c94d.tex}  
  % END

  Because {\tt scale\_colour\_gradient()} is the default scale for the colour aesthetic and continuous data, the only variation we see in the the plots is the different labels on the legends, and the resulting change in the plot's aspect ratio, in the case of the middle plot.

  % FIGURE
  %  LABEL: legend-names 
  %  CAPTION: Legends with names given by (from left to right): {\tt "Tip
  %  rate"}, {\tt "The amount of the tip$\backslash$ndivided by the total
  %  bill"} and {\tt expression(frac(tip, total\_bill)} 
  %  TEX-WIDTH: 0.33\linewidth
  %
  % p <- qplot(tip, total_bill, data=tips, colour=tip/total_bill)
  % p + scale_colour_gradient("Tip rate")
  % p + scale_colour_gradient("The amount of the tip\ndivided by the total bill")
  % p + scale_colour_gradient(expression(frac(tip, total_bill)))
  \input{_include/458d8d61b7bdaebe81b0bb4a3d71f417.tex}  
  % END

  \item {\bf limits}: fixes the domain of the scale.   Continuous scales take a numeric vector of length two; discrete scales take a character vector. If limits are set, no training of the data will be performed.  There are shortcut functions for setting the limits of x and y scales: \f{xlim} and \f{ylim}.  
  
  Limits are useful for zooming (i.e., setting limits that are smaller than the full range of data), and for ensuring that limits are consistent across multiple plots intended to be compared (i.e., setting limits that are larger or smaller than some of the default ranges).  
  
  Any value not in the domain of the scale is discarded: for an observation to be included in the plot, each aesthetic must be in the domain each scale.  This occurs before statistics are calculated. See Section~\ref{sub:cartesian} for purely visual zooming of the x and y axes.

  \item {\bf breaks} and {\bf labels}: {\bf breaks} controls which values appear on the axis or legend ~--~ e.g., at what values tick marks should appear on an axis or how a continuous scale is segmented in a legend.  {\bf labels} specifies the values that should appear at the breakpoints. (If {\tt labels} is set, you must also specify {\tt breaks}, so that the two can be matched up correctly.)  

  To distinguish breaks from limits, remember that breaks affect what appears on the guides, while limits affect what appears on the plot.  See by Figure~\ref{fig:breaks_vs_limits} for an illustration.  The first plot uses the default settings for both breaks and limits, which happen to be {\tt limits = c(4, 8)} and {\tt breaks = 4:8}.  In the second plot, the breaks have been reset: The plotted region is the same, but the tick positions and labels have shifted.  In the third plot, it is the limits which have been redefined, so much of the data now falls outside the plotting region. 
  
  % FIGURE
  %   LABEL: breaks_vs_limits
  %   COL: 3 TEX-WIDTH: 0.33\linewidth
  %   CAPTION: The difference between breaks and limits, demonstrated 
  %   using the x axis of {\tt qplot(cyl, wt, data = mtcars)}.  (Left) 
  %   default plot with {\tt limits = c(4, 8), breaks = 4:8}.  (Middle)  
  %   {\tt breaks = c(5.5,6.5)} and (right) {\tt limits = c(5.5,6.5)}.
  % 
  % p <- qplot(cyl, wt, data = mtcars)
  % p
  % p + scale_x_continuous(limits = c(5.5, 6.5))
  % p + scale_x_continuous(breaks = c(5.5, 6.5))
  \input{_include/0033cd85c46cfbf1e12e2d8dfe96c2d3.tex}  
  % END

  \item {\bf formatter}: if no labels are specified the formatter will be called on each break to produce the label.  Useful formatters for continuous scales are \f{comma}, \f{percent}, \f{dollar} and \f{scientific}, and for discrete scales is \f{abbreviate}.
\end{itemize}

\section{More details}
\label{sec:more-details}

Scales can be divided roughly into four separate groups:

\begin{itemize}
  \item Continuous position scales, used to map continuous variables onto the plotting region and to construct the corresponding axes.

  \item Colour gradients, used to map continuous variables to points or sub-regions in the plotting area and to construct the corresponding legends.  For example, colour gradients are used in rendering density surfaces.

  \item Discrete scales, used to map discrete variables to symbol size, shape or colour, and to create the corresponding legend.

  \item The identity scale, used to plot variable values directly to the aesthetic rather than mapping them.  For example, if the variable you want to map to symbol colour is itself a vector of colours, you want to plot those values rather than mapping them to some other colour scale.

\end{itemize}

\noindent  This section describes each type in more detail.  Precise details about individual scales can be found in the documentation, which can be used either within R (e.g.\ {\tt ?scale\_brewer}), or online at  \url{http://had.co.nz/ggplot2}.  The advantage of the online documentation is that you can see all the example plots, and navigate between pages more easily.

\subsection{Continuous position scales}
\label{sub:scale-position}

The most common continuous position scales are {\tt scale\_x\_continuous} and {\tt scale\_y\_continuous}, which map data to the x and y axis.  The most interesting variations are produced using transformations.  Every continuous scale takes a {\tt trans} argument, allowing the specification of a variety of transformations, both linear and non-linear.  The transformation is carried out by a ``transformer,'' which describes the transformation, its inverse, and how to draw the labels. Table~\ref{tbl:common-trans} lists some of the more common transformers.

\begin{table}
  \centering
  \begin{tabular}{lll}
    \toprule
    Name & Function $f(x)$ & Inverse $f^{-1}(x)$ \\
    \midrule
    asn       & $\tanh^{-1}(x)$ & $\tanh(x)$ \\
    exp       & $e ^ x$         & $\log(x)$  \\
    identity  & $x$             & $x$        \\
    log       & $\log(x)$       & $e ^ x$    \\
    log10     & $\log_{10}(x)$  & $10 ^ x$   \\
    log2      & $\log_2(x)$     & $2 ^ x$    \\
    logit     & $\log(\frac{x}{1 - x})$ & $\frac{1}{1 + e(x)} $ \\
    pow10     & $10^x$          & $\log_{10}(x) $ \\
    probit    & $\Phi(x)$       & $\Phi^{-1}(x)$ \\
    recip     & $x^{-1}$        & $x^{-1}$ \\
    reverse   & $-x$            & $-x$     \\
    sqrt      & $x^{1/2}$       & $x ^ 2$  \\
    % power     & $\frac{x^p - 1}{p * sgn(values - 1)}$ & $|values| * p + 1 $ 
    \bottomrule
  \end{tabular}
  \caption{List of built-in transformers.}
  \label{tbl:common-trans}
\end{table}

Transformations are most often used to modify position scales, so there are shortcuts for x, y, and z scales: \verb|scale_x_log10()| is equivalent to \verb|scale_x_continuous(trans = "log10")|.  The \code{trans} argument works for any continuous scale, including the colour gradients described below, but the shortcuts only exist for position scales.

Of course, you can also perform the transformation yourself.  For example instead of adding {\tt scale\_x\_log}, you could plot {\tt log(x)}.  That produces an identical result inside the plotting region, but the the axis and tick labels won't be the same.  If you use a transformed scale, the axes will be labelled in the original data space. In both cases, the transformation occurs before the statistical summary. Figure~\ref{fig:trans} illustrates this difference, and these commands produce the two plots in the figure:

% LISTING
% 
% qplot(log10(carat), log10(price), data=diamonds)
% qplot(carat, price, data=diamonds) + scale_x_log10() + scale_y_log10()
\input{_include/06e41578bc0ea18ae703166fa3712a50.tex}
% END

% FIGURE
%   FILETYPE: PNG
%   LABEL: trans
%   CAPTION: A scatterplot of diamond price vs. carat illustrating the
%   difference between log transforming the scale (left) and log transforming
%   the data (right).  The plots are identical, but the axis labels are
%   different.
% 
% qplot(log10(carat), log10(price), data=diamonds)
% qplot(carat, price, data=diamonds, log="xy")
\input{_include/7abbfebd8463e0ca02583d27ded7218e.tex}
% END

Transformers are also used in \f{coord_trans}, where the transformation occurs after the statistic has been calculated, and affect the shape of the graphical object drawn on the plot.  \f{coord_trans} is described in more detail in Section\ref{sub:cartesian}.

\subsection{Position scales}
\label{sub:position_scales}


\f{xlim} and \f{ylim}.  continuous, reverse and discrete.


\subsection{Colour gradients}
\label{sub:scale-gradient}

There are three types of colour gradients available.  A two--colour gradient, a three--colour gradient and a custom n--colour gradient.  This section introduces you to a little bit of theory how these gradients work and shows you how to create your own for specific purposes.

% You are probably most familiar with the rgb encoding of colour space, which defines a colour by the intensities of red, green and blue light needed to make it.  One problem with this space is that it is not perceptually uniform - the effect of moving by one unit varies by by both originally position and direction of movement.  There have m 

Colour gradients are often used to show the height of a 2d surface.  In the following example we'll use the surface of a 2d density estimate of the \code{faithful} dataset \citep{azzalini:1990}, which records the waiting time between eruptions and during of each eruption for the Old Faithful geyser in Yellowstone Park.  

Figure~\ref{fig:gradient} shows three gradients applied to this data.

% FIGURE
%   LABEL: gradient
%   CAPTION: Density of eruptions with three colour schemes.  (Left) default
%   gradient colour scheme, (mid) customised gradient from white to black and
%   (right) 3 point gradient with midpoint set to the median density.
% 
% f2d <- with(faithful, kde2d(eruptions, waiting, h= c(1, 10), n=50))
% df <- with(f2d, cbind(expand.grid(x, y), as.vector(z)))
% names(df) <- c("eruptions", "waiting", "density")
% p <- qplot(eruptions, waiting, data=df, fill=density, geom="tile") +
%   scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))
% p + scale_fill_gradient(limits = c(0, 0.04))
% p + scale_fill_gradient(limits = c(0, 0.04), low="white", high="black") 
% p + scale_fill_gradient2(limits = c(-0.04, 0.04), 
%   midpoint= median(df$density)) 
\input{_include/18d52b922f793fca89a59c65ee93bcb8.tex}
% END

% http://www.vendian.org/mncharity/dir3/blackbody/

You can also create your own custom gradient with \f{scale_colour_gradientn}.  This is useful if you have colours that are meaningful for your data (e.g.\ black body colours or standard terrain colours), or you'd like to use a palette produced by another package.  Figure~\ref{fig:vcd} shows show palettes generates from routines in the \code{vcd} package.  The technical report \citet{zeileis:2007} that describes the philosophy behind these palettes is a good introduction to some of the complexities of creating good colour scales.

% FIGURE 
%   LABEL: vcd
%   CAPTION: Gradient colour scales using perceptually well-formed palettes
%   produced by the \code{vcd} package.  From left to right: sequential,
%   diverging and heat hcl palettes.  Each scale is produced with 
%   \code{scale_fill_gradientn} with \code{values} set to 
%   \code{sequential_hcl(7)}, \code{diverge_hcl(7)} and \code{heat_hcl(7)}.
% 
% library(vcd)
% p + scale_fill_gradientn(colours = sequential_hcl(7), limits=c(0, 0.04))
% p + scale_fill_gradientn(colours = diverge_hcl(7), limits=c(0, 0.04))
% p + scale_fill_gradientn(colours = heat_hcl(7), limits=c(0, 0.04))
\input{_include/457748d5f44613123cb3cc73638f3c75.tex}
% END

\subsection{Discrete scales}
\label{sub:scale-discrete}

The discrete scales, \f{scale_linetype}, \f{scale_shape} and \f{scale_size_discrete} basically have no options (although for the shape scale you can choose whether points should be fixed or solid). Each has a list of values that are mapped to factor levels.

If you want to customise these scales, you need to create your own new scale with the manual scale: \f{scale_shape_manual}, \f{scale_linetype_manual}, \f{scale_colour_manual} etc..  It has one important argument, \verb|values| in which you specify the values that the scale should produce.  If this vector is named, it will match the values of the output to the values of the input, otherwise it will match in order of the levels of the discrete variable.   You will need some knowledge of the valid aesthetic values, which are described in Appendix \ref{cha:specifications}.

Legends always come from the scales, so you need to set up the plot in such a away that the scales know what you want. Here's a plot that captures the essence of your problem:

% INTERWEAVE  
% 
% huron <- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
% ggplot(huron, aes(year)) +
%   geom_line(aes(y = level - 5), colour = "blue") + 
%   geom_line(aes(y = level + 5), colour = "red")
\input{_include/1d76b9ec9c1a9e623ba01c17c0eeb846.tex}
% END

You have two lines from the same dataset that you want to colour differently, and include them in the legend.  In most other plotting systems, you'd just colour the lines as above, and then add a legend that describes which colour maps to which variable.  That doesn't work in ggplot2 because it's the scales that are responsible for drawing legends (the colour scale in this case), and they don't know about the values the lines should take.

What you need to do is tell the colour the scale about the two different lines by creating a mapping from the data to the colour aesthetic.  There's no variable present in the data, so you'll have to create one:

% INTERWEAVE  
% 
% ggplot(huron, aes(year)) +
%   geom_line(aes(y = level - 5, colour = "below")) + 
%   geom_line(aes(y = level + 5, colour = "above"))
\input{_include/a7a797923483c541d69f7470ff38e7e9.tex}
% END

This gets us basically what we want, but the legend isn't labelled correctly, and has the wrong colours.  That can be fixed with \code{scale_colour_manual}:

% INTERWEAVE  
% 
% ggplot(huron, aes(year)) +
%   geom_line(aes(y = level - 5, colour = "below")) + 
%   geom_line(aes(y = level + 5, colour = "above")) + 
%   scale_colour_manual("Direction", c("below" = "blue", "above" = "red"))
\input{_include/4a230808add7af66d1dc31daa53de20a.tex}
% END

In your original example, this is equivalent to operating on the molten data and using \code{geom_line(aes(colour = variable), data = molten)}


% TODO: add an example here!

\subsection{The identity scale}
\label{sub:scale-identity}

The identity scale is used when your data is already in a form that the plotting functions in R understand, i.e.\ when the data and aesthetic spaces are the same.  This means there is no way to derive a meaningful legend from the data alone, and by default a legend is not drawn.  However, you can still use the \code{breaks} and \code{labels} arguments to set up a legend yourself.

Figure~\ref{fig:scale-identity} shows one sort of data where \code{scale_identity} is useful.  Here the data themselves are colours, and there's no way we could make a meaningful legend.  The identity scale can also be useful in the case where you have manually scaled the data to aesthetic values.  In that situation, you will have to figure out what breaks and labels make sense for your data.

% FIGURE
%   LABEL: scale-identity
%   COL:1 TEX-WIDTH: 0.5\linewidth
%   CAPTION: A plot of R colours in Luv space.  A legend is unnecessary,
%   because the colour of the points represents itself: the data and aesthetic
%   spaces are the same.
% 
% x <- colors()
% luv <- as.data.frame(convertColor(t(col2rgb(x)), "sRGB", "Luv"))
% qplot(u, v, data=luv, colour = x, size = I(3)) + scale_colour_identity() +
%    coord_equal()
\input{_include/53537193bca30ccfa0b0992f5b1ea2c0.tex}
% END

\section{Legends and axes}
\label{sec:guides}

Collectively, axes and legends are called {\bf guides}, and they are the inverse of the scale: they allow you to read observations from the plot and map them back to their original values.  Figure~\ref{fig:labelled-guides} labels the guides and their components.  There are natural equivalents between the legend and the axis: the legend title and axis label are equivalent and determined by the scale name; the legend keys and tick labels are both determined by the scale breaks.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\linewidth]{scale-guides}
  
  \caption{The components of the axes and legend.}
  \label{fig:labelled-guides}
\end{figure}

In \ggplot, legends and axes are produced automatically based on the scales and geoms that you used in the plot. This is different to how legends work in most other plotting systems, where you are responsible for adding them.  In \ggplot, there is little you can do to directly control the legend.  This seems like a big restriction at first, but as you get more comfortable with this approach, you will discover that is saves you a lot of time, and there is little you can not do with it.

To draw the legend, the plot must collect information about how each aesthetic is used: for what data and what geoms. The scale breaks are used to determine the values of the legend keys and a list of the geoms that use the aesthetic  is used to determine how to draw the keys. For example, if you use the point geom, then you will get points in the legend; if you use the lines geom, you will get lines. If both point and line geoms are used, then both points and lines will be drawn in the legend.  This is illustrated in Figure~\ref{fig:legend-geom}.

% FIGURE
%   TEX-WIDTH: 1in  GG-WIDTH: 1.5 GG-HEIGHT: 2
%   LABEL: legend-geom
%   CAPTION: Legends produced by geom point, geom line, geom point and 
%   geom line, and geom bar.
% 
% p <- ggplot(diamonds[1:100, ], aes(price, carat, colour = cut)) +  
%   opts(keep = "legend_box")
% p + geom_point()
% p + geom_line()
% p + geom_point() + geom_line()
% p + geom_bar(binwidth = 100) + aes(fill = cut, y = ..count..)
\input{_include/ecbe34b0bfbb93f648bcd52b9e11c930.tex}
% END

\ggplot tries to use the smallest possible number of legends that accurately conveys the aesthetics used in the plot.  It does this by combining legends if a variable is used with more than one aesthetic.  Figure~\ref{fig:legend-merge} shows an example of this for the points geom: if both colour and shape are mapped to the same variable, then only a single legend is necessary.  In order for legends to be merged, they must have the same name (the same legend title).  For this reason, if you change the name of one of the merged legends you'll need to change it for all of them.

% FIGURE
%   TEX-WIDTH: 1in  GG-WIDTH: 1.5 GG-HEIGHT: 2
%   LABEL: legend-merge
%   CAPTION: Colour legend, shape legend, colour + shape legend. 
% 
% p <- ggplot(diamonds[1:100, ], aes(price, carat)) +  
%   geom_point() + 
%   opts(keep = "legend_box")
% p + aes(colour = cut)
% p + aes(shape = cut)
% p + aes(shape = cut, colour = cut)
\input{_include/7abcdc04c1317ae2f584552b865abfb8.tex}
% END

To content of the legend and axes is controlled by the scale, and the details of the rendering are controlled by the theming system.  The following list includes the most commonly tweaked settings.

\begin{itemize}
  \item The scale {\tt name} controls the axis label and the legend title.  This can be a string, or a mathematical expression, as described in \code{?plotmath}.
  
  \item The {\tt breaks} and {\tt labels} arguments to the scale function, introduced earlier in this chapter, are particularly important because they control what tick marks appear on the axis and what keys appear on the legend.  If the breaks chosen by default are not appropriate (or you want to use more informative labels) setting these arguments will adjust the appearance of the legend keys and axis ticks.  
  
  \item The theme settings {\tt axis.*} and {\tt legend.*} control the visual appearance of axes and legends.  To learn how to manipulate these settings, see Section~\ref{sec:themes}.

  \item The internal grid lines are controlled by the breaks and minor breaks arguments.  By default minor grid lines are spaced evenly in the original data space: this gives the common behaviour of log-log plots where major grid lines are multiplicative and minor grid lines are additive.  You can override the minor grid lines with the {\tt minor\_breaks} argument.  Grid line appearance is controlled by the \code{panel.grid.major} and \code{panel.grid.minor} theme settings.

  \item The position and justification of legends are controlled by the theme setting {\tt legend.position}, and the value can be right, left, top, bottom, none (no legend), or a numeric position.  The numeric position gives (in values between 0 and 1) the position of the corner given by {\tt legend.justification}, a numeric vector of length two.  Top-right = \code{c(1, 1)}, bottom-left = \code{c(0, 0)}.
  
  \item Position scales also have the {\bf expand} argument, which controls the amount of extra space added to axis limits.  This is a numeric vector of length two: the first number is a multiplicative amount and the second is an additive constant.  The default for continuous scales is {\tt c(0.05, 0)} (i.e.,\ add 5\% extra space on each end); for discrete scales it is {\tt c(0, 0.75)}).  Set to {\tt c(0, 0)} to eliminate extra space.
  
\end{itemize}

\section{More resources}
\label{sec:scale_resources}

As you experiment with different aesthetic choices and new scales, it's important to keep in mind how the plot will be perceived.   Some particularly good references to consult are:

\begin{itemize}
  \item \citet{cleveland:1993,cleveland:1987,cleveland:1994} for research on how plots are perceived and the best ways to encode data.
  \item \citet{tufte:2006,tufte:1990,tufte:1997,tufte:2001} for how to make beautiful, data-rich, graphics.
  \item \citet{brewer:1994,brewer:1994a} for how to choose colours that work well in a wide variety of situations, particularly for area plots.
  \item \citet{carr:1999,carr:1994,carr:2002} for the use of colour in general.
\end{itemize}

\input{_footer.tex}
