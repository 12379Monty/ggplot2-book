\input{_header.tex}
\chapter{Scales, axes and legends}
\label{cha:scales}

% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.33\textwidth COL: 3 
%   INLINE: FALSE
%   CACHE: TRUE
% 

% END

\section{Introduction}

Scales control the mapping from data to aesthetics. Each scale is a function from a region in data space (the domain) to a region in aesthetic space (the range).  The domain, as we already know, can be continuous or discrete, ordered or unordered.  The range consists of concrete aesthetics that you can perceive and that R can understand, such as position, colour, shape, size, and line type.  

If you blinked when you read that scales map data both to position and colour, you are not alone.  The notion that the same kind of object is used to map data to positions and symbols strikes some people as unintuitive.  However, you will see the logic and power of this notion as you read further in the chapter.

For each scale there is also a {\bf guide} which allows the viewer to perform the inverse mapping, from aesthetic space to data space.  For position aesthetics, the axes are the guides; for all other aesthetics, the legends do that job.

When a scale (and guide) are needed, ggplot automatically adds them using default values, so you can generate quite a lot of plots without knowing how scales work.  However, understanding scales and learning how to manipulate them gives you much more control over your plots.

% Add example showing an axis and legend(s?) for the same variable mapped to different aesthetics

This chapter covers:

\begin{itemize}
  \item How scales work, \secref{sec:how-scales-work}.
  \item Using scales: their names, arguments and roles, \secref{sec:scale-usage}.
  \item More details about individual scales, \secref{sec:more-details}.
  \item Controlling the appearance of axes and legends, \secref{sec:guides}.
\end{itemize}

\section{How scales work}
\label{sec:how-scales-work}

To describe how scales work, we will first describe the domain (the data space) and the range (the aesthetic space), and then outline the process by which one is mapped to the other.

Since an input variable is either discrete or continuous, the domain is either a set of values (stored as a factor, character vector, or logical vector) or an interval on the real line (stored as a numeric vector of length 2). For example, in the mammals sleep dataset, the domain of the discrete variable \var{vore} is \{carni, herbi, omni\}, and the domain of the continuous variable \var{bodywt} is $[0.005, 6654]$.

The range can also be discrete or continuous.  For discrete scales, it is a vector of aesthetic values corresponding to the input values. For continuous scales, it is a 1d path through some more complicated space.  For example, the continuous colour scales have a range which is a path through colour space.

%  'path through colour space' could use some elaboration

The range is either specified by the user when the scale is created, or by the scale itself.

The process of mapping the domain to the range often includes the following stages:

\begin{itemize}

  \item {\bf transformation}: For continuous variables, it is often useful to display a transformation of the data, such as a logarithm or square root.  This ensures that a plot of $log(x)$ vs $log(y)$ on linear scales looks the same as $x$ vs $y$ on log scales.  Transformations are described in more depth in Section~\ref{sec:trans}.

  After any transformations have been applied, the statistical summaries for each layer are computed based on the transformed data.

  \item {\bf training}:  During this key stage, the domain is learned.  Sometimes learning the domain of a scale is extremely straightforward: In a plot with only one layer, representing only raw data, it may consist simply of determining the minimum and maximum values of a continuous variable (after transformation), or listing the unique levels of a categorical variable.  However, sometimes the domain must reflect multiple layers.  For example, imagine a scale that will be used to create an axis; the minimum and maxiumum values of the raw data in the first layer and the statistical summary in the second layer are likely to be different, but they must all eventually be drawn on the same plot.

  The domain can also be specified directly, overriding the training process, by manually setting the domain of the scale with the {\tt limits} argument, as described in Section~\ref{sec:scale-usage}.  Any data values outside of the domain of the scale will be set to \code{NA}.

  \item {\bf mapping:}  The global domain has now been determined, and we already knew the range before we started this process.  The last thing to do, then, is to apply the scaling function that maps data values to aesthetic values.  Nothing needs to be done for some scales: For example, for continuous position scales, all the difficult work has already been done by the transformation step.

\end{itemize}

We have left a few stages out of this description of the process for simplicity.  For example, we haven't discussed the role facetting plays in training, and we have also ignored position adjustments.

\section{Constructing and using scales}
\label{sec:scale-usage}

Every aesthetic has a default scale that is added to the plot whenever you use that aesthetic in a layer.  These are listed in Table~\ref{tbl:default-scales}.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aesthetic & Discrete & Continuous \\
    \midrule
    Colour and fill & hue & gradient \\
    Position & discrete & continuous \\
    Shape & shape & --- \\
    Line type & linetype & --- \\
    Size & discrete  & size \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Default scales, by aesthetic and variable type.  The default scale varies depending on whether the variable is continuous or discrete.  Shape and line type do not not have a default continuous scale; size does not have a default discrete scale.}
  \label{tbl:default-scales}
\end{table}

To add a different scale or to modify some features of the default scale, create a scale object and add it to a plot (using \code{+}). All scale constructors have a common naming scheme.  They start with \code{scale_}, followed by the name of the aesthetic (e.g., \code{colour_}, \code{shape_}, or \code{x_}), and finally by the name of the scale (e.g., \code{gradient}, \code{hue}, or \code{discrete}). For example, the name of the default scale for the colour aesthetic based on discrete data is {\tt scale\_colour\_hue()}, and the name of the Brewer colour scale for filled points is {\tt scale\_fill\_brewer()}.

% unused, Hadley says.
%% TABLE
%  CAPTION: List of all scales, arranged by the aesthetic that they apply to
%  LABEL: tbl:scale_list
%
% source("scales-list.r")
% cat(laply(names(scales), function(s) paste(type_header(s), type_table(s), sep ="")))
% cat("\\bottomrule\n")
\input{_include/b1c20cb5f274a63081172bb96a5139ac.tex}
% END

The following example shows the difference between the default discrete and continuous scales for colour, as well as how to override the default scale; this is the code used to generate the plots:

% dfs: I can't test this, because I don't know where the msleep data is.
% Some remark should be made about the use of breaks and labels, too,
% which will be addressed later in the chapter.

% LISTING
% 
% p <- qplot(sleep_total, sleep_cycle, data=msleep, colour=vore)
% p 
% p + scale_colour_discrete("What does\nit eat?", 
%    breaks = rev(c("herbi", "carni", "omni", NA)), 
%    labels = rev(c("plants", "meat", "both", "don't know")))
% p + scale_colour_brewer(pal="Set1")
\input{_include/8e983f5df469e74da4b092ac2253cd08.tex}
% END

% FIGURE
%  LABEL: scale-defaults
%  CAPTION: Differences between default discrete and continuous colour
%  scales
% 
% p <- qplot(sleep_total, sleep_cycle, data=msleep, colour=vore)
% p 
% p + scale_colour_discrete("What does\nit eat?", 
%    breaks = rev(c("herbi", "carni", "omni", NA)), 
%    labels = rev(c("plants", "meat", "both", "don't know")))
% p + scale_colour_brewer(pal="Set1")
\input{_include/982fa40b20ff2d7ddacfa6a3004f4ba4.tex}
% END


The default colour scale for discrete values uses equally spaced hues, the default scale for continuous values uses a gradient of colours between blue and yellow, and there are a number of Brewer colour scales designed to work well in a variety of situations (see \url{http://colorbrewer.org} for more detail).

As well as referring to scales explicitly by name, you can also refer to the default scales with the shorthand scale name {\tt discrete} or {\tt continuous}.  For example, the default discrete colour scale is \code{scale_colour_discrete}.  You can change the default scales with \code{set_default_scale(aesthetic, variable_type, scale_name, ...)}.  Extra arguments are passed to the scale constructor.  For example, if you wanted to set up default black and white colour scales you could execute:

% LISTING
% 
% set_default_scale("colour", "discrete", "grey")
% set_default_scale("colour", "continous", "gradient", 
%  low = "white", high = "black"
% )
\input{_include/35676a642b9a8d856dfaf88b1d9d157f.tex}
% END

% Having to specify the type of variable (continuous or discrete) seems like extra work: why can't ggplot2 figure that out by itself?  Well, it can't because you can create the scales independently of (and before) the plot.  Allows you to create scales independently of the plot.  

As well as having a common naming scheme, all scales share a set of common arguments.  These arguments control the basic operation of the scale and are described below.

\begin{itemize}
  \item {\bf name}:  sets the label which will appear on the axis or legend. You can supply text strings (using ``$\backslash$n'' for line breaks) or mathematical expressions (as described by \verb|?plotmath|).  The plots in the following figure are produced using this code:

  % LISTING
  % 
  % p <- qplot(tip, total_bill, data=tips, colour=tip/total_bill)
  % p + scale_colour_gradient("Tip rate")
  % p + scale_colour_gradient("The amount of the tip\ndivided by the total bill")
  % p + scale_colour_gradient(expression(frac(tip, total_bill)))
  \input{_include/19da2bba1759804ff8c1e077fc36c94d.tex}  
  % END

  Because {\tt scale\_colour\_gradient()} is the default scale for the colour aesthetic and continuous data, the only variation we see in the the plots is the different labels on the legends ~--~ and the resulting change in the plot's aspect ratio, in the case of the middle plot.

  % FIGURE
  %  LABEL: legend-names 
  %  CAPTION: Legends with names given by (from left to right): {\tt "Tip
  %  rate"}, {\tt "The amount of the tip$\backslash$ndivided by the total
  %  bill"} and {\tt expression(frac(tip, total\_bill)} 
  %  TEX-WIDTH: 0.33\textwidth
  %
  % p <- qplot(tip, total_bill, data=tips, colour=tip/total_bill)
  % p + scale_colour_gradient("Tip rate")
  % p + scale_colour_gradient("The amount of the tip\ndivided by the total bill")
  % p + scale_colour_gradient(expression(frac(tip, total_bill)))
  \input{_include/9519eadffa5f56fccec7f840a298b9dd.tex}  
  % END

  \item {\bf limits}: fixes the domain of the scale.   Continuous scales take a numeric vector of length two; discrete scales take a character vector. If limits are set, no training of the data will be performed.  
  
  There are shortcut functions for setting the limits of continuous x and y scales: \f{xlim} and \f{ylim}.  Each has two arguments specifying the endpoints of the new domain, and each creates a scale object.  
  
  This is particularly useful for zooming (i.e., setting limits that are smaller than the full range of data), and for ensuring that limits are consistent across multiple plots intended to be compared (i.e., setting limits that are larger or smaller than some of the default ranges).  
  
  Any value not in the domain of the scale is not displayed; i.e., for an observation to be displayed it must be in the domain of every scale on the plot.

  \item {\bf breaks} and {\bf labels}: {\bf breaks} controls which values appear on the axis or legend ~--~ e.g., at what values tick marks should appear on an axis or how a continuous scale is segmented in a legend.  {bf labels} specifies the values that should appear at the breakpoints. (If {\tt labels} is set, you must also specify {\tt breaks}, so that the two can be matched up correctly.)  

To distinguish breaks from limits, remember that breaks affect what appears on the guides, while limits affect what appears on the plot.  See by Figure~\ref{fig:breaks_vs_legends} for an illustration.  The first plot uses the default settings for both breaks and limits, which happen to be limits = c(4, 8) and breaks = 4:8.  In the second plot, the breaks have been reset: The plotted region is the same, but the tick positions and labels have shifted.  In the third plot, it is the limits which have been redefined, so much of the data now falls outside the plotting region. 
  % Alternatively, both breaks and labels can be a function with a single  argument, range, that returns a numeric vector (for breaks) or a character vector (for labels) with desired break positions and labels.
\end{itemize}

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.33\textwidth]{scales-unlimited}%
    \includegraphics[width=0.33\textwidth]{scales-breaks}%
    \includegraphics[width=0.33\textwidth]{scales-limits}
  \caption{The difference between breaks and limits.  (Left) default plot \code{limits = c(4, 8), breaks = 4:8}.  (Middle)  {\tt breaks = c(5.5,6.5)} and (right) {\tt limits = c(5.5,6.5)}.}
  \label{fig:breaks_vs_legends}
\end{figure}

This code generates the plots in the figure:

% LISTING
% 
% p <- qplot(cyl, wt, data=mtcars)
% p
% p + scale_x_continuous(breaks=c(5.5, 6.5))
% p + scale_x_continuous(limits=c(5.5, 6.5))
\input{_include/02035a1ee69230c7eea2c0d4bf857235.tex}
% END

\section{More details}
\label{sec:more-details}


Scales can be divided roughly into four separate groups:

\begin{itemize}
  \item Continuous position scales, used to map continuous variables onto the plotting region and to construct the corresponding axes.

  \item Colour gradients, used to map continuous variables to points or sub-regions in the plotting area and to construct the corresponding legends.  For example, colour gradients are used in rendering density surfaces.

  \item Discrete scales, used to map discrete variables to symbol size, shape or colour, and to create the corresponding legend.

  \item The identity scale, used to plot variable values directly to the aesthetic rather than mapping them.  For example, if the variable you want to map to symbol colour is itself a vector of colours, you want to plot those values rather than mapping them to some other colour scale.

\end{itemize}

\noindent  This section describes each type in more detail.  Precise details about individual scales can be found in the documentation, which can be used either within R (e.g.\ {\tt ?scale\_brewer}), or online at  \url{http://had.co.nz/ggplot2}.  The advantage of the online documentation is that you can see all the example plots, and navigate between pages more easily.

\subsection{Continuous position scales}
\label{sub:scale_position}

The most common continuous position scales are {\tt scale\_x\_continuous} and {\tt scale\_y\_continuous}, which map data to the x and y axis.  The most interesting variations are produced using transformations.  Every continuous scale takes a {\tt trans} argument, allowing the specification of a variety of transformations, both linear and non-linear.  The transformation is carried out by a ``transformer,'' which describes the transformation, its inverse, and how to draw the labels. Table~\ref{tbl:common-trans} lists some of the more common transformers.

\begin{table}
  \centering
  \begin{tabular}{lll}
    \toprule
    Name & Function $f(x)$ & Inverse $f^{-1}(x)$ \\
    \midrule
    asn       & $\tanh^{-1}(x)$ & $\tanh(x)$ \\
    exp       & $e ^ x$         & $\log(x)$  \\
    identity  & $x$             & $x$        \\
    log       & $\log(x)$       & $e ^ x$    \\
    log10     & $\log_{10}(x)$  & $10 ^ x$   \\
    log2      & $\log_2(x)$     & $2 ^ x$    \\
    logit     & $\log(\frac{x}{1 - x})$ & $\frac{1}{1 + e(x)} $ \\
    pow10     & $10^x$          & $\log_{10}(x) $ \\
    probit    & $\Phi(x)$       & $\Phi^{-1}(x)$ \\
    recip     & $x^{-1}$        & $x^{-1}$ \\
    reverse   & $-x$            & $-x$     \\
    sqrt      & $x^{1/2}$       & $x ^ 2$  \\
    % power     & $\frac{x^p - 1}{p * sgn(values - 1)}$ & $|values| * p + 1 $ 
    \bottomrule
  \end{tabular}
  \caption{List of built-in transformers.}
  \label{tbl:common-trans}
\end{table}

Transformations are most often used to modify position scales, so there are shortcuts for x, y, and z scales: \verb|scale_x_log10()| is equivalent to \verb|scale_x_continuous(trans = "log10")|.

Of course, you can also perform the transformation yourself.  For example instead of adding {\tt scale\_x\_log}, you could plot {\tt log(x)}.  That produces an identical result inside the plotting region, but the the axis and tick labels won't be the same.  If you use a transformed scale, the axes will be labelled in the original data space. In both cases, the transformation occurs before the statistical summary. Figure~\ref{fig:trans} illustrates this difference, and these commands produce the two plots in the figure:

% dfs: Is one of these log base 10 and the other natural log?

% LISTING
% 
% qplot(carat, price, data=diamonds) + scale_x_log10() + scale_y_log10()
% qplot(log10(carat), log10(price), data=diamonds)
\input{_include/f3690019914297c3070eed0d28806753.tex}
% END

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.5\textwidth]{trans-scale}%
    \includegraphics[width=0.5\textwidth]{trans-data}
  \caption{A scatterplot of diamond price vs. carat illustrating the difference between log transforming the scale (left) and log transforming the data (right).  The plots are identical, but the axis labels are different.}
  \label{fig:trans}
\end{figure}


%%% dfs -- note that the word 'grob' suddenly appears here without
%%% any definition or explanation.

Transformers are also used in \verb|coord_trans|, where the transformation occurs after the statistic has been calculated, and affect the shape of the grob.  \verb|coord_trans| is described in more detail in Section XXX.

The \code{trans} argument works for any continuous scale, including the colour gradients described below, but the shortcuts only exist for position scales.

\subsection{Colour gradients}
\label{sub:scale-gradient}

There are three types of colour gradients available.  A two--colour gradient, a three--colour gradient and a custom n--colour gradient.  This section introduces you to a little bit of theory how these gradients work and shows you how to create your own for specific purposes.

% f2d <- with(faithful, kde2d(eruptions, waiting, h= c(1, 10), n=50))
% df <- with(f2d, cbind(expand.grid(x, y), as.vector(z)))
% names(df) <- c("eruptions", "waiting", "density")
% p <- qplot(eruptions, waiting, data=df, fill=density, geom="tile")  + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0))

% You are probably most familiar with the rgb encoding of colour space, which defines a colour by the intensities of red, green and blue light needed to make it.  One problem with this space is that it is not perceptually uniform - the effect of moving by one unit varies by by both originally position and direction of movement.  There have m 

Colour gradients are often used to show the height of a 2d surface.  In the following example we'll use the surface of a 2d density estimate of the \code{faithful} dataset \citep{azzalini:1990}, which records the waiting time between eruptions and during of each eruption for the Old Faithful geyser in Yellowstone Park.  

Figure~\ref{fig:gradient} shows three gradients applied to this data.

% p + scale_fill_gradient(limits=c(0, 0.04))
% ggsave(file="_include/scale-gradient-1.pdf", width=6, height=6)
% p + scale_fill_gradient(limits=c(0, 0.04), low="white", high="black") 
% ggsave(file="_include/scale-gradient-2.pdf", width=6, height=6)
% p + scale_fill_gradient2(limits=c(-0.04, 0.04), midpoint= median(df$density)) 
% ggsave(file="_include/scale-gradient-3.pdf", width=6, height=6)

\begin{figure}[htbp]
  \centering
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-1}%
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-2}%
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-3}
  \caption{Density of eruptions with three colour schemes.  (Left) default gradient colour scheme, (mid) customised gradient from white to black and (right) 3 point gradient with midpoint set to the median density.}
  \label{fig:gradient}
\end{figure}

% http://www.vendian.org/mncharity/dir3/blackbody/

You can also create your own custom gradient with \f{scale_colour_custom}.  This is useful if you have colours that are meaningful for your data (e.g.\ black body colours or standard terrain colours), or you'd like to use a palette produced by another package.  Figure~\ref{fig:vcd} shows show palettes generates from routines in the \code{vcd} package.  The technical report \citet{zeileis:2007} that describes the philosophy behind these palettes is a good introduction to some of the complexities of creating good colour scales.

% library(vcd)
% p + scale_fill_gradientn(colours = sequential_hcl(7), limits=c(0, 0.04))
% ggsave(file="_include/scale-gradient-vcd-1.pdf", width=6, height=6)
% p + scale_fill_gradientn(colours = diverge_hcl(7), limits=c(0, 0.04))
% ggsave(file="_include/scale-gradient-vcd-2.pdf", width=6, height=6)
% p + scale_fill_gradientn(colours = heat_hcl(7), limits=c(0, 0.04))
% ggsave(file="_include/scale-gradient-vcd-3.pdf", width=6, height=6)

\begin{figure}[htbp]
  \centering
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-vcd-1}%
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-vcd-2}%
    \includegraphics[width= 0.33 \textwidth]{scale-gradient-vcd-3}
  \caption{Gradient colour scales using perceptually well-formed palettes produced by the \code{vcd} package.  From left to right: sequential, diverging and heat hcl palettes.}
  \label{fig:vcd}
\end{figure}

\subsection{Discrete scales}
\label{sub:scale-discrete}

The discrete scales, \f{scale_linetype}, \f{scale_shape} and \f{scale_size_discrete} basically have no options (although for the shape scale you can choose whether points should be fixed or solid).  If you want to customise these scales, you need to create your own new scale with the manual scale.  It has one important argument, \verb|values| in which you specify the values that the scale should produce.  If this vector is named, it will match the values of the output to the values of the input, otherwise it will match in order of the levels of the discrete variable.  

This scale is particularly useful if you'd like to override the default shape, size or linetype scales.  You will need some knowledge of the valid aesthetic values, which are described in Appendix \ref{cha:specifications}.

\subsection{The identity scale}
\label{sub:scale-identity}

The identity scale is used when your data is already in a form that the plotting functions in R understand, i.e.\ when the data and aesthetic spaces are the same.  This means there is no way to derive a meaningful legend from the data alone, and by default a legend is not drawn.  However, you can still use the \code{breaks} and \code{labels} arguments to set up a legend yourself.

Figure~\ref{fig:scale-identity} shows one sort of data where \code{scale_identity} is useful.  Here the data themselves are colours, and there's no way we could make a meaningful legend.  The identity scale can also be useful in the case where you have manually scaled the data to aesthetic values.  In that situation, you will have to figure out what breaks and labels make sense for your data.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.5\textwidth]{scale-identity}
  \caption{A plot of R colours in Luv space.  A legend is unnecessary, because the colour of the points represents itself: the data and aesthetic spaces are the same.}
  \label{fig:scale-identity}
\end{figure}

\section{Legends and axes}
\label{sec:guides}

Collectively, axes and legends are called guides, and they are like the inverse of the scale: they allow you to read observations from the plot and map them back to their original values.  Figure~\ref{fig:labelled-guides} labels the guides and their components.  There are natural equivalents between the legend and the axis: legend name and axis label; legend keys and tick labels.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{scale-guides}
  
  \caption{The components of the axes and legend.}
  \label{fig:labelled-guides}
\end{figure}

In \ggplot, legends and axes are produced automatically based on the scales and geoms that you used in the plot. This requires collecting information about how each aesthetic is used. We use the domain of the scale for the aesthetic to determine the value of the legend keys; we use a list of the geoms that use the aesthetic to determine how to draw the keys. For example, the point geom has points in the legend key and the lines geom has lines. If both points and lines are used then both will be drawn.

\ggplot tries to use the smallest possible number of legends that accurately conveys the scales used in the plot.  It does this by combining legends for the same variable with different aesthetics.  Figure~\ref{fig:legend-merge} shows an example of this.  

% In order for legends to be merged, they must have the same title.  For this reason, if you change the title of one of the merged legends you'll need to change it for all of them.


% p <- ggplot(diamonds[1:100, ], aes(x=price, y=carat)) + geom_point() + geom_point() + opts(keep = "legend_box")
% p + aes(colour = cut)
% ggsave(file="_include/lm-1.pdf", width=1.5, height=1.9)
% p + aes(shape = cut)
% ggsave(file="_include/lm-2.pdf", width=1.5, height=1.9)
% p + aes(shape = cut, colour= cut)
% ggsave(file="_include/lm-2.pdf", width=1.5, height=1.9)
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1in]{lm-1}%
  \includegraphics[width=1in]{lm-2}%
  \includegraphics[width=1in]{lm-3}
  
  \caption{Colour legend, shape legend, colour + shape legend. }
  \label{fig:legend-merge}
\end{figure}

\subsection{Customising appearance}

It is possible to customize both the contents of the legends and the way they are rendered using the following arguments and options.

\begin{itemize}
  \item The {\tt breaks} and {\tt labels} arguments to the scale function, introduced earlier in this chapter, are particularly important because they control what tick marks appear on the axis and what keys appear on the legend.  If the breaks chosen by default are not appropriate (or you want to use more informative labels) setting these arguments will adjust the appearance of the legend keys and axis tick marks.  
  
  \item The theme settings {\tt axis.box}, {\tt axis.title}, {\tt axis.ticks}, {\tt legend.box}, {\tt legend.title}, and {\tt legend.keys} control the visual appearance of axes and legends.  For more details on how to manipulate these settings, see Section~\ref{sec:theming}.

  \item The internal grid lines are controlled by the breaks and minor breaks arguments.  By default minor grid lines are spaced evenly in the original data space - this gives the common behaviour of log-log plots where major grid lines are multiplicative and minor grid lines are additive.  You can override the minor grid lines with the {\tt minor\_breaks} argument.

% dfs: what are npc coordinates?  

  \item Position and justification of legends.  Plot level option setting: {\tt legend.position}, can be right, left, top, bottom, none (no legend), or a numeric position.  The numeric position gives (in npc coordinates) the position of the corner given by {\tt legend.justification}.  
  
  \item Position scales also have the {\bf expand} argument, which controls the amount of extra space added to axis limits.  This is a numeric vector of length two: the first number is a multiplicative amount and the second is an additive constant.  The default for continuous scales is {\tt c(0.05, 0)} (i.e.,\ add 5\% extra space on each end); for discrete scales it is {\tt c(0, 0.75)}).  Set to {\tt c(0, 0)} to eliminate extra space.
  
\end{itemize}

\section{More resources}
\label{sec:scale_resources}

As you experiment with different aesthetic choices and new scales, it's important to keep in mind how the plot will be perceived.   Some particularly good references to consult are:

\begin{itemize}
  \item \citet{cleveland:1993,cleveland:1987,cleveland:1994} for research on how plots are perceived and the best ways to encode data.
  \item \citet{tufte:2006,tufte:1990,tufte:1997,tufte:2001} for how to make beautiful, data-rich, graphics.
  \item \citet{brewer:1994,brewer:1994a} for how to colours that work well in a wide variety of situations, particularly for area plots.
  \item \citet{carr:1999,carr:1994,carr:2002}, for the use of colour in general.
\end{itemize}

\input{_footer.tex}
