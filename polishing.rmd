---
output: bookdown::html_chapter
bibliography: references.bib
---

```{r polishing, include = FALSE}
source("common.R")
```

# Themes {#cha:polishing}

In this chapter you will learn how to prepare polished plots for publication using ggplot2 theme system, which allows you to exercise fine control over the non-data elements of your plot. The theme system does not affect how the data is rendered by geoms, or how it is transformed by scales. Themes don't change the perceptual properties of the plot, but they do help you make the plot aesthetically pleasing or match existing style guides. Themes give you control over things like the fonts in all parts of the plot: the title, axis labels, axis tick labels, strips, legend labels and legend key labels; and the colour of ticks, grid lines and backgrounds (panel, plot, strip and legend). \index{Themes} \index{Publication!themes}

This separation of control into data and non-data parts is quite different than base and lattice graphics. In base and lattice graphics, most functions take a large number of arguments that specify both data and non-data appearance, which makes the functions complicated and hard to learn. ggplot2 takes a different approach: when creating the plot you determine how the data is displayed, then *after* it has been created you can edit every detail of the rendering, using the theming system. 

For example, imagine you've made the following plot of your data.

`r columns(1, 2/3)`
```{r}
base <- ggplot(mpg, aes(cty, hwy, color = factor(cyl))) +
  geom_jitter() + 
  geom_abline(colour = "grey50", size = 2)
base
```

It's served it's purpose for you: you've learned that `cty` and `hwy` are highly correlated, both are highly related to `cyl`, and that `hwy` is always greater than `cty` (and the difference increases as `cty` increases). Now you want to share the plot with others, perhaps by publishing it in a paper. That requires some changes. First, we need to make sure the plot can stand alone by:

* Improving the axes and legend labels.
* Adding a title for the plot.
* Tweaking the colour scale.

Fortunately you know how to do that already because you've read the scales chapter:

```{r}
labelled <- base +
  labs(
    x = "City mileage/gallon",
    y = "Highway mileage/gallon",
    colour = "Cylinders",
    title = "Highway and city mileage are highly correlated"
  ) +
  scale_colour_brewer(type = "seq", palette = "Spectral")
labelled
```

Next, you need to make sure the plot matches the style guidelines of your journal:

* The background should be white, not pale grey.
* The legend should be placed inside the plot, if there's room.
* No minor gridlines, and major gridlines should be a pale grey.
* The plot title should be 12pt bold text.

In this chapter, you'll learn how to use the theming system to make those changes, as shown below:

```{r theme-ex1a}
styled <- labelled +
  theme_bw() + 
  theme(
    plot.title = element_text(face = "bold", size = 12),
    legend.background = element_rect(fill = "white", size = 4, colour = "white"),
    legend.justification = c(0, 1),
    legend.position = c(0, 1),
    axis.ticks = element_line(colour = "grey70", size = 0.2),
    panel.grid.major = element_line(colour = "grey70", size = 0.2),
    panel.grid.minor = element_blank()
  )
styled
```

Finally, the journal wants the figure as a 600 dpi TIFF file. You'll learn the fine details of `ggsave()` in [saving your output](#sec:saving).

The theming system is composed of four main components:

* Theme _elements_ specify the non-data elements that you can control.
  For example, the `plot.title` element controls the appearance of the
  plot title; `axis.ticks.x`, the ticks on the x axis; `legend.key.height`,
  the height of the keys in the legend.

* Each element is associated with an _element function_, which describes 
  the visual properties of the element. For example, `element_text()` sets
  the font size, colour and face of text elements like `plot.title`.

* The `theme()` function which allows you to override the default theme
  elements by calling element functions, like 
  `theme(plot.title = element_text(colour = "red"))`.
  
* Complete _themes_, like `theme_grey()` set all of the theme elements to 
  values designed to work together harmoniously.

## Themes {#sec:themes}

ggplot2 comes with a number of built in themes. \index{Themes!built-in} The most important is `theme_grey()`, the signature ggplot2 theme with a light grey background and white gridlines. The theme is designed to put the data forward while supporting comparisons, following the advice of [@tufte:2006; @brewer:1994; @carr:2002; @carr:1994; @carr:1999]. We can still see the gridlines to aid in the judgement of position [@cleveland:1993a], but they have little visual impact and we can easily 'tune' them out. The grey background gives the plot a similar typographic  colour to the text, ensuring that the graphics fit in with the flow of a 
document without jumping out with a bright white background. Finally, the  grey background creates a continuous field of colour which ensures that the plot is perceived as a single visual entity. \indexf{theme_grey}
  
There are seven other themes built in to ggplot2 1.1.0:
  
* `theme_bw()`: a variation on `theme_grey()` that uses a white background
  and thin grey grid lines. 
  
* `theme_linedraw()`: A theme with only black lines of various widths on white 
  backgrounds, reminiscent of a line drawing.
  
* `theme_light()`: similar to `theme_linedraw()` but with light grey lines and 
  axes, to direct more attention towards the data.}

* `theme_dark()`: the dark cousin of `theme_light()`, with similar line sizes 
  but a dark background. Useful to make thin coloured lines pop out.
  
* `theme_minimal()`: A minimalistic theme with no background annotations.

* `theme_classic()`: A classic-looking theme, with x and y axis lines and no 
   gridlines.
   
* `theme_void()`: A completely empty theme. 

`r columns(3, 2/3)`
```{r}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()
base + theme_grey() + ggtitle("theme_grey()")
base + theme_bw() + ggtitle("theme_bw()")
base + theme_linedraw() + ggtitle("theme_linedraw()")
base + theme_light() + ggtitle("theme_bw()")
base + theme_dark() + ggtitle("theme_dark()")
base + theme_minimal()  + ggtitle("theme_minimal()")
base + theme_classic() + ggtitle("theme_classic()")
base + theme_void() + ggtitle("theme_void()")
```

All themes have a `base_size` parameter which controls the base font size. The base font size is the size that the axis titles use: the plot title is usually bigger (1.2x), and the tick and strip labels are smaller (0.8x). If you want to control these sizes separately, you'll need to modify the individual elements as described in the following section.

As well as applying themes a plot at-a-time, you can change the default theme with `theme_set()`. For example, if you really hate the default grey background, run `theme_set(theme_bw())` to use a white background for all plots. \indexf{theme_set}

You're not limited to the themes built-in to ggplot2. Other packages, like ggtheme by Jeffrey Arnold, add even more. Here's a few of my favourite from ggtheme:

```{r}
library(ggthemes)
base + theme_tufte() + ggtitle("theme_tufte()")
base + theme_solarized() + ggtitle("theme_solarized()")
base + theme_excel() + ggtitle("theme_excel()") # ;)
```

The complete themes are a great place to start but don't give you a lot of control. To modify individual elements, you need to use `theme()` to override the default setting for an element with an element function.

## Modifying theme components

Modifying an individual theme component looks like `plot + theme(element.name = element_function())`.  In this section you'll learn about the basic element functions, and then in the next section, you'll see all the elements that you can modify.

There are four basic types of built-in element functions: text, lines and segments, rectangles and blank. Each element function has a set of parameters that control the appearance as described below:

*   `element_text()` draws labels and headings. You can control the font 
    `family`, `face`, `colour`, `size` (in points), `hjust`, `vjust`, `angle` 
    (in degress) and `lineheight` (as ratio of `fontcase`). More details on 
    the parameters can be found in [specifications](#cha:specifications).
    \index{Themes!labels} \indexf{element_text}
  
    ```{r theme-text}
    base_t <- base + labs(title = "This is a ggplot")
    base_t + theme(plot.title = element_text(size = 20))
    base_t + theme(plot.title = element_text(face = "bold", colour = "red"))
    base_t + theme(plot.title = element_text(hjust = 0))
    ```
    
    You can control the margins around the text with the `margin` argument that
    should be fed the results of the `margin()` function. `margin()` has four 
    arguments: the amount of space (in points) to add to the top, right, bottom 
    and left sides of the text. Any elements not specified default to 0.

    ```{r theme-text-margin}
    # The margins here look asymmetric because there are also plot margins
    base_t + theme(plot.title = element_text(margin = margin()))
    base_t + theme(plot.title = element_text(margin = margin(t = 10, b = 10)))
    base_t + theme(axis.title.y = element_text(margin = margin(r = 10)))
    ```

*  `element_line()` draws lines parameterised by `colour`, `size` and
   `linetype`: \indexf{element_line}

    ```{r theme-line}
    base + theme(panel.grid.major = element_line(colour = "black"))
    base + theme(panel.grid.major = element_line(size = 2))
    base + theme(panel.grid.major = element_line(linetype = "dotted"))
    ```

* `element_rect()` draws rectangles, mostly used for backgrounds, parameterised
   by `fill` colour and border `colour`, `size` and `linetype`.  
   \index{Background} \index{Themes!background} \indexf{theme_rect}
  
    ```{r theme-background}
    base + theme(plot.background = element_rect(fill = "grey80", colour = NA))
    base + theme(plot.background = element_rect(colour = "red", size = 2))
    base + theme(panel.background = element_rect(fill = "linen"))
    ```

*   `element_blank()` draws nothing.  Use this element if you don't want 
    anything drawn, and no space allocated for that element.  The following
    example uses `element_blank()` to progressively suppress the appearance of 
    elements we're not interested in. Notice how the plot automatically reclaims 
    the space previously used by these elements: if you don't want this to 
    happen (perhaps because they need to line up with other plots on the page), 
    use `colour = NA, fill = NA` as parameter to create invisible elements that 
    still take up space. \indexf{element_blank}

    ```{r theme-blank}
    base
    last_plot() + theme(panel.grid.minor = element_blank())
    last_plot() + theme(panel.grid.major = element_blank())
    last_plot() + theme(panel.background = element_blank())
    last_plot() + theme(
      axis.title.x = element_blank(), 
      axis.title.y = element_blank()
    )
    last_plot() + theme(axis.line = element_line(colour = "grey50"))
    ```
    
A few other settings take grid units. Create them with `unit(1, "cm")` or `unit(0.25, "in")`.

To modify theme elements for all future plots, use `theme_update()`. It returns the previous theme settings, so you can easily restore the original parameters once you're done. \index{Themes!updating} \indexf{theme_get} \indexf{theme}

```{r theme-update}
old_theme <- theme_update(
  plot.background = element_rect(fill = "lightblue3", colour = NA),
  panel.background = element_rect(fill = "lightblue", colour = NA),
  axis.text = element_text(colour = "linen"),
  axis.title = element_text(colour = "linen")
)
base
theme_set(old_theme)
base
```

## Theme elements {#sec:theme-elements}

There are around 40 unique elements that control the appearance of the plot. They can be roughly grouped into five categories: \index{Themes!elements}

* plot attributes
* axis attributes
* legends attributes
* panel attributes
* facet attributes

I'll describe each category below with a few examples.

### Plot attributes

Some elements affect the plot as a whole:

Element               | Theme function   | Description
----------------------|------------------|------------
plot.background       | `element_rect()` | plot background
plot.title            | `element_text()` | plot title
plot.margin           | `margin()`       | margins around plot

`plot.background` modifies properties of the entire graphics region of a ggplot. By default it's set to white which ensures you can always read the text (even if you save and put on a black background). When exporting for inclusion in other systems, you might want to make it transparent (it won't look any different on screen). Similarly, if you're embedding a plot in a context which automatically gives it margins you might want to eliminate the built-in margins (a small margin is still necessary if you want to draw a border).

```{r plot-bkgrd-ex}
base + theme(plot.background = element_rect(colour = "grey50"))
base + theme(
  plot.background = element_rect(colour = "grey50"),
  plot.margin = margin(2, 2, 2, 2)
)
base + theme(plot.background = element_rect(fill = "lightblue"))
```

### Axis attributes

The table below lists each theme element associated with the rendering of axes, the theme function or unit function that controls it, and a short description of the element.

Element             | Setter            | Description               
--------------------|-------------------|---------------------------
axis.line           | `element_line()`  | line parallel to axis (not shown by default)
axis.text           | `element_text()`  | tick labels               
axis.text.x         | `element_text()`  | x-axis tick labels        
axis.text.y         | `element_text()`  | y-axis tick labels        
axis.title          | `element_text()`  | axis titles               
axis.title.x        | `element_text()`  | x-axis title              
axis.title.y        | `element_text()`  | y-axis title              
axis.ticks          | `element_line()`  | axis tick marks           
axis.ticks.length   | `unit()`          | length of tick marks      

Note that `axis.text` (and `axis.title`) comes in three forms: `axis.text`, `axis.text.x`, and `axis.text.y`. Use the first form if you want to modify the properties of both axes at once: any properties that you don't explicitly set in `axis.text.x` and `axis.text.y`  will be inherited from `axis.text`.

```{r theme-axis}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

# Accentuate the axes
base + theme(axis.line = element_line(colour = "grey50", size = 1))
# Style both x and y axis labels
base + theme(axis.text = element_text(color = "blue", size = 15))
# Useful for long labels
base + theme(axis.text.x = element_text(angle = -90, vjust = 0.5))
```

### Legend attributes

The following theme elements are associated with the appearance of legends:

Element             | Theme function            | Description                                 |
--------------------|---------------------------|---------------------------------------------|
legend.background   |  `element_rect()`         | legend background                           |
legend.key          |  `element_rect()`         | background of legend keys                   |
legend.key.size     |  `unit()`                 |                                             |
legend.key.height   |  `unit()`                 | legend key height                           |
legend.key.width    |  `unit()`                 | legend key width                            |
legend.margin       |  `unit()`                 | legend margin                               |
legend.text         |  `element_text()`         | legend labels                               |
legend.text.align   |  0--1                     | legend label alignment (0 = right, 1 = left)|
legend.title        |  `element_text()`         | legend name                                 |
legend.title.align  |  0--1                     | legend name alignment (0 = right, 1 = left) |

These options are illustrated below:

```{r theme-legend}
df <- data.frame(x = 1:4, y = 1:4, z = rep(c("a", "b"), each = 2))
base <- ggplot(df, aes(x, y, colour = z)) + geom_point()

base + theme(
  legend.background = element_rect(fill = "lemonchiffon", colour = "grey50", size = 1)
)
base + theme(
  legend.key = element_rect(color = "grey50"),
  legend.key.width = unit(0.9, "cm"),
  legend.key.height = unit(0.75, "cm")
)
base + theme(
  legend.text = element_text(size = 15),
  legend.title = element_text(size = 15, face = "bold")
)
```

There are four other properties that control how legends are laid out in the context of the plot (`legend.position`, `legend.direction`, `legend.justification`, `legend.box`). They are described in [legend layout](#sub:legend-layout).

### Panel attributes

Panel elements control the appearance of the plotting panels.

Element             | Theme function    | Description                                       |
--------------------|-------------------|---------------------------------------------------|
panel.background    | `element_rect()`  | background of graphics region (drawn beneath data)|  
panel.border        | `element_rect()`  | border of graphics region (drawn on top of data)  |
panel.grid.major    | `element_line()`  | major grid lines                                  |
panel.grid.major.x  | `element_line()`  | vertical major grid lines                         |
panel.grid.major.y  | `element_line()`  | horizontal major grid lines                       |
panel.grid.minor    | `element_line()`  | minor grid lines                                  |
panel.grid.minor.x  | `element_line()`  | vertical minor grid lines                         |
panel.grid.minor.y  | `element_line()`  | horizontal minor grid lines                       |
aspect.ratio        | numeric           | plot aspect ratio                                 |

```{r panel-bkgd-ex}
base <- ggplot(df, aes(x, y)) + geom_point()
# Modify background
base + theme(panel.background = element_rect(fill = "lightblue"))

# Tweak major grid lines
base + theme(panel.grid.major = element_line(color = "gray60", size = 0.8))
# Just in one direction  
base + theme(panel.grid.major.x = element_line(color = "gray60", size = 0.8))
```

The main difference is between `panel.background` and `panel.border` is that the background is drawn underneath the data, and the border is drawn on top of it. For that reason, you'll always need to assign `fill = NA` when overriding `panel.border`.

You can use the theming system to modify the aspect ratio of the panels. Here are a couple of examples:

```{r aspect-ratio-ex}
base2 <- base + theme(plot.background = element_rect(colour = "grey50"))
# Wide screen
base2 + theme(aspect.ratio = 9 / 16)
# Long and skiny
base2 + theme(aspect.ratio = 2 / 1)
# Square
base2 + theme(aspect.ratio = 1)
```

### Facetting attributes

The following theme elements are associated with panel strips in faceted ggplots:

Theme element       | Theme function   | Description                        |
--------------------|------------------|------------------------------------|
strip.background    | `element_rect()` | background of panel strips         |
strip.text          | `element_text()` | strip text                         |
strip.text.x        | `element_text()` | horizontal strip text              |
strip.text.y        | `element_text()` | vertical strip text                |
panel.margin        | `unit()`         | margin between facets              |
panel.margin.x      | `unit()`         | margin between facets (vertical)   |
panel.margin.y      | `unit()`         | margin between facets (horizontal) |

Element `strip.text.x` affects both `facet_wrap()` or `facet_grid()`; `strip.text.y` only affects `facet_grid()`.

```{r panel-margin-ex}
df <- data.frame(x = 1:4, y = 1:4, z = c("a", "a", "b", "b"))
base_f <- ggplot(df, aes(x, y)) + geom_point() + facet_wrap(~z)

base_f
base_f + theme(panel.margin = unit(0.5, "in"))
base_f + theme(
  strip.background = element_rect(fill = "grey20", color = "grey80", size = 1),
  strip.text = element_text(colour = "white")
)
```

### Exercises

1.  Create the ugliest plot possible! (Contributed by Andrew D. Steen, 
    University of Tennessee - Knoxville)

## Creating your own theme

If you want to create your complete theme, you need a few more details.


### Global settings

There are four elements that affect the global appearance of the plot.

Element      | Theme function    | Description
-------------|--------------------------------------------
line         | `element_line()`  | all line elements
rect         | `element_rect()`  | all rectangular elements
text         | `element_text()`  | all text
title        | `element_text()`  | all text in title elements (plot, axes & legend)

These set default properties that are inherited by more specific settings. These are most useful for setting an overall "background" colour and overall font settings (e.g. family and size).

`r columns(2, 1, 2/3)`
```{r axis-line-ex}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

base + theme(text = element_text(colour = "pink"))
```

It's also possible to use `rel()` to specify a relative size.

Inheritance

Complete vs. incomplete.

`%+replace%`

### Complete vs incomplete

It is useful to understand the difference between complete and incomplete theme objects. A *complete* theme object is one produced by calling a theme function with the attribute `complete = TRUE`. 

Theme functions `theme_grey()` and `theme_bw()` are examples of complete theme functions. Calls to `theme()` produce *incomplete* theme objects, since they represent (local) modifications to a theme object rather than returning a complete theme object per se. When adding an incomplete theme to a complete one, the result is a complete theme. 

Complete and incomplete themes behave somewhat differently when added to a ggplot object:

* Adding an incomplete theme augments the current theme object, replacing only 
  those properties of elements defined in the call to `theme()`. In particular, 
  any NULL element properties specified in `theme()`.
  
* Adding a complete theme wipes away the existing theme and applies. 

To deal with this problem, the concept of a complete theme (object) was introduced in the new theming system. In particular, `theme_grey` and `theme_bw` are both complete theme functions and return complete theme objects when called. When added to a plot, a complete theme object overrides the current default theme and in fact *replaces* it. This idea is implemented by endowing a theme function with the attribute `"complete"`: its value is `TRUE` for complete themes and `FALSE` for incomplete themes. Examples are shown in the next section.

### Modifying a theme function

There is a second type of inheritance in themes

```{r}
theme_grey()$legend.key

new_theme <- theme_grey() + theme(legend.key = element_rect(colour = "red"))
new_theme$legend.key

new_theme <- theme_grey() %+replace% theme(legend.key = element_rect(colour = "red"))
new_theme$legend.key
```

## Saving your output {#sec:saving}

You have two basic choices of output: raster or vector.  Vector graphics are procedural.  This means that they are essentially 'infinitely' zoomable; there is no loss of detail.  Raster graphics are stored as an array of pixels and have a fixed optimal viewing size.  Figure \ref{fig:vector-raster} illustrates the basic differences for a basic circle.  A good description is available at <http://tinyurl.com/rstrvctr>. \index{Saving} \index{Exporting} \index{Publication!saving output}

\begin{figure}[htbp]
  \centering
    \includegraphics[width= 0.5\linewidth]{diagrams/vector-raster}
  \caption{The schematic difference between raster (left) and vector (right) graphics. }
  \label{fig:vector-raster}
\end{figure}

Generally, vector output is more desirable, but for complex graphics containing thousands of graphical objects it can be slow to render.  In this case, it may be better to switch to raster output.  For printed use, a high-resolution (e.g., 600 dpi) graphic may be an acceptable compromise, but may be large. 

To save your output, you can use the typical R way with disk-based graphics devices, which works for all packages, or a special function from `ggplot` that saves the current plot: `ggsave()`. `ggsave()` is optimised for interactive use and has the following important arguments: \indexf{ggsave}

* The `path` specifies the path where the image should be saved. The file 
  extension will be used to automatically select the correct graphics device.

* Three arguments control output size.  If left blank, the size of the current 
  on-screen graphics device will be used. Otherwise, override with `width` and 
  `height` arguments. 
  
* For raster graphics, the `dpi` argument controls the resolution of the plot. 
  It defaults to 300, which is appropriate for most printers, but you may want 
  to use 600 for particularly high-resolution output, or 72 for on-screen 
  (e.g., web) display.

The following code shows these two methods. If you want to save multiple plots to a single file, you will need to explicitly open a disk-based graphics device (like `png()` or `pdf()`), print the plots and then close it with `dev.off()`.

```{r ggsave, eval = FALSE}
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggsave("output.pdf")

pdf("output.pdf", width = 6, height = 6)
# If inside a script, you will need to explicitly print() plots
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggplot(mpg, aes(displ, cty)) + geom_point()
dev.off()
```

Table~\ref{tbl:graphic-recommendation} lists recommended graphic formats for various tasks. R output generally works best as part of a linux development tool chain: using png or pdf output in LaTeX documents.  With Microsoft Office it is easiest to use a high-resolution (`dpi = 600`) png file.  You can use vector output, but neither Windows meta files nor postscript supports transparency, and while postscript prints fine, it's not displayed on screen (unless you add a preview image with another tool). Transparency is used to show confidence intervals with the points showing through. If you copy and paste a graph into Word, and see that the confidence interval bands have vanished, that is the cause. The same advice holds for OpenOffice. \index{Exporting!to Word} \index{Exporting!to Powerpoint}

If you are using LaTeX, I recommend including `\DeclareGraphicsExtensions{.png,.pdf}` in the preamble.  Then you don't need to specify the file extension in `\includegraphics{}` commands, but LaTeX will pick png files in preference to pdf. \index{Exporting!to Latex} I choose this order because you can produce all your files in pdf, and then go back and re-render any big ones as png.  Another useful command is `\graphicspath{}` which specifies a path in which to look for graphics, allowing you to keep graphics in a separate directory to the text.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Software & Recommended graphics device \\
    \midrule
    Illustrator & svg \\
    latex & ps \\
    MS Office & png (600 dpi) \\
    Open Office & png (600 dpi) \\
    pdflatex & pdf, png (600 dpi) \\
    web & png (72 dpi) \\
    \bottomrule 
  \end{tabular}
  \end{center}
  \caption{Recommended graphic output for different purposes.}
  \label{tbl:graphic-recommendation}
\end{table}
