---
output: bookdown::html_chapter
bibliography: references.bib
---

```{r polishing, include = FALSE}
source("common.R")
```

# Polishing your plots for publication {#cha:polishing}

In this chapter you will learn how to prepare polished plots for publication.  Most of this chapter focusses on the theming capability of ggplot which allows you to control many non-data aspects of plot appearances, but you'll also learn functions that make adding annotations easier and the best way to save plots for inclusion into other software packages. \index{Publication!polishing plots for}

Imagine you've made the following plot of your data.

`r columns(1, 2/3)`
```{r}
base <- ggplot(mpg, aes(cty, hwy, color = factor(cyl))) +
  geom_jitter() + 
  geom_abline(colour = "grey50", size = 2)
base
```

It's served it's purpose to you: you know now that `cty` and `hwy` are highly correlated, and that both are highly related to the number of cylinders. But now you want to share that plot with others by including it in a paper. That's going to necesitate some changes. First, we need:

* Need better labels for the axes and legend
* A better colour scale
* A plot title.

Fortunately you know how to do that already because you've read the scales chapter:

```{r}
labelled <- base +
  labs(
    x = "City mileage/gallon",
    y = "Highway mileage/gallon",
    colour = "Cylinders",
    title = "Highway vs. city mileage per gallon"
  ) +
  scale_colour_brewer(type = "seq", palette = "Spectral")
labelled
```

But know you need to learn about the themeing system so you can make it compatible with the journal style.

```{r theme-ex1a}
styled <- labelled +
  theme_bw() + 
  theme(
    axis.text = element_text(size = 14),
    plot.title = element_text(face = "bold"),
    legend.background = element_rect(fill = "white", size = 4, colour = "white"),
    legend.justification = c(0, 1),
    legend.position = c(0, 1),
    axis.ticks = element_line(colour = "grey70", size = 0.2),
    panel.grid.major = element_line(colour = "grey70", size = 0.2),
    panel.grid.minor = element_blank()
  )
styled
```

Finally, the journal wants the file as a 600 dpi TIFF file. [Saving your output](#sec:saving) discusses the chapter with a discussion about how to get your graphics out of R and into LaTeX, Word or other presentation or word-processing software.  

## Themes {#sec:themes}

The theming system in ggplot2 enables a user to control non-data elements of a ggplot object. It is composed of the following:

* theme _elements_, which refer to individual attributes of a graphic
  that are independent of the data, such as font size, axis ticks,
  appearance of grid lines or background color of a legend;

* theme _element functions_, which enables you to modify the settings
  of certain theme elements;

* theme _functions_, which define the settings of a collection of
  theme elements for the purpose of creating a specific style of
  graphics production;

* the `theme()` function, used to locally modify one or more theme
  elements in a specific ggplot object

The appearance of non-data elements of the plot is controlled by the theme system. The theme system does not affect how the data is rendered by geoms, or how it is transformed by scales. Themes don't change the perceptual properties of the plot, but they do help you make the plot aesthetically pleasing or match existing style guides. Themes give you control over things like the fonts in all parts of the plot: the title, axis labels, axis tick labels, strips, legend labels and legend key labels; and the colour of ticks, grid lines and backgrounds (panel, plot, strip and legend). \index{Themes} \index{Publication!themes}

This separation of control into data and non-data parts is quite different than base and lattice graphics.  In base and lattice graphics, most functions take a large number of arguments that specify both data and non-data appearance, which makes the functions complicated and hard to learn. ggplot2 takes a different approach: when creating the plot you determine how the data is displayed, then *after* it has been created you can edit every detail of the rendering, using the theming system. 

ggplot2 comes with a number of built in themes: \index{Themes!built-in}

* `theme_grey()`: the signature ggplot2 theme with a light grey background and 
  white gridlines, designed to put the data forward yet make comparisons easy.
  This follows from the advice of [@tufte:2006; @tufte:1990; @tufte:2001; 
  @tufte:1997] and [@brewer:1994; @carr:2002; @carr:1994; @carr:1999]. We can 
  still see the gridlines to aid in the judgement of position 
  [@cleveland:1993a], but they have little visual impact and we can easily 
  'tune' them out. The grey background gives the plot a similar typographic 
  colour to the text, ensuring that the graphics fit in with the flow of a 
  document without jumping out with a bright white background. Finally, the 
  grey background creates a continuous field of colour which ensures that the 
  plot is perceived as a single visual entity. \indexf{theme_grey}
  
* `theme_bw()`: the classic dark-on-light ggplot2 theme. May work better for 
  presentations displayed with a projector.
  
* `theme_linedraw()`: A theme with only black lines of various widths on white 
  backgrounds, reminiscent of a line drawing.
  
* `theme_light()`: similar to `theme_linedraw()` but with light grey lines and 
  axes, to direct more attention towards the data.}

* `theme_dark()`: the dark cousin of `theme_light()`, with similar line sizes 
  but a dark background. Useful to make thin coloured lines pop out.
  
* `theme_minimal()`: A minimalistic theme with no background annotations.

* `theme_classic()`: A classic-looking theme, with x and y axis lines and no 
   gridlines.
   
* `theme_void()`: A completely empty theme. 

`r columns(3, 2/3)`
```{r}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()
base + theme_grey() + ggtitle("theme_grey()")
base + theme_bw() + ggtitle("theme_bw()")
base + theme_linedraw() + ggtitle("theme_linedraw()")
base + theme_light() + ggtitle("theme_bw()")
base + theme_dark() + ggtitle("theme_dark()")
base + theme_minimal()  + ggtitle("theme_minimal()")
base + theme_classic() + ggtitle("theme_classic()")
base + theme_void() + ggtitle("theme_void()")
```

All themes have a `base_size` parameter which controls the base font size. The base font size is the size that the axis titles use: the plot title is usually bigger, and the tick and strip labels are smaller. If you want to control these sizes separately, you'll need to modify the individual elements as described in the following section.

You're not limited to just built-in themes. Other packages, like ggtheme, add even more. Here's a selection:

```{r}
library(ggthemes)
base + theme_tufte() + ggtitle("theme_tufte()")
base + theme_solarized() + ggtitle("theme_solarized()")
base + theme_excel() + ggtitle("theme_excel()") # ;)
```

As well as using a complete theme, you can modifying each component individually. The theme system comes with a number of built-in element rendering functions with a limited set of parameters. By adjusting these parameters you can control things like text size and colour, background and grid line colours and text orientation, as you'll see in the following section.

## Theme elements

A theme is made up of multiple __elements__ which control the appearance of a single item on the plot. There are around 40 unique elements, than can roughly grouped into five categories: \index{Themes!elements}


* global settings
* axis
* legends
* strips
* panels 
* plot region

Each element is either:

* a unit
* an element function
* text

I'll describe the types of elements with a few examples, and then work through the different categories.

The default theme function `theme_grey()` contains 38 individual theme elements. The first three of these are `line`, `rect` and `text`, whose default properties are defined through their respective theme element functions `element_line()`, `element_rect()` and `element_text()`. The remaining theme elements can be grouped into:

### Theme elements {#sec:theme-elements}

There are four basic types of built-in element functions: text, lines and segments, rectangles and blank.  Each element function has a set of parameters that control the appearance as described below:

*   `element_text()` draws labels and headings. You can control the font 
    `family`, `face`, `colour`, `size`, `hjust`, `vjust`, `angle` and 
    `lineheight`. \index{Themes!labels} \indexf{element_text}
  
    ```{r theme-text}
    base_t <- base + labs(title = "This is a ggplot")
    base_t + theme(plot.title = element_text(size = 20))
    base_t + theme(plot.title = element_text(face = "bold", colour = "red"))
    base_t + theme(plot.title = element_text(hjust = 0))
    ```

*  `element_line()` draws lines parameterised by `colour`, `size` and
   `linetype`: \indexf{element_line}

    ```{r theme-line}
    base + theme(panel.grid.major = element_line(colour = "black"))
    base + theme(panel.grid.major = element_line(size = 2))
    base + theme(panel.grid.major = element_line(linetype = "dotted"))
    ```

* `element_rect()` draws rectangles, mostly used for backgrounds, parameterised
   by `fill` colour and border `colour`, `size` and `linetype`.  
   \index{Background} \index{Themes!background} \indexf{theme_rect}
  
    ```{r theme-background}
    base + theme(plot.background = element_rect(fill = "grey80", colour = NA))
    base + theme(plot.background = element_rect(colour = "red", size = 2))
    base + theme(panel.background = element_rect(fill = "linen"))
    ```

*   `element_blank()` draws nothing.  Use this element if you don't want 
    anything drawn, and no space allocated for that element.  The following
    example uses `element_blank()` to progressively suppress the appearance of 
    elements we're not interested in. Notice how the plot automatically reclaims 
    the space previously used by these elements: if you don't want this to 
    happen (perhaps because they need to line up with other plots on the page), 
    use `colour = NA, fill = NA` as parameter to create invisible elements that 
    still take up space. \indexf{element_blank}

    ```{r theme-blank}
    base
    last_plot() + theme(panel.grid.minor = element_blank())
    last_plot() + theme(panel.grid.major = element_blank())
    last_plot() + theme(panel.background = element_blank())
    last_plot() + theme(
      axis.title.x = element_blank(), 
      axis.title.y = element_blank()
    )
    last_plot() + theme(axis.line = element_line(colour = "grey50"))
    ```
    
Other settings take "units". Create them with `unit(1, "cm")` or `unit(0.25, "in")`.

### Plot attributes

Finally, some elements affect the plot as a whole:

Element               | Theme function   | Description
----------------------|------------------|------------
plot.background       | `element_rect()` | background of entire plot
plot.title            | `element_text()` | plot title
plot.margin           | `unit()` * 4     | 4-elemnt vector of margins around plot

Element `plot.margin` is a four-element vector associated with the margins to be placed outside the graphics region going clockwise from the top (top-right-bottom-left, margin order is troubling).

The theme element `plot.background` modifies properties of the entire graphics region of a ggplot. By default it's set to white which ensures you can always read the text (even if you save and put on a black background). When exporting for inclusion in other systems, you might want to set it to transparent (it won't look any different on screen). Similarly you might want to eliminate the built-in margin if you're embedding a system with margins.

```{r plot-bkgrd-ex}
base + theme(plot.background = element_rect(colour = "grey50"))
base + theme(
  plot.background = element_rect(colour = "grey50"),
  plot.margin = grid::unit(c(0, 0, 0, 0), "cm")
)
base + theme(plot.background = element_rect(fill = "lightblue"))
```

### Axis attributes

The table below lists each theme element associated with the rendering of axes, the theme function or unit function that controls it, and a short description of the element.

Element             | Setter            | Description               |
--------------------|-------------------|---------------------------|
axis.line           | `element_line()`  | line parallel to axis     |
axis.text           | `element_text()`  | tick labels               |
axis.text.x         | `element_text()`  | x-axis tick labels        |
axis.text.y         | `element_text()`  | y-axis tick labels        |
axis.title          | `element_text()`  | axis titles               |
axis.title.x        | `element_text()`  | x-axis title              |
axis.title.y        | `element_text()`  | y-axis title              |
axis.ticks          | `element_line()`  | axis tick marks           |
axis.ticks.length   | `unit()`          | length of tick marks      |
axis.ticks.margin   | `unit()`          | width of axis tick margin |

Our first example shows how to modify axis lines. The first call below changes each of the available properties in the `axis.line` theme element so that the changes propagate to both `axis.line.x` and `axis.line.y`, taking advantage of inheritance. The plot on the left therefore has axis lines with long dashes of thickness 2 in red in both the `x` and `y` directions.

The second call uses inheritance somewhat differently. The attributes changed in `axis.line` propagate to both `axis.line.x` and `axis.line.y`. However, in the second line of code corresponding to `axis.line.y`,  the specified color and linetype override the values inherited from `axis.line`. As a result, in the right hand plot, `axis.line.x` will be a solid blue line with thickness 2 while `axis.line.y` will be a dashed orange line with the same thickness.

```{r theme-axis}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

# Accentuate the axes
base + theme(
  axis.line = element_line(colour = "grey50", size = 1)
)
# Style both x and y axis labels
base + theme(
  axis.text = element_text(color = "blue", size = 15)
)
# Useful for long labels
base + theme(
  axis.text.x = element_text(angle = -90, vjust = 0.5)
)
```

### Legend attributes

The following theme elements are associated with the appearance of legends:

Element             | Theme function            | Description                                 |
--------------------|---------------------------|---------------------------------------------|
legend.background   |  `element_rect()`         | legend background                           |
legend.key          |  `element_rect()`         | background of legend keys                   |
legend.key.size     |  `unit()`                 |                                             |
legend.key.height   |  `unit()`                 | legend key height                           |
legend.key.width    |  `unit()`                 | legend key width                            |
legend.margin       |  `unit()`                 | legend margin                               |
legend.text         |  `element_text()`         | legend labels                               |
legend.text.align   |  0--1                     | legend label alignment (0 = right, 1 = left)|
legend.title        |  `element_text()`         | legend name                                 |
legend.title.align  |  0--1                     | legend name alignment (0 = right, 1 = left) |

These options are illustrated below:

```{r theme-legend}
df <- data.frame(x = 1:4, y = 1:4, z = rep(c("a", "b"), each = 2))
base <- ggplot(df, aes(x, y, colour = z)) + geom_point()

base + theme(
  legend.background = element_rect(fill = "lemonchiffon", colour = "grey50", size = 1)
)
base + theme(
  legend.key = element_rect(color = "grey50"),
  legend.key.width = grid::unit(0.9, "cm"),
  legend.key.height = grid::unit(0.75, "cm")
)
base + theme(
  legend.text = element_text(size = 15),
  legend.title = element_text(size = 15, face = "bold")
)
```

There are four other properties that control how legends are laid out in the context of the plot (`legend.position`, `legend.direction`, `legend.justification`, `legend.box`). They are described in [legend layout](#sub:legend-layout).

### Panel attributes

Panel elements control the appearance of the plotting panels.

Element             | Theme function    | Description                                       |
--------------------|-------------------|---------------------------------------------------|
panel.background    | `element_rect()`  | background of graphics region (drawn beneath data)|  
panel.border        | `element_rect()`  | border of graphics region (drawn on top of data)  |
panel.grid.major    | `element_line()`  | major grid lines                                  |
panel.grid.major.x  | `element_line()`  | vertical major grid lines                         |
panel.grid.major.y  | `element_line()`  | horizontal major grid lines                       |
panel.grid.minor    | `element_line()`  | minor grid lines                                  |
panel.grid.minor.x  | `element_line()`  | vertical minor grid lines                         |
panel.grid.minor.y  | `element_line()`  | horizontal minor grid lines                       |
aspect.ratio        | numeric           | plot aspect ratio                                 |

```{r panel-bkgd-ex}
base <- ggplot(df, aes(x, y)) + geom_point()
# Modify background
base + theme(panel.background = element_rect(fill = "lightblue"))

# Tweak major grid lines
base + theme(panel.grid.major = element_line(color = "gray60", size = 0.8))
# Just in one direction  
base + theme(panel.grid.major.x = element_line(color = "gray60", size = 0.8))
```

The main difference is between `panel.background` and `panel.border` is that the background is drawn underneath the data, and the border is drawn on top of it. For that reason, you'll always need to assign `fill = NA` when overriding `panel.border`.

You can use the theming system to modify the aspect ratio of the panels. Here are a couple of examples:

```{r aspect-ratio-ex}
base2 <- base + theme(plot.background = element_rect(colour = "grey50"))
# Wide screen
base2 + theme(aspect.ratio = 9 / 16)
# Long and skiny
base2 + theme(aspect.ratio = 2 / 1)
# Square
base2 + theme(aspect.ratio = 1)
```

### Facetting attributes

The following theme elements are associated with panel strips in faceted ggplots:

Theme element       | Theme function   | Description                        |
--------------------|------------------|------------------------------------|
strip.background    | `element_rect()` | background of panel strips         |
strip.text          | `element_text()` | strip text                         |
strip.text.x        | `element_text()` | horizontal strip text              |
strip.text.y        | `element_text()` | vertical strip text                |
panel.margin        | `unit()`         | margin between facets              |
panel.margin.x      | `unit()`         | margin between facets (vertical)   |
panel.margin.y      | `unit()`         | margin between facets (horizontal) |

Element `strip.text.x` affects both `facet_wrap()` or `facet_grid()`; `strip.text.y` only affects `facet_grid()`.

```{r panel-margin-ex}
df <- data.frame(x = 1:4, y = 1:4, z = c("a", "a", "b", "b"))
base_f <- ggplot(df, aes(x, y)) + geom_point() + facet_wrap(~z)

base_f
base_f + theme(panel.margin = grid::unit(0.5, "in"))
base_f + theme(
  strip.background = element_rect(fill = "grey20", color = "grey80", size = 1),
  strip.text = element_text(colour = "white")
)
```

### Setting globally

As well as applying themes to each plot individually, you can also set them globally with `theme_set()`.  `theme_set()` returns the previous theme so that you can restore it later if you want. \indexf{theme_set}

You can modify the elements locally for a single plot with `theme()` (as seen above), or globally for all future plots with `theme_update()`. \index{Themes!updating} \indexf{theme_get} \indexf{theme}

```{r theme-update}
old_theme <- theme_update(
  plot.background = element_rect(fill = "lightblue3", colour = NA),
  panel.background = element_rect(fill = "lightblue", colour = NA),
  axis.text = element_text(colour = "linen"),
  axis.title = element_text(colour = "linen")
)
base
theme_set(old_theme)
base
```

### Exercises

1.  Create the ugliest plot possible! (Contributed by Andrew D. Steen, 
    University of Tennessee - Knoxville)

## Creating your own theme

If you want to create your complete theme, you need a few more details.


### Global settings

There are four elements that affect the global appearance of the plot.

Element      | Theme function    | Description
-------------|--------------------------------------------
line         | `element_line()`  | all line elements
rect         | `element_rect()`  | all rectangular elements
text         | `element_text()`  | all text
title        | `element_text()`  | all text in title elements (plot, axes & legend)

These set default properties that are inherited by more specific settings. These are most useful for setting an overall "background" colour and overall font settings (e.g. family and size).

`r columns(2, 1, 2/3)`
```{r axis-line-ex}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point()

base + theme(text = element_text(colour = "pink"))
```

It's also possible to use `rel()` to specify a relative size.

Inheritance

Complete vs. incomplete.

`%+replace%`

### Complete vs incomplete

It is useful to understand the difference between complete and incomplete theme objects. A *complete* theme object is one produced by calling a theme function with the attribute `complete = TRUE`. 

Theme functions `theme_grey()` and `theme_bw()` are examples of complete theme functions. Calls to `theme()` produce *incomplete* theme objects, since they represent (local) modifications to a theme object rather than returning a complete theme object per se. When adding an incomplete theme to a complete one, the result is a complete theme. 

Complete and incomplete themes behave somewhat differently when added to a ggplot object:

* Adding an incomplete theme augments the current theme object, replacing only 
  those properties of elements defined in the call to `theme()`. In particular, 
  any NULL element properties specified in `theme()`.
  
* Adding a complete theme wipes away the existing theme and applies. 

To deal with this problem, the concept of a complete theme (object) was introduced in the new theming system. In particular, `theme_grey` and `theme_bw` are both complete theme functions and return complete theme objects when called. When added to a plot, a complete theme object overrides the current default theme and in fact *replaces* it. This idea is implemented by endowing a theme function with the attribute `"complete"`: its value is `TRUE` for complete themes and `FALSE` for incomplete themes. Examples are shown in the next section.

### Modifying a theme function

There is a second type of inheritance in themes

```{r}
theme_grey()$legend.key

new_theme <- theme_grey() + theme(legend.key = element_rect(colour = "red"))
new_theme$legend.key

new_theme <- theme_grey() %+replace% theme(legend.key = element_rect(colour = "red"))
new_theme$legend.key
```

## Saving your output {#sec:saving}

You have two basic choices of output: raster or vector.  Vector graphics are procedural.  This means that they are essentially 'infinitely' zoomable; there is no loss of detail.  Raster graphics are stored as an array of pixels and have a fixed optimal viewing size.  Figure \ref{fig:vector-raster} illustrates the basic differences for a basic circle.  A good description is available at <http://tinyurl.com/rstrvctr>. \index{Saving} \index{Exporting} \index{Publication!saving output}

\begin{figure}[htbp]
  \centering
    \includegraphics[width= 0.5\linewidth]{diagrams/vector-raster}
  \caption{The schematic difference between raster (left) and vector (right) graphics. }
  \label{fig:vector-raster}
\end{figure}

Generally, vector output is more desirable, but for complex graphics containing thousands of graphical objects it can be slow to render.  In this case, it may be better to switch to raster output.  For printed use, a high-resolution (e.g., 600 dpi) graphic may be an acceptable compromise, but may be large. 

To save your output, you can use the typical R way with disk-based graphics devices, which works for all packages, or a special function from `ggplot` that saves the current plot: `ggsave()`. `ggsave()` is optimised for interactive use and has the following important arguments: \indexf{ggsave}

* The `path` specifies the path where the image should be saved. The file 
  extension will be used to automatically select the correct graphics device.

* Three arguments control output size.  If left blank, the size of the current 
  on-screen graphics device will be used. Otherwise, override with `width` and 
  `height` arguments. 
  
* For raster graphics, the `dpi` argument controls the resolution of the plot. 
  It defaults to 300, which is appropriate for most printers, but you may want 
  to use 600 for particularly high-resolution output, or 72 for on-screen 
  (e.g., web) display.

The following code shows these two methods. If you want to save multiple plots to a single file, you will need to explicitly open a disk-based graphics device (like `png()` or `pdf()`), print the plots and then close it with `dev.off()`.

```{r ggsave, eval = FALSE}
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggsave("output.pdf")

pdf("output.pdf", width = 6, height = 6)
# If inside a script, you will need to explicitly print() plots
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggplot(mpg, aes(displ, cty)) + geom_point()
dev.off()
```

Table~\ref{tbl:graphic-recommendation} lists recommended graphic formats for various tasks. R output generally works best as part of a linux development tool chain: using png or pdf output in LaTeX documents.  With Microsoft Office it is easiest to use a high-resolution (`dpi = 600`) png file.  You can use vector output, but neither Windows meta files nor postscript supports transparency, and while postscript prints fine, it's not displayed on screen (unless you add a preview image with another tool). Transparency is used to show confidence intervals with the points showing through. If you copy and paste a graph into Word, and see that the confidence interval bands have vanished, that is the cause. The same advice holds for OpenOffice. \index{Exporting!to Word} \index{Exporting!to Powerpoint}

If you are using LaTeX, I recommend including `\DeclareGraphicsExtensions{.png,.pdf}` in the preamble.  Then you don't need to specify the file extension in `\includegraphics{}` commands, but LaTeX will pick png files in preference to pdf. \index{Exporting!to Latex} I choose this order because you can produce all your files in pdf, and then go back and re-render any big ones as png.  Another useful command is `\graphicspath{}` which specifies a path in which to look for graphics, allowing you to keep graphics in a separate directory to the text.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Software & Recommended graphics device \\
    \midrule
    Illustrator & svg \\
    latex & ps \\
    MS Office & png (600 dpi) \\
    Open Office & png (600 dpi) \\
    pdflatex & pdf, png (600 dpi) \\
    web & png (72 dpi) \\
    \bottomrule 
  \end{tabular}
  \end{center}
  \caption{Recommended graphic output for different purposes.}
  \label{tbl:graphic-recommendation}
\end{table}

<!--
## Multiple plots on the same page {#sec:grid-layout}

If you want to arrange multiple plots on a single page, you'll need to learn a little bit of grid, the underlying graphics system used by ggplot. The key concept you'll need to learn about is a viewport: a rectangular subregion of the display. The default viewport takes up the entire plotting region, and by customising the viewport you can arrange a set of plots in just about any way you can imagine. \index{Layout} \index{Publication!multiple plots on the same page}

To begin, let's create three plots that we can experiment with. When arranging multiple plots on a page, it will usually be easiest to create them, assign them to variables and then plot them. This makes it easier to experiment with plot placement independent of content. The plots created by the code below are shown in Figure \ref{fig:layout}.

`r columns(3)`
```{r layout}
a <- ggplot(economics, aes(date, unemploy)) + geom_line()
b <- ggplot(economics, aes(uempmed, unemploy)) + geom_point() + geom_smooth(se = FALSE) 
c <- ggplot(economics, aes(uempmed, unemploy)) + geom_point()
a
b
c
```

### Subplots

One common layout is to have a small subplot drawn on top of the main plot.  To achieve this effect, we first plot the main plot, and then draw the subplot in a smaller viewport.  Viewports are created with (surprise!) the `viewport()` function, with parameters `x`, `y`, `width` and `height` to control the size and position of the viewport. By default, the measurements are given in 'npc' units, which range from 0 to 1. The location (0, 0) is the bottom left, (1, 1) the top right and (0.5, 0.5) the centre of viewport.  If these relative units don't work for your needs, you can also use absolute units, like `unit(2, "cm")` or `unit(1, "inch")`. \index{Sub-figures} \index{Subplots}

```{r viewports}
library(grid)
# A viewport that takes up the entire plot device
vp1 <- viewport(width = 1, height = 1, x = 0.5, y = 0.5)
vp1 <- viewport()

# A viewport that takes up half the width and half the height, 
# located in the middle of the plot.
vp2 <- viewport(width = 0.5, height = 0.5, x = 0.5, y = 0.5)
vp2 <- viewport(width = 0.5, height = 0.5)

# A viewport that is 2cm x 3cm located in the center
vp3 <- viewport(width = unit(2, "cm"), height = unit(3, "cm"))
```

By default, the x and y parameters control the location of the centre of the viewport. When positioning the plot in other locations, you may need to use the `just` parameter to control which corner of the plot you are positioning.  The following code gives some examples.

```{r viewport2}
# A viewport in the top right
vp4 <- viewport(x = 1, y = 1, just = c("right", "top"))
# Bottom left
vp5 <- viewport(x = 0, y = 0, just = c("right", "bottom"))
```

To draw the plot in our new viewport, we use the `vp` argument of the `print()` method.  This method is normally called automatically whenever you evaluate something on the command line, but because we want to customise the viewport, we need to call it ourselves. The result of this is shown in Figure \ref{fig:subplot-1}.

```{r polish, results='hide'}
pdf("figures/polishing-subplot-1.pdf", width = 4, height = 4)
subvp <- viewport(width = 0.4, height = 0.4, x = 0.75, y = 0.35)
b
print(c, vp = subvp)
dev.off()
```

This gives us what we want, but we need to make a few tweaks to the appearance: the text should be smaller, we want to remove the axis labels and shrink the plot margins. The result is shown in Figure \ref{fig:subplot-2}.

```{r polish2, results='hide'}
csmall <- c + 
  theme_gray(9) + 
  labs(x = NULL, y = NULL) + 
  theme(plot.margin = unit(c(1/4, 0, 0, 0), "lines"))

pdf("figures/polishing-subplot-2.pdf", width = 4, height = 4)
b
print(csmall, vp = subvp)
dev.off()
```

\begin{figure}[htbp]
  \centering
  \subfigure[Figure with subplot.]{
    \includegraphics[width=0.5\textwidth]{figures/polishing-subplot-1}
    \label{fig:subplot-1}
  }%
  \subfigure[Subplot tweaked for better display.]{
    \includegraphics[width=0.5\textwidth]{figures/polishing-subplot-2}
    \label{fig:subplot-2}
  }
  \caption{Two examples of a figure with subplot. It will usually be necessary to tweak the theme settings of the subplot for optimum display.}
  \label{fig:subplot}
\end{figure}

Note we need to use `pdf()` (or `png()` etc.) to save the plots to disk because `ggsave()` only saves a single plot.

### Rectangular grids

A more complicated scenario is when you want to arrange a number of plots in a rectangular grid. Of course you could create a series of viewports and use what you've learned above, but doing all the calculations by hand is cumbersome. A better approach is to use `grid.layout()`, which sets up a regular grid of viewports with arbitrary heights and widths. You still need to create each viewport, but instead of explicitly specifying the position and size, you can specify the row and column of the layout.

The following example shows how this work.  We first create the layout, here a 2 by 2 grid, then assign it to a viewport and push that viewport on to the plotting device.  Now we are ready to draw each plot into its own position on the grid.  We create a small function to save some typing, and then draw each plot in the desired place on the grid.  You can supply a vector of rows or columns to span a plot over multiple cells.  The results are shown in Figure \ref{fig:layout-2}.

`r columns(1)`
```{r layout-2}
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))

vplayout <- function(x, y) 
  viewport(layout.pos.row = x, layout.pos.col = y)
print(a, vp = vplayout(1, 1:2))
print(b, vp = vplayout(2, 1))
print(c, vp = vplayout(2, 2))
```

By default `grid.layout()` makes each cell the same size, but you can use the `widths` and `heights` arguments to make them different sizes.  See the documentation for `grid.layout()` for more examples.
-->