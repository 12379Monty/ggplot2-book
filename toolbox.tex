\input{_header.tex}

\chapter{Toolbox}
\label{cha:toolbox}

\section{Introduction}\label{sec:introduction}

A typical graphic has three layers:

\begin{itemize}
  \item The {\bf data}.  This layer appears on every graphic and 

  \item A statistical {\bf summary}.  For the purposes of communication and inference, any conclusions we make about the data will typically be summarised and supported by a quantitative model.  Displaying the predictions from this model in the context of the data is useful to both summarise the data, and to detect potential problems with the model.  This is normally the top layer.

  \item {\bf Context}.  The context for the data shouldn't interfere with the perception of the data, so it should normally be on the bottom layer and formatted so that it is minimally perceptible.  That is, if you concentrate on it, you can see it with ease, but it doesn't jump out at you when you are casually browsing the plot.
  
  For spatial data, the context will often be a map.  For temporal data, it might be significant events outside the data.  Context can also include labelling unusual points.
\end{itemize}


This chapter describes how to use the various 

The examples in this section use a mixture of {\tt ggplot()} and {\tt qplot()} calls, reflecting real life.  If you need a reminder on how to translate between the two, see Section~\ref{sec:qplot-ggplot}.

\begin{itemize}
  \item Basic plot types
  \item Displaying distributions
  \item Dealing with overplotting
  \item Surface plots
  \item Revealing uncertainty
  \item Annotating a plot
  \item Weighted data
\end{itemize}

\section{Basics}\label{sub:basics}

These geoms are the basic geoms used to build up almost all of the other geoms.  These are useful for creating basic graphics, and when building your own geom function (see section \ref{sec:writing_your_own}).

\begin{itemize}
  \item {\tt geom\_point}: points
  \item {\tt geom\_line}, {\tt geom\_path}: paths and lines.  Lines are paths that have their x-axis values ordered in increasing value.
  \item {\tt geom\_polygon}: polygons
  \item {\tt geom\_bar}: bars
  \item {\tt geom\_text}: text
  \item {\tt geom\_tile}: tiles, rectangles which form a regular tessellation of the plane
\end{itemize}

\section{Displaying distributions}\label{sec:distributions}

There are quite a few geoms associated with displaying distributions:

\begin{itemize}
	\item {\tt geom\_boxplot}: box and whisker plot, for a continuous variable possibly conditioned by a categorical variable
	\item {\tt geom\_jitter}: a crude way of investigating densities
	\item {\tt geom\_quantile}: quantiles, for a continuous variable conditional on another continuous variable.
	\item {\tt geom\_density}: 
	\item {\tt geom\_histogram}: 
	\item {\tt geom\_2ddensity}: for displaying the density of points on the plot surface.
\end{itemize}

% (Ask Heike about this)
% 
% We have a number of plots available to investigate distributions, depending on the number of variables, and whether we are interested in the conditional or joint distribution.
% 
% \begin{Verbatim}
%   
% Single variable
% + cont: histogram, density plot, boxplot
% + cat:  barchart
% 
% Two variables: conditional
% + cat  | cat:  mosaic plot
% + cat  | cont: ?
% + cont | cont: quantiles
% + cat  | cont: boxplot
% 
% Two variables: joint
% + cat  * cat:  fluctuation diagram
% + cat  * cont: boxplots?
% + cont * cont: bagplot, geom\_2ddensity
% \end{Verbatim}

Jittered points can be used for any joint distribution (or conditional if one or both variables are categorical)

\section{Dealing with overplotting}\label{sec:overplotting}

The simplest way to deal with overplotting is to bin the plot into small squares and count the number of points that lies in each square, much like a 2D histogram.  This count can then be visualised as the third variable on a plot.  However, breaking the plot into many small squares produces distracting visual artefacts.  Carr (reference) suggests using hexagons instead, and this is implemented with {\tt geom\_hexagon}, using the capabilities of the {\tt hexbin package}.

A continuous analogue of this is to compute a 2D density function and then visualise this as coloured tiles or contour lines.  This can be done with {\tt geom\_2ddensity}.

Another approach to dealing with overplotting is to add supplemental information to help guide the eye to the true shape of or pattern within the data:

\begin{itemize}
	\item {\tt geom\_smooth} add a smooth line showing the mean.
	\item {\tt geom\_quantile} add a smooth line showing any quantile you are interested in.
\end{itemize}

\section{Surface plots}

\ggplot currently does not support true 3D plots.  However, it does offer two tools for producing pseudo-3d plots, the imageplot and the contour plot.

\begin{itemize}
	\item {\tt geom\_tile}: map z variable to fill colour
	\item {\tt geom\_contour}: useful for smoother surfaces
	\item {\tt geom\_point}: can map abs(z) variable to size and sign(z) to colour
\end{itemize}

These are often better than ``true'' 3d for static plots anyway, because many perceptual cues necessary for accurate depth perception (eg. occlusion, parallax) are not present in static plots.  You can also manually project data points in a higher dimensional space by multiplying by a projection matrix.  However, correctly representing occlusion or generating correct perspective effects will require considerably more effort.  You may want to look at RGL (\url{http://www.rgl.com}) and rggobi (\url{http://www.ggobi.org/ggobi}) for other solutions.

\section{Statistical summaries}
\label{sec:statistical_summaries}

\code{stat_smooth}, \code{stat_quantile}.  \code{stat_summary}

\section{Revealing uncertainty}\label{sub:displaying_uncertainty}

General class of geoms for displaying not points, but intervals.  

If you have information about the uncertainty present in your data, possibly from a model or distributional assumptions, it is often useful to visualise.  There are two geoms that allow you to do this depending on whether you have point or functional confidence intervals:

\begin{itemize}
	\item {\tt geom\_errorbar}: for pointwise confidence intervals
	\item \code{geom_linerange}, \code{geom_pointrange}, \code{geom_crossbar}
	\item {\tt geom\_ribbon}: ribbons of variable width, useful for displaying confidence intervals around functions, \code{geom_smooth}
	\item \code{geom_point} with size aesthetic.  Mapping size to uncertainty may be ok, but will make most uncertain points have the most visual impact
\end{itemize}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    X variable & Range & Range plus centre \\
    \midrule
    Continuous & \code{geom_ribbon} & \code{geom_area} \\
    Discrete   & \code{geom_errorbar}, \code{geom_pointrange} & \code{geom_linerange}, \code{geom_crossbar} \\
    \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{caption}
  \label{label}
\end{table}

There are two ways to display standard errors with {\tt ggplot}.  For point standard errors, you can use the {\tt errorbar} geom.  For continuous or functional standard errors, you can use the {\tt ribbon} grob.  We've have already seen an example of this: the {\tt ribbon} grob is used inside {\tt smooth} to display the standard errors of the smooth.  Because there are so many different ways to calculate standard errors, the calculation is up to you.  {\tt ggplot} only provides facilities for displaying them once you have them.

For both {\tt ribbon} and {\tt errorbar} you can specify confidence internals using {\tt min} and {\tt max} which specify the upper and lower edges of the confidence band.

Assume y conditioned on x.  Have additional position parameters, min and max, which determine the 

\code{coord_flip}

Calculating with {\tt stat\_sum}, {\tt stat\_smooth} etc.

\section{Lines}
\label{sec:lines}

\begin{itemize}
  \item \code{geom_line}
  \item \code{geom_path}
  \item \code{geom_segment}
  \item \code{geom_step}
\end{itemize}

\begin{itemize}
  \item \code{geom_smooth}
  \item \code{stat_sum}
\end{itemize}

% section lines (end)

\section{Annotating a plot}\label{sub:annotating_a_plot}

Any of the basic geoms can be used to annotate a plot with additional output, for example, adding text with {\tt geom\_text}, or a point illustrating the mean with {\tt geom\_point}.  Additionally, there are several geoms whose use is almost entirely for annotation.  These are:

\begin{itemize}
	\item {\tt geom\_vline}, {\tt geom\_hline}: add vertical or horizontal lines to a plot
	\item {\tt geom\_abline}: add lines with arbitrary slope and intercept to a plot
\end{itemize}

See also Section~\ref{sec:adding_annotation} for ways to add more general types of annotation using grid graphics.

\section{Weighted data}\label{sec:weighted_data}

% The {\tt weight} aesthetic is also useful when you have weighted data.  All ggplot2 statistics know how to correctly deal with (WHAT TYPE OF WEIGHTS?) weights, which makes plotting your weighted data easy.  For a more comprehensive description of plotting weights, see ``Weight and see''.

When you have aggregated data where each row in the dataset represents multiple observations, you need some way to take into account the weighting variable.  Since there are no variables appropriate for weighting in the diamonds data, we will use some data collected on Midwest states in the 2000 US census.  The data consists mainly of percentages (eg. percent white, percent below poverty line, percentage with college degree) and some information for each county (area, total population, population density).

There are few different things we might want to weight by: 

\begin{itemize}
	\item nothing, to look at county numbers
	\item total population, to work with absolute numbers
	\item area, to investigate geographic effects
\end{itemize}

\noindent The choice of a weighting variable profoundly effects what we are looking at in the plot and the conclusions that we will draw.  There are two aesthetic attributes that can be used to adjust for weights.  Firstly, for simple geoms like lines and points, you can make the size of the grob proportional to the number of points, using the {\tt size} aesthetic, as follows:

% decumar<<< 
% interweave({
% midwest <- read.csv("~/Documents/graphics/weighted/midwest.csv")
% qplot(percwhite, percbelowpoverty, data=midwest)
% qplot(percwhite, percbelowpoverty, data=midwest, size=poptotal)
% qplot(percwhite, percbelowpoverty, data=midwest, size=area)
% })
% |||
\begin{alltt}
> midwest <- read.csv("~/Documents/graphics/weighted/midwest.csv")
> qplot(percwhite, percbelowpoverty, data = midwest)
\includegraphics[scale=0.5]{4b8c600efdc1f31f77c7c3368cac11d2}

> qplot(percwhite, percbelowpoverty, data = midwest, size = poptotal)
\includegraphics[scale=0.5]{f3976daae1f4a7ef912ea259ca3dd8f5}

> qplot(percwhite, percbelowpoverty, data = midwest, size = area)
\includegraphics[scale=0.5]{440b95f469e5b96a08e077d4a177e603}

\end{alltt}
% >>>

For more complicated grobs which involve some statistical transformation, we specify weights with the {\tt weight} aesthetic.  These weights will be passed on to the statistical summary function.  Weights are supported for every case where it makes sense: smoothers, quantile regressions, box plots, histograms, and density plots.  You can't see this weighting variable directly, and it doesn't produce a legend, but it will change the results of the statistical summary.

The following example shows how weighting by population density effects the relationship between percent white and percent below the poverty line.

% decumar<<< 
% interweave({
% qplot(percwhite, percbelowpoverty, data=midwest, geom=c("point","smooth"), method=lm)
% qplot(percwhite, percbelowpoverty, data=midwest, size=popdensity, weight=popdensity,geom=c("point","smooth"), method=lm)
% })
% |||
\begin{alltt}
> qplot(percwhite, percbelowpoverty, data = midwest, geom = c("point", 
+     "smooth"), method = lm)
\includegraphics[scale=0.5]{54d5b5a95badb06ff2339bfd51826af0}

> qplot(percwhite, percbelowpoverty, data = midwest, size = popdensity, 
+     weight = popdensity, geom = c("point", "smooth"), method = lm)
\includegraphics[scale=0.5]{3353081c3ffa3fd62b69fb2c0aef9142}

\end{alltt}
% >>>

When we weight a histogram or density plot by total population, we change from looking at the distribution of the number of counties, to the distribution of the number of people.  This example shows the difference this makes for a histogram and density plot of the percentage below the poverty line.

% decumar<<< 
% interweave({
% qplot(percbelowpoverty, data=midwest, geom="histogram", binwidth=1)
% qplot(percbelowpoverty, data=midwest, geom="histogram", weight=poptotal, binwidth=1)
% })
% |||
\begin{alltt}
> qplot(percbelowpoverty, data = midwest, geom = "histogram", binwidth = 1)
\includegraphics[scale=0.5]{d8cef4ee59175bda59eaa2647a64b930}

> qplot(percbelowpoverty, data = midwest, geom = "histogram", weight = poptotal, 
+     binwidth = 1)
\includegraphics[scale=0.5]{affb33e87c76bc94bd3ea9eb2df0190c}

\end{alltt}
% >>>

\input{_footer.tex}
