\input{_header.tex}

% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.5\textwidth
%   INLINE: FALSE
%   CACHE: TRUE
% 

% END

\chapter{Toolbox}
\label{cha:toolbox}

\section{Introduction}

The use of layers in \ggplot, introduced in the preceding chapter, encourages you to design and construct graphics in a structured manner.  You have learned what a layer is and how to add one to your graphic, but not what geoms and statistics are available to help you build revealing plots.  This chapter lists the many geoms and stats included in \ggplot, broken down by their purpose.  The main purpose of this chapter is to provide a good overview of the available options: it does not describe each geom and stat in detail.  For more information about individual geoms, along with many more examples showing how you can use it, see the online and electronic documentation.

To illustrate the geoms a wide range of datasets is used.  You have seen each of them before, but the list below should refresh your memory about the major features of each dataset.  Remember you can find out more details with the online documentation.

\begin{itemize}
  \item The diamonds data contains 50,000 round cut diamonds
\end{itemize}

This chapter is broken up into the following sections, each of which deals with a particular graphical challenge.  This is not an exhaustive or exclusive categorisation, and there are many other possible ways to break up graphics into different categories.  Many geoms can be used for many different purposes, especially if you are creative.  However, 

\begin{itemize}
  \item Basic plot types, \secref{sec:basics}, to produce common, ``named'' graphics.
  
  \item Displaying distributions, \secref{sec:distributions}, whether continuous or discrete, 1d or 2d, joint or conditional, with histograms, density plots, boxplots and other creative combinations.
  
  \item Dealing with overplotting, \secref{sec:overplotting} is a challenge for large data.

  \item Surface plots, \secref{sec:surface}, display 3d surfaces in 2d, with imageplots, contours and other variations.

  \item Statistical summaries, \secref{sec:summary}.

  \item Revealing uncertainty and showing intervals, \secref{sec:uncertainty}.

  \item Connecting related observations, \secref{sec:connecting}.

  \item Annotating a plot, \secref{sec:annotating}.

  \item Weighted data, \secref{sec:weighting}.
\end{itemize}

The examples in this section use a mixture of {\tt ggplot()} and {\tt qplot()} calls, reflecting real life use.  If you need a reminder on how to translate between the two, see Appendix~\ref{sec:qplot-ggplot}.  The examples do not go into much depth, but hopefully if you flick through this chapter, you'll be able to see a plot that looks like the one you're trying to create.

\section{Overall strategy}
\label{sec:strategy}

Touch on strategies for creating a graphic

It is useful to think about the purpose of each layer before it is added.  

In general, there are three purposes for a layer:

\begin{itemize}
  \item To display the {\bf data}.  We plot the raw data for many reasons, relying on our skills at pattern detection to spot gross structure, local structure, and outliers.  This layer appears on virtually every graphic.  In the earliest stages of data exploration, it is often the only layer.

  \item To display a statistical {\bf summary} of the data. As we develop and explore models, it is useful to display the predictions from each model in the context of the data. We learn from the data summaries and we evaluate the model. A summary layer is often a part of a presentation graphic, plots produced to communicate conclusions to others. This layer is normally drawn on top of the data.

  If you review the examples in the preceding chapter, you'll see many examples of plots of data with an added layer displaying a statistical summary.

  \item To add additional {\bf metadata}, context and annotations. A metadata layer displays background context or annotations that help to give meaning to the raw data. 
  
  A map is often used as a background layer with spatial data. Background data should be rendered so that it doesn't interfere with the perception of the data, so it should normally be on the bottom layer and formatted so that it is minimally perceptible. That is, if you concentrate on it, you can see it with ease, but it doesn't jump out at you when you are casually browsing the plot.

  Some metadata, on the other hand, is intended to highlight important features of the data. If you have added explanatory labels to a couple of inflection points or outliers, then you want to render them so that they pop out at the viewer. In that case, you want this to be the very last layer drawn.

\end{itemize}


\section{Basic plot types}\label{sec:basics}

These geoms are the basic geoms used to build up many of the other geoms.  Most of these geoms are associated with a named plot: when that geom is used by itself in a plot, that plot has a special name.  These geoms are illustrated in Figure~\ref{fig:geom-basic} and described below.

Each of these geoms is two dimensional and requires both \code{x} and \code{y} aesthetics.  All understand \code{colour} and \code{size} aesthetics, and the filled geoms also understand \code{fill}.  The point geom uses \code{shape} and line and path geoms understand \code{linetype}. The geoms are used for displaying data, summaries computed elsewhere, and metadata.

\begin{itemize}
  \item \code{geom_area} draws an area plot, which is a line plot filled to the y-axis (filled lines).  Multiple groups will be stacked on top of each other.
  
  \item \code{geom_bar(stat = "identity")} makes a barchart.  By default, the bar geom automatically counts values (so is essentially a 1d geom, see \secref{sec:distributions}), so to make it use y values instead of counts, we have to specify the identity stat.  By default, multiple groups will be stacked.
  
  \item \code{geom_line} makes a line plot.  The \code{group} aesthetic determine which observations are connected, see Section~\ref{sub:grouping} for more details. \code{geom_path} is similar to a \code{geom_line}, but lines are connected in the order they appear in the data, not from left to right.  
  
  \item \code{geom_point} produces a scatterplot.
  
  \item \code{geom_polygon} draws polygons, which are filled paths.
  
  \item \code{geom_text} adds labels at the specified points.  This is the only geom in this group that requires another aesthetic: \code{label}.  It also has optional aesthetics \code{hjust} and \code{vjust} that control the horizontal and vertical position of the text; and \code{angle} which controls the rotation of the text.
  
  \item \code{geom_tile} makes a image plot or level plot.  The tiles form a regular tessellation of the plane and are typically have fill aesthetic mapped to another variable.

\end{itemize}

% FIGURE
%   LABEL: geom-basic
%   CAPTION: The basic geoms applied to the same data.  Many give rise to 
%   to named plots (from top-left to bottom-right): scatterplot, barchart,
%   line chart, area chart, path plot, labelled scatterplot, image/level 
%   plot and polygon plot.  Observe the different axis ranges for the 
%   bar, area and image plots: these geoms take up space outside the 
%   range of the data, so push the axes out.
%   GG-WIDTH: 3  GG-HEIGHT: 3 COL: 4
%   TEX-WIDTH: 0.25\textwidth
% 
% df <- data.frame(x = c(3, 1, 5), y = c(2, 4, 6), label = c("a","b","c"))
% p <- ggplot(df, aes(x, y, label = label)) + scale_x_continuous("") + scale_y_continuous("")
% p + geom_point() + opts(title = "geom_point")
% p + geom_bar(stat="identity") + opts(title = "geom_bar(stat=\"identity\")")
% p + geom_line() + opts(title = "geom_line")
% p + geom_area() + opts(title = "geom_area")
% p + geom_path() + opts(title = "geom_path")
% p + geom_text() + opts(title = "geom_text")
% p + geom_tile() + opts(title = "geom_tile")
% p + geom_polygon() + opts(title = "geom_polygon")
\input{_include/72b362ec03da30c5f1525e8fabc4acec.tex}
% END

% Pie charts.

\section{Displaying distributions}\label{sec:distributions}

There are a number of geoms can be used to display distributions, depending on the dimensionality of the distribution, whether it is continuous or discrete, and whether you are interested in conditional or joint distributions.

For 1d continuous distributions the important geom is the histogram.  Figure~\ref{geom-1d-con} uses the histogram to display the distribution of diamond \var{depth}.  It is important to customise the parameters to find a revealing view.  If you are interested in the distribution of a continuous variable conditioned on a discrete variable, there are a few things that you can try: you could create small multiples of the histogram, \code{facets = . ~ var} with facetting; use a frequency polygon, {\tt geom = "freqpoly"}; or create a conditional density plot, {\tt position = "fill"}.  For the first two options, it may be desirable to use {\tt y = ..density..} to focus on the relative shape of the distributions, rather than there size. 

% FIGURE
%   LABEL: geom-1d-con
%   CAPTION: \Leftc, never rely on the default parameters to get a revealing
%   view of the distribution.  \Rightc, zooming in on the x axis and selecting
%   a smaller bin width reveal far more detail, {\tt xlim = c(55, 70), 
%   binwidth = 0.1}.
% 
% qplot(depth, data=diamonds, geom="histogram")
% qplot(depth, data=diamonds, geom="histogram", xlim=c(55, 70), binwidth=0.1)
\input{_include/fd641be1ab194a5da74118ae078e5fcd.tex}
% END

% INTERWEAVE
%   GG-WIDTH: 8 GG-HEIGHT: 3
%   TEX-WIDTH: \textwidth
% 
% qplot(depth, ..density.., data = diamonds, geom = "histogram", 
%   xlim = c(58, 68), binwidth = 0.1, facets = cut ~ ., fill = cut)
% qplot(depth, data = diamonds, geom = "histogram", 
%   xlim = c(58, 68), binwidth = 0.1, fill = cut, position = "fill", 
%   colour = I(NA))
% qplot(depth, ..density.., data = diamonds, geom = "freqpoly", 
%   xlim = c(58, 68), binwidth = 0.1, colour = cut)
\input{_include/9a0806a954a34acb7e4069b092f53620.tex}
% END

Many of the distribution related geoms come in geom/stat pairs.  Most of these geoms are aliases: a basic geom is combined with a stat to produce the desired plot.  The boxplot may appear to be an exception to this rule, but behind the scenes \code{geom_boxplot} uses a combination of the basic bars, lines and points.

\begin{itemize}
  \item \code{geom_boxplot} = \code{stat_boxplot} + \code{geom_boxplot}: box and whisker plot, for a continuous variable conditioned by a categorical variable.  This is a useful display when the categorical variable has many distinct values, but for a few values, the techniques described above give a better view of the shape of the distribution.
  
  % FIGURE
  %   LABEL: geom-boxplot
  %   CAPTION: The boxplot geom can be use to see the distribution of a 
  %   continuous variable conditional on a, \leftc discrete varable, or
  %   right continuous variable.  If the number of boxplots is small, 
  %   faceted histograms will reveal finer details of the distribution.
  % 
  % qplot(cut, depth, data=diamonds, geom="boxplot")
  % qplot(carat, depth, data=diamonds, geom="boxplot", group=round_any(carat, 0.1), xlim=c(0, 3))
 \input{_include/34c8833767028b4076b92a24f4a670c7.tex} 
 % END
  
  \item \code{geom_jitter} = \code{position_jitter} + \code{geom_point}: a crude way of looking at discrete distributions.
  
  % FIGURE
  %   LABEL: geom-jitter
  %   COL: 1 GG-WIDTH: 8 TEX-WIDTH: 0.8 \textwidth
  %   CAPTION: The jitter geom can give a crude visualisation of 2d 
  %   distributions with a discrete component.  Generally this works better
  %   for smaller datasets.  Car class vs \leftc, city mpg (continuous) and
  %   \rightc drive train (discrete).
  % 
  % qplot(class, cty, data=mpg, geom="jitter")
  % qplot(class, drv, data=mpg, geom="jitter")
 \input{_include/6a89c9c887ff67774a6909454f7a6eb7.tex} 
 % END
  
  \item \code{geom_quantile} = \code{stat_quantile} + \code{geom_line}: quantiles, for a continuous variable conditional on another continuous variable.  This is a continuous analogue of the boxplot. 
  
  % FIGURE
  %   LABEL: geom-quantile
  %   CAPTION: The boxplot geom can be use to see the distribution of a 
  %   continuous variable conditional on a, \leftc discrete varable, or
  %   right continuous variable.  If the number of boxplots is small, 
  %   faceted histograms will reveal finer details of the distribution.
  % 
  % qplot(carat, depth, data=diamonds, geom="quantile", 
  %   xlim=c(0, 3), quantiles = c(0.05, 0.25, 0.5, 0.75, 0.95))
  % qplot(carat, depth, data=diamonds, geom="quantile", xlim=c(0, 3), formula = y ~ factor(round_any(x, 0.5)))
 \input{_include/229fd1a992d3df297f57c502168ff41e.tex} 
 % END
  
  \item \code{geom_density} = \code{stat_density} + \code{geom_area}: a smoothed density.  Also described in Section~\ref{sub:distribution}.  Don't use a density plot unless you know that the underlying density is continuous and unbounded, otherwise you'll get some strange artefacts. You can use the \code{adjust} parameter to make the density more or less smooth.
  
  % FIGURE
  %   LABEL: geom-density
  %   CAPTION: The density plot is a smoothed version of the histogram.  
  %   It has desirable theoretical properties, but is more difficult to 
  %   relate directly back to the data.  \Leftc a density plot of depth, 
  %   and \rightc facetted by cut.
  % 
  % qplot(depth, data=diamonds, geom="density", xlim = c(54, 70))
  % qplot(depth, data=diamonds, geom="density", xlim = c(54, 70), 
  %   fill = cut) + scale_fill_hue(alpha = 0.2)
 \input{_include/88afb2e9d029c2f8373e6975fa0792f1.tex} 
 % END

  \item \code{geom_histogram} = \code{stat_bin} + \code{geom_bar}.  When you use a histogram, make sure to experiment with various bin widths.  Remember to try very small bin widths, right down to the resolution of the data.  
  
  \item \code{geom_freqpoly} = \code{stat_bin} + \code{geom_line}.  
\end{itemize}

\code{stat_qq} can be used to compare two distributions.  A plot matrix with qq plots can be used to see all pairwise comparisons of variable distributions in a dataset.

Recommendations:   

% (Ask Heike about this)
% 
% We have a number of plots available to investigate distributions, depending on the number of variables, and whether we are interested in the conditional or joint distribution.
% 
% \begin{Verbatim}
%   
% Single variable
% + cont: histogram, density plot, boxplot
% + cat:  barchart
% 
% Two variables: conditional
% + cat  | cat:  mosaic plot
% + cat  | cont: ?
% + cont | cont: quantiles
% + cat  | cont: boxplot
% 
% Two variables: joint
% + cat  * cat:  fluctuation diagram
% + cat  * cont: boxplots?
% + cont * cont: bagplot, geom\_2ddensity
% \end{Verbatim}

\section{Dealing with overplotting}
\label{sec:overplotting}

The simplest way to deal with overplotting is to bin the plot into small squares and count the number of points that lies in each square, much like a 2D histogram.  This count can then be visualised as the third variable on a plot.  However, breaking the plot into many small squares produces distracting visual artefacts.  Carr \citep{carr:1987} suggests using hexagons instead, and this is implemented with \code{geom_hexagon}, using the capabilities of the {\tt hexbin package}.

A continuous analogue of this is to compute a 2D density function and then visualise this as coloured tiles or contour lines.  This can be done with \code{geom_2ddensity}.

Another approach to dealing with overplotting is to add supplemental information to help guide the eye to the true shape of or pattern within the data:

\begin{itemize}
  \item \code{geom_smooth} add a smooth line showing the mean.
  \item \code{geom_quantile} add a smooth line showing any quantile you are interested in.
\end{itemize}

\section{Surface plots}
\label{sec:surface}

\ggplot currently does not support true 3D plots.  However, it does offer two tools for producing pseudo-3d plots, the image/level plot and the contour plot.  

\begin{itemize}
  \item \code{geom_tile}: map z variable to fill colour
  \item \code{geom_contour}: useful for smoother surfaces
  \item \code{geom_point}: can map abs(z) variable to size and sign(z) to colour
\end{itemize}

These are often better than ``true'' 3d for static plots anyway, because many perceptual cues necessary for accurate depth perception (eg. occlusion, parallax, motion) are not present in static plots.  You can also manually project data points in a higher dimensional space by multiplying by a projection matrix.  However, correctly representing occlusion or generating correct perspective effects will require considerably more effort.  You may want to look at RGL (\url{http://www.rgl.com}) and rggobi (\url{http://www.ggobi.org/ggobi}) for other solutions.

\section{Statistical summaries}
\label{sec:summary}

\begin{itemize}
  \item \code{stat_smooth}
  \item \code{stat_quantile}
  \item \code{stat_summary}
\end{itemize}

Doing it yourself.

\section{Revealing uncertainty}
\label{sec:uncertainty}

General class of geoms for displaying not points, but intervals.  

If you have information about the uncertainty present in your data, possibly from a model or distributional assumptions, it is often useful to visualise.  There are two geoms that allow you to do this depending on whether you have point or functional confidence intervals:

\begin{itemize}
  \item \code{geom_errorbar}: for pointwise confidence intervals
  \item \code{geom_linerange}, \code{geom_pointrange}, \code{geom_crossbar}
  \item \code{geom_ribbon}: ribbons of variable width, useful for displaying confidence intervals around functions, \code{geom_smooth}
  \item \code{geom_point} with size aesthetic.  Mapping size to uncertainty may be ok, but will make most uncertain points have the most visual impact
\end{itemize}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    X variable & Range & Range plus centre \\
    \midrule
    Continuous & \code{geom_ribbon} & \code{geom_area} \\
    Discrete   & \code{geom_errorbar}, \code{geom_pointrange} & \code{geom_linerange}, \code{geom_crossbar} \\
    \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{caption}
  \label{label}
\end{table}

There are two ways to display standard errors with {\tt ggplot}.  For point standard errors, you can use the {\tt errorbar} geom.  For continuous or functional standard errors, you can use the {\tt ribbon} grob.  We've have already seen an example of this: the {\tt ribbon} grob is used inside {\tt smooth} to display the standard errors of the smooth.  Because there are so many different ways to calculate standard errors, the calculation is up to you.  {\tt ggplot} only provides facilities for displaying them once you have them.

For both {\tt ribbon} and {\tt errorbar} you can specify confidence internals using {\tt min} and {\tt max} which specify the upper and lower edges of the confidence band.

Assume y conditioned on x.  Have additional position parameters, min and max, which determine the 

\code{coord_flip}

Calculating with {\tt stat\_sum}, {\tt stat\_smooth} etc.

\section{Connecting related observations}
\label{sec:connecting}

\begin{itemize}
  \item \code{geom_line}
  \item \code{geom_path}
  \item \code{geom_segment}
\end{itemize}

\begin{itemize}
  \item \code{geom_smooth}
  \item \code{stat_sum}
\end{itemize}

% section lines (end)

\section{Annotating a plot}
\label{sec:annotating}

Any of the basic geoms can be used to annotate a plot with additional output, for example, adding text with \code{geom_text}, or a point illustrating the mean with \code{geom_point}.  Additionally, there are several geoms whose use is almost entirely for annotation.  These are:

\begin{itemize}
  \item \code{geom_vline}, \code{geom_hline}: add vertical or horizontal lines to a plot
  \item \code{geom_abline}: add lines with arbitrary slope and intercept to a plot
  \item \code{geom_rect}
\end{itemize}

See also Section~\ref{sec:adding_annotation} for ways to add more general types of annotation using grid graphics.

Most plots will not benefit from adding text to every single observation on the plot.  However, pulling out just a few observations (using subset) can be very useful.  Typically you will want to label outliers.

% qplot(vore, sleep_cycle, data=msleep)


\section{Weighted data}
\label{sec:weighting}

% The {\tt weight} aesthetic is also useful when you have weighted data.  All ggplot2 statistics know how to correctly deal with (WHAT TYPE OF WEIGHTS?) weights, which makes plotting your weighted data easy.  For a more comprehensive description of plotting weights, see ``Weight and see''.

When you have aggregated data where each row in the dataset represents multiple observations, you need some way to take into account the weighting variable.  Since there are no variables appropriate for weighting in the diamonds data, we will use some data collected on Midwest states in the 2000 US census.  The data consists mainly of percentages (eg. percent white, percent below poverty line, percentage with college degree) and some information for each county (area, total population, population density).

There are few different things we might want to weight by: 

\begin{itemize}
  \item nothing, to look at county numbers
  \item total population, to work with absolute numbers
  \item area, to investigate geographic effects
\end{itemize}

\noindent The choice of a weighting variable profoundly effects what we are looking at in the plot and the conclusions that we will draw.  There are two aesthetic attributes that can be used to adjust for weights.  Firstly, for simple geoms like lines and points, you can make the size of the grob proportional to the number of points, using the {\tt size} aesthetic, as follows:

% INTERWEAVE
%
% midwest <- read.csv("~/Documents/weight-and-see/midwest.csv")
% qplot(percwhite, percbelowpoverty, data=midwest)
% qplot(percwhite, percbelowpoverty, data=midwest, size=poptotal) + scale_area()
% qplot(percwhite, percbelowpoverty, data=midwest, size=area) + scale_area()
\input{_include/86e903c5b5dca9079a484eb761f989ee.tex}
% END

For more complicated grobs which involve some statistical transformation, we specify weights with the {\tt weight} aesthetic.  These weights will be passed on to the statistical summary function.  Weights are supported for every case where it makes sense: smoothers, quantile regressions, box plots, histograms, and density plots.  You can't see this weighting variable directly, and it doesn't produce a legend, but it will change the results of the statistical summary.  Figure~\ref{weight-lm} shows how weighting by population density effects the relationship between percent white and percent below the poverty line.

% FIGURE
%   LABEL: weight-lm
%   CAPTION: \leftc A line of best fit unweighted by population size, and 
%   \rightc weighted by population size.
%
% lm_smooth <- geom_smooth(method = lm, size = 1)
% qplot(percwhite, percbelowpoverty, data = midwest) + lm_smooth 
% qplot(percwhite, percbelowpoverty, data = midwest, 
%   weight = popdensity, size = popdensity) + lm_smooth
\input{_include/68ba7c2c8207e89861d999ccb0d383d1.tex}
% END

When we weight a histogram or density plot by total population, we change from looking at the distribution of the number of counties, to the distribution of the number of people.  Figure~\ref{fig:weight-hist} shows the difference this makes for a histogram of the percentage below the poverty line.

% FIGURE
%   LABEL: weight-hist
%   CAPTION: The different between an \leftc unweighted and \rightc weighted
%   histogram.  The unweighted histogram shows number of counties, while the
%   weighted histogram shows population
%
% qplot(percbelowpoverty, data=midwest, geom="histogram", binwidth=1)
% qplot(percbelowpoverty, data=midwest, geom="histogram", weight=poptotal, binwidth=1) + scale_y_continuous("population")
\input{_include/297bc0527a32d14d7a5cf98848e0a10e.tex}
% END

\input{_footer.tex}
