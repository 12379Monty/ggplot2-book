---
output: bookdown::html_chapter
bibliography: references.bib
---

```{r duplication, include = FALSE}
source("common.r")
```

# Programming with ggplot2 {#cha:duplication}

## Introduction

A major requirement of a good data analysis is flexibility. If the data changes, or you discover something that makes you rethink your basic assumptions, you need to be able to easily change many plots at once. The main inhibitor of flexibility is duplication. If you have the same plotting statement repeated over and over again, you have to make the same change in many different places. Often just the thought of making all those changes is exhausting!

To make your code more flexible, you need to reduce duplication by writing functions. When you notice you're doing the same thing over and over again, think about how you might generalise it and turn it into a function. If you're not that familiar with how functions work in R, you might want to brush up your knowledge at <http://adv-r.had.co.nz/Functions.html>.

In this chapter I'll show four basic techniques for reducing the duplication in your plotting code:

* Function with single component
* Function with multiple components
* Creating a whole plot
* Functional programming

You might also find the [cowplot](https://github.com/wilkelab/cowplot) and [ggthemes](https://github.com/jrnold/ggthemes) packages helpful. As well as providing reuable components that might help you directly, you can also read the source code of the packages to figure out how they work.

## Single components

Each component of a ggplot plot (layer, scale, coord, facet & theme) is its own object. Most of the time you create the object and immediately add it to a plot. However, you can save any component to a variable (giving it a name), and then apply it to multiple plots:

`r columns(2, 1, 0.75)`
```{r layer9}
bestfit <- geom_smooth(
  method = "lm", 
  se = FALSE, 
  colour = alpha("steelblue", 0.5), 
  size = 2
)
ggplot(mpg, aes(cty, hwy)) + 
  geom_point() + 
  bestfit
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  bestfit
```

That's a great way to reduce simple types of duplication (it's much better than copying-and-pasting!), but requires that the component be exactly the same every time.  If you need more flexibility, you can wrap these resuable snippets in a function. For example, we could extend our `bestfit` object to a more general function for adding lines of best fit to a plot. The following code creates `geom_lm()` which has three parameters: the model `formula`, the line `colour` and the line `size`:

```{r geom-lm}
geom_lm <- function(formula = y ~ x, colour = alpha("steelblue", 0.5), 
                    size = 2, ...)  {
  geom_smooth(formula = formula, se = FALSE, method = "lm", colour = colour,
    size = size, ...)
}
ggplot(mpg, aes(displ, 1 / hwy)) + 
  geom_point() + 
  geom_lm()
ggplot(mpg, aes(displ, 1 / hwy)) + 
  geom_point() + 
  geom_lm(y ~ poly(x, 2), size = 1, colour = "red")
```

Note the use of `...`. In the function definition `...` allows a function to accept aribtrary extra functions. You then use `...` within the function to pass those arguments on to another function. It's a good idea to always use `...` in your component functions so that you can control all parameters of the geom. Here it allows the user to pass on any additional arguments (like `data`, `linetype`) to the underlying geom. 

### Exercises

1.  Create an object that represents a pink histogram with 100 bins.

1.  Create an object that represents a fill scale with the Blues 
    ColorBrewer palette.

1.  Read the source code for `theme_grey()`?  What are its arguments? 
    How does it work?

1.  Create `scale_colour_wesanderson()`. It should have a parameter to pick 
    the palette from the wesanderson package, and create either a continuous
    or discrete scale.

## Multiple components

It's not alway possible to achieve your goals with a single component, so ggplot2 supports a convenient way of adding multiple components to a plot in one step: with a list. The following function adds a layer showing the mean of `y` and a layer showing its standard error:

`r columns(2, 2/3, 0.75)`
```{r geom-mean-1}
geom_mean <- function() {
  list(
    stat_summary(fun.y = "mean", geom = "bar", fill = "grey70"),
    stat_summary(fun.data = "mean_cl_normal", geom = "errorbar", width = 0.4)
  )
}
ggplot(mpg, aes(class, cty)) + geom_mean()
ggplot(mpg, aes(drv, cty)) + geom_mean()
```

If the list contains any `NULL` elements, they're ignored. This makes it easy to conditionally add components:

```{r geom-mean-2}
geom_mean <- function(se = TRUE) {
  list(
    stat_summary(fun.y = "mean", geom = "bar", fill = "grey70"),
    if (se) 
      stat_summary(fun.data = "mean_cl_normal", geom = "errorbar", width = 0.4)
  )
}
ggplot(mpg, aes(class, cty)) + geom_mean()
ggplot(mpg, aes(class, cty)) + geom_mean(se = FALSE)
```

You're not just limited to geoms and stats, you can also put scales, coords and facetting specifications in that list.

### Annotation

It's often useful to add standard annotations to a plot. In this case, your function will also set the data in the layer function, rather than inheriting it from the plot defaults. When you do this, there are two other options that you should set to make the layer self-contained:

* `inherit.aes = FALSE`: this ensures that your layer doesn't inherit an 
  aesthetics from the parent plot. This will ensure your annotation works
  regardless of what else is on the plot.
  
* `show.legend = FALSE`: this ensures that your annotation won't appear in the
  legend.
  
One example of this technique is the `borders()` function built into ggplot2.  It's designed to add map borders from one of the dataset in the maps package:

```{r}
borders <- function(database = "world", regions = ".", fill = NA, 
                    colour = "grey50", ...) {
  df <- map_data(database, regions)
  geom_polygon(
    aes_(~lat, ~long, group = ~group), 
    data = df, fill = fill, colour = colour, ..., 
    inherit.aes = FALSE, show.legend = FALSE
  )
}
```

### Passing along arguments

`...` is no longer so useful if your function returns multiple components because there's no way to direct different arguments to different layers. Instead, you'll need to think about exactly how you want your function to work, balancing the benefits of having one function that does it all vs. the cost of having a complex function that's harder to understand. 

Here's one approach using `modifyList()` and `do.call()`:

```{r}
geom_mean <- function(..., bar.params = list(), errorbar.params = list()) {
  params <- list(...)
  bar.params <- modifyList(params, bar.params)
  errorbar.params  <- modifyList(params, errorbar.params)
  
  bar <- do.call("stat_summary", modifyList(
    list(fun.y = "mean", geom = "bar", fill = "grey70"),
    bar.params)
  )
  errorbar <- do.call("stat_summary", modifyList(
    list(fun.data = "mean_cl_normal", geom = "errorbar", width = 0.4),
    errorbar.params)
  )

  list(bar, errorbar)
}

ggplot(mpg, aes(class, cty)) + 
  geom_mean(
    colour = "steelblue",
    errorbar.params = list(width = 0.5, size = 1)
  )
ggplot(mpg, aes(class, cty)) + 
  geom_mean(
    bar.params = list(fill = "steelblue"),
    errorbar.params = list(colour = "blue")
  )
```

If you need more complex behaviour, it might be easier to create a custom geom or stat. You can learn about that in the extending ggplot2 vignette included with the package. Read it by running `vignette("extending", package = "ggplot2")`.

### Exercises

1.  To make the best use of space, many examples in this book turn off 
    the axes labels and the legend. I've just copied-and-pasted the same code 
    into multiple place, but it would make more sense to create a resuable 
    function. What would that function look like?

1.  Extend the `borders()` function to also add `coord_quickmap()` to the
    plot.

1.  Look through your own code. What combinations of geoms or scales do you
    use all the time? How could you extract the pattern into a reusable 
    function?

## Functional programming

Since ggplot2 objects are just objects, you can put them in lists, and use all of R's great tools. For example, if you wanted to add different geoms to the same base plot, you could put them in a list and use `lapply()`.

`r columns(3, 1, 1)`
```{r}
geoms <- list(
  geom_point(),
  geom_boxplot(aes(group = cut_width(displ, 1))),
  list(geom_point(), geom_smooth())
)

p <- ggplot(mpg, aes(displ, hwy))
lapply(geoms, function(g) p + g)
```

Remember ggplot2 objects are regular R objects, and R is a functional programming language, so there are lots of standard R tools that you can apply. If you're not familiar with functional programming, a reasonable place to start is <http://adv-r.had.co.nz/Functional-programming.html>.

### Exercises

1.  What does the following function do? What's a better name for it?
    
    ```{r, eval = FALSE}
    mystery <- function(...) {
      Reduce(`+`, list(...), accumulate = TRUE)
    }
    
    mystery(
      ggplot(mpg, aes(displ, hwy)) + geom_point(), 
      geom_smooth(), 
      xlab(NULL), 
      ylab(NULL)
    )
    ```


## Plot functions {#sec:functions}

Creating small reusable components is most inline with the ggplot2 spirit: you can recombine them flexibly to create whatever plot you want. But sometimes you're creating the same plot over and over again, and you don't need that flexibility. Instead of creating components, you might want to a function that takes data and parameters and returns a complete plot.

For example, you could wrap up the complete code needed to make a piechart:

`r columns(1, 2 / 3, 0.5)`
```{r}
piechart <- function(data, mapping, ...) {
  ggplot(data, mapping) +
    geom_bar(width = 1) + 
    coord_polar(theta = "y") + 
    xlab(NULL) + 
    ylab(NULL)
}
piechart(mpg, aes(factor(1), fill = class))
```

This is much less flexible than the component based approach, but equally, it's much more concise.

You can take a similar approach to drawing parallel coordinates plots (PCPs) with ggplots. PCPs require a transformation of the data, so you can write two functions: one that does the transformation and one that generates the plot. I strongly recommend keeping the transformation and plotting separately because it makes life much easier if you later want to reuse the same transformation for a different visualisation.

`r columns(2, 2/3)`
```{r pcp_data}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
pcp_data <- function(df) {
  is_numeric <- vapply(df, is.numeric, logical(1))
  # Rescale numeric columns
  df[is_numeric] <- lapply(df[is_numeric], rescale01)
  # Add row identifier
  df$.row <- rownames(df)
  # Treat numerics as value (aka measure) variables 
  tidyr::gather_(df, "variable", "value", names(df)[is_numeric])
}
pcp <- function(df, ...) {
  df <- pcp_data(df)
  ggplot(df, aes(variable, value, group = .row)) + 
    geom_line(...)
}
pcp(mpg)
pcp(mpg, aes(colour = drv))
```

A complete example of this idea is `qplot()`, which provides a fairly deep wrapper around the most common `ggplot()` options. I recommend studying the source code if you want to see how far these basic techniques can take you.


### Indirectly referring to variables

The `piechart()` function above is a little unappealing because it requires the user to know the exact `aes()` specification that generates a pie chart. It would be more convenient if the user could simply specify the the name of the variable to plot. To do that you'll need to learn a bit more about how `aes()` works.

`aes()` uses non-standard evaluation: rather than looking at the values of its arguments, it looks at their expressions. This makes it difficult to work with programmatically - there's no way to store the name of a variable in an object and then refer to it later:

```{r}
x_var <- "displ"
aes(x_var)
```

Instead we need to use `aes_()`, which uses regular evaluation. There are two basic ways to create a mapping with `aes_()`:

*   Using a _quoted call_, created by `quote()`, `substitute()`, `as.name()`, 
    or `parse()`.
    
    ```{r}
    aes_(quote(displ))
    aes_(as.name(x_var))
    aes_(parse(text = x_var)[[1]])
    
    f <- function(x_var) {
      aes_(substitute(x_var))
    }
    f(displ)
    ```

    (The difference between `as.name()` and `parse()` is subtle. If `x_var` 
    is "a + b", `as.name()` will turn it into a variable called `` `a + b` ``,
    `parse()` will turn it into the function call `a + b`. If this is
    confusing <http://adv-r.had.co.nz/Expressions.html> might help).

*   Using a formula, created with `~`.

    ```{r}
    aes_(~displ)
    ```

`aes_()` gives us three options for how a user can supply variables: as a string, as a formula, or as a bare expression. These three options are illustrated below

`r columns(3, 1)`
```{r}
piechart1 <- function(data, var, ...) {
  piechart(data, aes_(~factor(1), fill = as.name(var)))
}
piechart1(mpg, "class") + theme(legend.position = "none")

piechart2 <- function(data, var, ...) {
  piechart(data, aes_(~factor(1), fill = var))
}
piechart2(mpg, ~class) + theme(legend.position = "none")

piechart3 <- function(data, var, ...) {
  piechart(data, aes_(~factor(1), fill = substitute(var)))
}
piechart3(mpg, class) + theme(legend.position = "none")
```

There's another advantage to `aes_()` over `aes()` if you're writing ggplot2 plots inside a package: using `aes_(~x, ~y)` instead of `aes(x, y)` avoids the global variables NOTE in `R CMD check`.

### The plot environment

As you create more sophisticated plotting functions, you'll need to understand a bit more about ggplot2's scoping rules. ggplot2 was written well before I understood the full intricacies of non-standard evaluation. This means it has a rather simple scoping system. If a variable is not found in the `data`, it is looked for in the plot environment. There is only one environment for a plot (not one for each layer), and it is the environment in which `ggplot()` is called from (i.e. the `parent.frame()`).

This means that a function like this won't work:

```{r, error = TRUE}
f <- function() {
  n <- 10
  geom_line(aes(x / n)) 
}
df <- data.frame(x = 1:3, y = 1:3)
ggplot(df, aes(x, y)) + f()
```

Because `n` is not stored in an environment accessible when the expressions in the mapping are evaluated. 

Note that this is only a problem with `mapping`, not with any other arguments. All other arguments are evaluated immediately so their values (not a reference to a name) is stored in the plot object.

```{r, fig.show = "hide"}
f <- function() {
  colour <- "blue"
  geom_line(colour = colour) 
}
ggplot(df, aes(x, y)) + f()
```

If you need to use a different environment for the plot, you can specify it with the `environment` argument to `ggplot()`.

### Exercises

1.  Create a `distribution()` function specially designed for visualising 
    continuous distributions. Allow the user to supply a dataset and the
    name of a variable to visualise. Let them choose between histograms,
    frequency polygons, and density plots. What other arguments might you
    want to include?
