\input{header.tex}


% qplot chapter suggestions:
% 
% * exercises - see plot and then try and create on your own
% * wall chart of different plot types
% * more error bar and ribbon examples
% * table of options

% decumar<<< 
% source("~/documents/ggplot/ggplot/load.r")
% library(xtable)
% doptions(width=8, height=4.8, lscale=0.5)
% ggopt(axis.color = "black")
% >>>

%\setchapterpreamble[u]{% 
%\dictum[Friedrich Nietzsche]{He who fights with monsters might take care lest he thereby become a monster. And if you gaze for long into an abyss, the abyss gazes also into you.}} 

\chapter{Getting started with ggplot: {\tt qplot}}

\section{Introduction} 

In this chapter, you will learn to make a wide variety of plots with your first ggplot function, {\tt qplot}, short for {\bf q}uick plot. qplot makes it easy to produce complex plots, normally requiring several lines of code in R, in one line. qplot can do this because it's based on the grammar of graphics, which allows you to create a simple, yet expressive, description of the plot.  In later chapters you'll learn to use all of the expressive power of the grammar, but here we'll start simple so you can work your way up.

{\tt qplot} has been designed be very similar to {\tt plot}, which should make it easy if you're already familiar with plotting in R.  Remember, during an R session you can get a summary of all the arguments to {\tt qplot} with R help, {\tt ?qplot}.

In this chapter you'll learn:

\begin{itemize}
	\item The basic use of {\tt qplot}---If you're already familiar with {\tt plot}, this will be particularly easy. Page \pageref{sec:basic_use}.
	\item How to map variables to aesthetic attributes, like colour, size and shape. Page \pageref{sec:aesthetic_attributes}.
	\item How to creating many different types of plots by specifying different geoms, and how to combine multiple types in a single plot. Page \pageref{sec:plot_geoms}.
	\item The use of facetting, also known as trellising or conditioning, to break apart subsets of your data. Page \pageref{sec:facetting}.
	\item How to tune the appearance of the plot by specifying some basic options. Page \pageref{sec:other_options}.
\end{itemize}

\section{Data sets}\label{sec:data_sets}

In this chapter we'll just use one data source, so you can get familiar with the plotting details rather than having to familiarise yourself with different datasets.  The {\tt diamonds} dataset consists of prices and quality information about 54,000 diamonds, and is included in the ggplot package.  The dataset has not been well cleaned, so as well as demonstrating interesting relationships about diamonds, it also demonstrates some data quality problems.  We'll also use another dataset, {\tt dsmall}, which is a random sample of 1000 diamonds.  We'll use this for plots which are more appropriate for smaller datasets.

The first few rows of the data are shown in \ref{tab:diamonds}.

% decumar<<< 
% set.seed(1410)
% dsmall <- diamonds[sample(nrow(diamonds), 1000),]
% xtable(head(diamonds), digits=c(0,1,2,0,0,1,1,0,0,2,2,2), align="l|rrrrrrrrrrr", label="tab:diamonds", caption="{\tt diamonds} dataset")
% |||
% latex table generated in R 2.5.0 by xtable 1.4-3 package
% Wed May 23 15:32:00 2007
\begin{table}[ht]
\begin{center}
\begin{tabular}{l|rrrrrrrrrrr}
  \hline
 & shape & carat & cut & colour & clarity & depth & table & price & x & y & z \\
  \hline
1 & Round & 0.23 & Ideal & E & SI2 & 61.5 & 55 & 326 & 3.95 & 3.98 & 2.43 \\
  2 & Round & 0.21 & Premium & E & SI1 & 59.8 & 61 & 326 & 3.89 & 3.84 & 2.31 \\
  3 & Round & 0.23 & Good & E & VS1 & 56.9 & 65 & 327 & 4.05 & 4.07 & 2.31 \\
  4 & Round & 0.29 & Premium & I & VS2 & 62.4 & 58 & 334 & 4.20 & 4.23 & 2.63 \\
  5 & Round & 0.31 & Good & J & SI2 & 63.3 & 58 & 335 & 4.34 & 4.35 & 2.75 \\
  6 & Round & 0.24 & Very Good & J & VVS2 & 62.8 & 57 & 336 & 3.94 & 3.96 & 2.48 \\
   \hline
\end{tabular}
\caption{{	t diamonds} dataset}
\label{tab:diamonds}
\end{center}
\end{table}
% >>>

\section{Basic use}\label{sec:basic_use}

Just like {\tt plot}, the first two arguments to {\tt qplot} are {\tt x} and {\tt y}, giving the x- and y-coordinates for the objects on the plot. There is also an optional {\tt data} argument.  If this is specified, {\tt qplot} will look inside that data frame before looking for objects in your workspace.  I recommend that you keep all the data for one plot in a data frame, instead of scatter across multiple vectors.

Here is a simple example of using {\tt qplot}, investigating the relationship between price and carats (weight) of a diamond.  

% decumar<<< 
% interweave({
% qplot(carat, price, data=diamonds)
% })
% |||
\begin{alltt}
> qplot(carat, price, data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/3efcbcf607b2f70949d2649272aee437.pdf}
\begin{alltt}

\end{alltt}
% >>>

You are not limited to specifying names of existing vectors: you can use functions of them as well.  Here we look at the relationship of log(price) to log(weight), and the relationship between weight and volume ($x * y * z$).

% decumar<<< 
% interweave({
% qplot(log(carat), log(price), data=diamonds)
% qplot(carat, x * y * z, data=diamonds)
% })
% |||
\begin{alltt}
> qplot(log(carat), log(price), data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/6059255f674625027e46eac69fb596ae.pdf}
\begin{alltt}

> qplot(carat, x * y * z, data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/110775f41e86da8d0e423b4637e04273.pdf}
\begin{alltt}

\end{alltt}
% >>>

These plots illustrate some unusual features of this dataset.  There seems to be a narrow band of prices for which there are no diamonds, and there are some diamonds with very unusual volumes for their weight.  We will investigate these relationships more as we continue.

\section{Aesthetic attributes}\label{sec:aesthetic_attributes}

The first big difference with using {\tt qplot} compared to {\tt plot} comes when you want to assign colours---or sizes or shapes---to the points on your plot.  With {\tt plot}, it's your responsibility to change your data (eg. ``apples'', ``bananas'', ``pears'') into something that {\tt plot} knows how to use (eg. ``red'', ``yellow'', ``green'').  {\tt qplot} will do this for you automatically, and will automatically provide a legend to make it easier to look up the actual data values.  This makes it easy to include additional data on the plot.  

In the next example, we augment the plot of carat and price with information about colour, clarity and cut of the diamonds.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, colour=colour)
% qplot(carat, price, data=dsmall, size=clarity)
% qplot(carat, price, data=dsmall, shape=cut)
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, colour = colour)
\end{alltt}
\includegraphics[scale=0.5]{./include/c533c977919e425c5e4daa05997336a4.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, size = clarity)
\end{alltt}
\includegraphics[scale=0.5]{./include/8a4b8428cb604953497f3ea44855c0f7.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, shape = cut)
\end{alltt}
\includegraphics[scale=0.5]{./include/bbae864b1b8b2bfaf312fa141c843e8c.pdf}
\begin{alltt}

\end{alltt}
% >>>

Colour, size and shape are all examples of aesthetic attributes.  An aesthetic attribute is some property that affects how the observations are displayed.  For every aesthetic attribute, there is some function, called a scale, which maps data values to valid values for that aesthetic.  It is this scale that controls how the points appear.  For example, in the above plots, the colour scale maps J to purple and F to green.  We will learn how to configure this in Chapter X.

Different types of aesthetic attributes work better with different types of variables.  For example, colour and shape work well with categorical variables, while size works better with continuous variables.  You can always convert a continuous variable to a categorical one using the {\tt chop} function. The amount of data also makes a difference:  size works poorly when you have a lot of data, because you can't distinguish the individual points.  These issues are discussed more in chapter X.

\section{Plot geoms}\label{sec:plot_geoms}

{\tt qplot} is not limited to just producing scatterplots.  In fact, it can produce almost any type of plots, by varying the {\bf geom} used. Geom, short for geometric object, describes the type of object that is used to display the data.  Some geoms have an associated statistical transformation, for example, a histogram is a binning statistic plus a bar geom.  These different components are described in the next chapter.  Here we'll introduce you to the most common and useful geoms, categorised by whether they are useful for 1D or 2D data.

The following geoms enable you to investigate 2D relationships:

\begin{itemize}
	\item {\tt geom="point"} draws points to produce a scatterplot (the default), as described above.
	\item {\tt geom="smooth"} fits a smoother to the data and displays the smooth and its standard error.
	\item {\tt geom="quantiles"} displays conditional density estimates.  You can think of this as a extension of boxplots to deal with the case of a continuous conditioning variable.
	\item {\tt geom="density2d"} adds contours of a 2d density estimate.  This is very useful when you have a lot of overplotting.
	\item {\tt geom="path"} and {\tt geom="line"} draw lines between the data points.  Traditionally these are used to explore relationships between time and another variable, but lines may to be use to join observations connected in some other way.  A line plot is constrained to produce lines that travel from left to right, while paths can go in any direction.
	\item {\tt geom="boxplot"} produces a box and whisker plot to summarise the distribution of a set of points.
  % \item {\tt geom="errorbar"} adds error bars to help indicate uncertainty associated with measurements.
\end{itemize}

These geoms are useful for exploring 1d distributions:

\begin{itemize}
	\item {\tt geom="histogram"} draws a histogram of the $x$ variable (continuous or categorical)
	\item {\tt geom="density"} creates a density plot for the $x$ variable (continuous only)
  % \item {\tt geom="bar"} makes a barchart.
\end{itemize}

Other types of plots for dealing with categorical data (bar charts, mosiac plots, spineplots, spinograms) are dealt with in chapter X, using the special categorical plotting function {\tt catplot}.

\subsection{Adding a smoother to a plot}\label{sub:smooth}

If you have a scatterplot with many data points, it can be hard to see exactly what trend is shown by the data.  In this case you may want to add a smoothed line to the plot.  This is easily done using the {\tt smooth} geom:

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, geom=c("smooth", "point"))
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"))
\end{alltt}
\includegraphics[scale=0.5]{./include/73fa72500aec0af896b175ef3ff7515f.pdf}
\begin{alltt}

\end{alltt}
% >>>

Notice that we have combined multiple geoms by supplying a vector of geom names to {\tt qplot}.  The geoms will be overlaid in the order that you specified them.

There are many different smoothers you can choose using the {\tt method} argument:

\begin{itemize}
	\item {\tt method="loess"}, the default, uses a smooth local regression.  More details about the algorithm used can be found in {\tt ?loess}.  You can modify the wiggliness of the line by varying the span between 0, exceeding wiggly, and 1, not so wiggly.  Loess does not work well for large datasets (it's $O(n^2)$ in memory), so you'll need to use one of the other methods listed below.

  % decumar<<< 
  % interweave({
  % qplot(carat, price, data=dsmall, geom=c("smooth", "point"), span=0.1)
  % qplot(carat, price, data=dsmall, geom=c("smooth", "point"), span=1)
  % })
  % |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"))
\end{alltt}
\begin{alltt}

> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     span = 0.2)
\end{alltt}
\begin{alltt}

> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     span = 1)
\end{alltt}
\begin{alltt}

\end{alltt}
  % >>>

	\item {\tt method="lm"} fits a linear model.  The default will fit a straight line to your data, or you can specify {\tt formula = y $\sim$ poly(x, 2)} to specify a degree 2 polynomial, or better, load the {\tt splines} library and use a natural spline: {\tt formula = y $\sim$ ns(x, 2)}. The second parameter is the degrees of freedom: a higher number will create a wigglier curve. You are free to specify any formula involving $x$ and $y$.  

  % decumar<<< 
  % interweave({
  % qplot(carat, price, data=dsmall, geom=c("smooth", "point"), method="lm")
  % library(splines)
  % qplot(carat, price, data=dsmall, geom=c("smooth", "point"), method="lm", formula=y ~ ns(x,3))
  % })
  % |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     method = "lm")
\end{alltt}
\begin{alltt}

> library(splines)
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     method = "lm", formula = y ~ ns(x, 3))
\end{alltt}
\begin{alltt}

\end{alltt}
  % >>>

	\item {\tt method="rlm"} works the same as {\tt lm}, but uses a robust fitting algorithm so that outliers don't affect the fit as much.  It's part of the {\tt MASS} package, so remember to load that first.

	\item You could also load the {\tt mgcv} library and use {\tt method="gam", formula = y $\sim$ s(x)} to fit a generalised additive model.  This is similar 
to using a spline with {\tt lm}, but the degree of smoothness is estimated from the data.  For large data, you should use the formula {\tt y $\sim$ s(x, bs="cr")}
 
  % decumar<<< 
  % interweave({
  % library(mgcv)
  % qplot(carat, price, data=dsmall, geom=c("smooth", "point"), method="gam", formula= y ~ s(x))
  % qplot(carat, price, data=diamonds, geom=c("smooth", "point"), method="gam", formula= y ~ s(x, bs="cr"))
  % })
  % |||
\begin{alltt}
> library(mgcv)
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     method = "gam", formula = y ~ s(x))
\end{alltt}
\begin{alltt}

> qplot(carat, price, data = diamonds, geom = c("smooth", "point"), 
+     method = "gam", formula = y ~ s(x, bs = "cr"))
\end{alltt}
\begin{alltt}

\end{alltt}
  % >>>

\end{itemize}

By default, the standard errors are shown with a grey band around the smoother.  If you want to turn them off, use {\tt se=FALSE}.

\subsection{Quantiles}\label{sub:quantiles}

A smoother displays a smoothed conditional mean.  It's often useful to see a smooth estimate of other summaries of the distribution, for example the upper and lower quartiles to show the spread of the data.  We can do this with quantile regression \citep{koenker:2005}, which is basically a process to estimate smoothed conditional quantiles.  The types of smoothes we can use is much more limited compared to {\tt geom="smooth"}, but we can learn more about the conditional distribution.

For this example, we're going to zoom into a small range of diamond sizes so we can look at the distribution more closely.

% decumar<<< 
% interweave({
% dlittle <- subset(diamonds, carat < 2)
% qplot(carat, price, data=dlittle, geom=c("point", "quantile"))
% })
% |||
\begin{alltt}
> dlittle <- subset(diamonds, carat < 2)
> qplot(carat, price, data = dlittle, geom = c("point", "quantile"))
\end{alltt}
\includegraphics[scale=0.5]{./include/f0e3272f519354eb6b76f28a9be5bbae.pdf}
\begin{alltt}

\end{alltt}
% >>>

By default, the relationship between x and y is assumed to be linear, but we can adjust this using the {\tt formula} argument, in the same way that we could for smoothers.  In this example we'll try using a natural spline, and then manually adding some change points where we can see an obvious jump on the graph.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dlittle, geom=c("point", "quantile"), formula=y~ns(x, 3))
% qplot(carat, price, data=dlittle, geom=c("point", "quantile"), formula=y~ns(x, 3) + I(x > 1) + I(x > 1.5))
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dlittle, geom = c("point", "quantile"), 
+     formula = y ~ ns(x, 3))
\end{alltt}
\includegraphics[scale=0.5]{./include/8a2e5f541b32d70b4f6c2b658c778404.pdf}
\begin{alltt}

> qplot(carat, price, data = dlittle, geom = c("point", "quantile"), 
+     formula = y ~ ns(x, 3) + I(x > 1) + I(x > 1.5))
\end{alltt}
\includegraphics[scale=0.5]{./include/bdf04a39610ebd47bf97d2a092139684.pdf}
\begin{alltt}

\end{alltt}
% >>>

You can also adjust the quantiles displayed with the {\tt quantiles} argument:

% decumar<<< 
% interweave({
% qplot(carat, price, data=dlittle, geom=c("point", "quantile"), formula=y~ns(x, 3) + I(x > 1) + I(x > 1.5), quantiles=seq(0.05,0.95, 0.05))
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dlittle, geom = c("point", "quantile"), 
+     formula = y ~ ns(x, 3) + I(x > 1) + I(x > 1.5), quantiles = seq(0.05, 
+         0.95, 0.05))
\end{alltt}
\includegraphics[scale=0.5]{./include/dc12c0a1d12d7753270939fc2cd4784c.pdf}
\begin{alltt}

\end{alltt}
% >>>

\subsection{2d density contours}

When there is a lot of over-plotting on a plot, it is very hard to judge the relative density of points.  One way to get around this is to supplement the plot with contour lines from a 2d density estimate.  This is shown below.

% decumar<<< 
% interweave({
% qplot(log(carat), log(price), data=diamonds, geom=c("point","density2d"))
% })
% |||
\begin{alltt}
> qplot(log(carat), log(price), data = diamonds, geom = c("point", 
+     "density2d"))
\end{alltt}
\begin{alltt}

\end{alltt}
% >>>

The density estimation is described in more detail in {\tt ?kde2d}.

\subsection{Time series with line and path plots}\label{sub:line_plot}

Line and path plots are typically used for time series data.  Line plots always join the points from left to right, while path plots join them in the order that they appear in the data set (a line plot is just a path plot of the data sorted by x value).  Line plots usually have time on the x-axis, showing how a single variable has changed over time.  Path plots show how two variables have simultaneously changed over time, with time encoded in the way that the points are joined together.

Because there isn't a time variable in the diamonds data, we will create an example data frame to illustrate these types of plots.  This has a very simple sinusoidal pattern in two variables.

% decumar<<< 
% interweave({
% df <- data.frame(year = 1:20, a = sin(1:20 * pi / 5) + rnorm(20, 0, 0.15), b=cos(1:20 * pi / 5)  + rnorm(20, 0, 0.15))
% head(df)
% })
% |||
\begin{alltt}
> df <- data.frame(year = 1:20, a = sin(1:20 * pi/5) + rnorm(20, 
+     0, 0.15), b = cos(1:20 * pi/5) + rnorm(20, 0, 0.15))
> head(df)
  year           a          b
1    1  0.70290625  0.6552839
2    2  0.87791696  0.1256403
3    3  0.92555697 -0.2606255
4    4  0.54479073 -0.9252863
5    5 -0.03462586 -1.0217611
6    6 -0.79865539 -1.0162740

\end{alltt}
% >>>

Let's start with a time series plot of {\tt a}.

% decumar<<< 
% interweave({
% qplot(year, a, data=df, geom="line")
% })
% |||
\begin{alltt}
> qplot(year, a, data = df, geom = "line")
\end{alltt}
\includegraphics[scale=0.5]{./include/0c143796e1ed0fa260fb6c91c611a828.pdf}
\begin{alltt}

\end{alltt}
% >>>

If we want to display the two variables on the same plot we need to reshape our dataset so that we have a new column which represents the variable the observation was taken on.  The {\tt melt} function from the {\tt reshape} package will do this for us.  Reshaping data is described more in XXX.  Notice that specifying {\tt colour} draws two series.  If we just want to separate series, we can use the {\tt group} aesthetic.

% decumar<<< 
% interweave({
% dfm <- melt(df, id="year")
% head(dfm)
% qplot(year, value, data=dfm, geom="line", colour=variable)
% qplot(year, value, data=dfm, geom="line", group=variable)
% })
% |||
\begin{alltt}
> dfm <- melt(df, id = "year")
> head(dfm)
  year variable       value
1    1        a  0.70290625
2    2        a  0.87791696
3    3        a  0.92555697
4    4        a  0.54479073
5    5        a -0.03462586
6    6        a -0.79865539

> qplot(year, value, data = dfm, geom = "line", colour = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/7f6a9fade4e4549933ac5c6be9d2dab6.pdf}
\begin{alltt}

> qplot(year, value, data = dfm, geom = "line", group = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/a5ddb641249a3e830a4c450bd94b9bf3.pdf}
\begin{alltt}

\end{alltt}
% >>>

These plots show the behaviour of {\tt a} and {\tt b} individually, but it is not so easy to see the joint pattern.  Each time point occupies a point on the 2d grid of {\tt a} and {\tt b}, and if we joint up each point to its neighbours we get a 2d trajectory.

This can be illustrated with a path plot.  Below we plot {\tt a} vs {\tt b} and then join the individual observations with a path to show the pattern over time.  To make it more obvious in which direction time flows, we can use the {\tt size} aesthetic, as in the second plot.   This allows us to see that it follows a cyclical pattern over time.

% decumar<<< 
% interweave({
% qplot(a, b, data=df, geom="path")
% qplot(a, b, data=df, geom="path", size=year)
% })
% |||
\begin{alltt}
> qplot(a, b, data = df, geom = "path")
\end{alltt}
\includegraphics[scale=0.5]{./include/f4c573d51742a0b16981182788c97c7d.pdf}
\begin{alltt}

> qplot(a, b, data = df, geom = "path", size = year)
\end{alltt}
\includegraphics[scale=0.5]{./include/5d102c209d84551d7b7bef25be0ff05b.pdf}
\begin{alltt}

\end{alltt}
% >>>

The examples above illustrate the two most common aesthetics for path and line plots: {\tt colour}, and {\tt size}.  The final aesthetic attribute that line and path plots use is {\tt linetype}, which species the dashing pattern of the line: solid, dashed, dotted etc.

% decumar<<< 
% interweave({
% qplot(year, value, data=dfm, geom="line", linetype=variable)
% })
% |||
\begin{alltt}
> qplot(year, value, data = dfm, geom = "line", linetype = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/b32aa118b2db02a9af702d19dfa0e9d8.pdf}
\begin{alltt}

\end{alltt}
% >>>

\subsection{Boxplots and jittered points}\label{sub:boxplot}

If you have one categorical variable, and one or more continuous variables, you will probably be interested to know how the values of the continuous variables vary with the categorical.  Box plots and jittered points offer to ways to do this.  

This example looks at how the price per carat varies with colour of the diamond.

% decumar<<< 
% interweave({
% qplot(colour, price/carat, data=diamonds, geom="jitter")
% qplot(colour, price/carat, data=diamonds, geom="boxplot")
% })
% |||
\begin{alltt}
> qplot(colour, price/carat, data = diamonds, geom = "jitter")
\end{alltt}
\includegraphics[scale=0.5]{./include/1f4a027324e4e56aa4f679768c01546c.pdf}
\begin{alltt}

> qplot(colour, price/carat, data = diamonds, geom = "boxplot")
\end{alltt}
\includegraphics[scale=0.5]{./include/ea1b813995a8becdd218497464903fad.pdf}
\begin{alltt}

\end{alltt}
% >>>

Both boxplots and jittered points will try to guess which orientation they should lie, and while most of the time they will get it right, sometimes you will need to say exactly what you want.  For the boxplot, use {\tt orientation="horizontal"} or {\tt orientation="vertical"}, and for the jittered points, use {\tt xjitter} and {\tt yjitter} to specify the amount of jittering to use. 

For jittered points, you have the same control over aesthetics as you do with a normal scatterplot: {\tt size}, {\tt colour}, {\tt shape}.  The options for boxplots are more limited (and it is hard to imagine when they would be useful), you can control only the outline colour ({\tt colour}) and the internal fill {\tt fill}.

Another way to look at conditional distributions is to plot a separate histogram or density plot for each value of the categorical variable.

\subsection{Histogram and density plots}\label{sub:density}

Histogram and density plots show the distribution of a single variable.  They provide more information about the distribution of a single group than boxplots do, but it is harder to compare many groups (although we will look at one way to do so).  The next example shows the distribution of carats with a histogram and a density plot.

% decumar<<< 
% interweave({
% qplot(carat, data=diamonds, geom="histogram")
% qplot(carat, data=diamonds, geom="density")
% })
% |||
\begin{alltt}
> qplot(carat, data = diamonds, geom = "histogram")
\end{alltt}
\includegraphics[scale=0.5]{./include/cd68a9dc987b40e80029776d9efdf34a.pdf}
\begin{alltt}

> qplot(carat, data = diamonds, geom = "density")
\end{alltt}
\includegraphics[scale=0.5]{./include/5a5bae0f09248da5c2666c2094142b19.pdf}
\begin{alltt}

\end{alltt}
% >>>

You can control the amount of smoothing using the {\tt binwidth} argument for the histogram, which specifies the bin size to use.  You can also specify the break points explicitly, using the {\tt breaks} argument.  For the density plot, you can use {\tt adjust} argument, which adjusts the bandwidth of the smoother (high values of {\tt adjust} produce smoother plots).  It is {\bf very important} to experiment with the level of smoothing.  With a histogram you should try many bin widths before you decide on the one (or two, or three) which best describe the data.

For this example, we need to use a rather small binwidth before we can see the full story.

% decumar<<< 
% interweave({
% qplot(carat, data=diamonds, geom="histogram", binwidth=1)
% qplot(carat, data=diamonds, geom="histogram", binwidth=0.1)
% qplot(carat, data=diamonds, geom="histogram", binwidth=0.01)
% })
% |||
\begin{alltt}
> qplot(carat, data = diamonds, geom = "histogram", binwidth = 1)
\end{alltt}
\includegraphics[scale=0.5]{./include/fd9a4d1484d28d618dca680087b6452f.pdf}
\begin{alltt}

> qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.1)
\end{alltt}
\includegraphics[scale=0.5]{./include/4b2d50d669038c432411090a666e680c.pdf}
\begin{alltt}

> qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.01)
\end{alltt}
\includegraphics[scale=0.5]{./include/07828a76b42cae67f56650f70126a4db.pdf}
\begin{alltt}

\end{alltt}
% >>>

Density plots are useful in that they are easier to overlay, but are generally less flexible than histograms, and it is more difficult to understand exactly what a density plot is showing.  (And we are {\bf not} trying to estimate a density: we're trying to see what's going on with our data)  If you want to compare the distributions of different subgroups, all you need to do is add an aesthetic mapping that differentiates the different groups, as follows:

% decumar<<< 
% interweave({
% qplot(carat, data=diamonds, geom="density", colour=colour)
% })
% |||
\begin{alltt}
> qplot(carat, data = diamonds, geom = "density", colour = colour)
\end{alltt}
\includegraphics[scale=0.5]{./include/6f01ea3caddde8bb5b7e93fa5eab0461.pdf}
\begin{alltt}

\end{alltt}
% >>>

% \subsection{Displaying uncertainty with error bars and ribbons}\label{sub:error_bars}
% 
% + Use with statistics
% 
% There are two ways to display standard errors with {\tt ggplot}.  For point standard errors, you can use the {\tt errorbar} geom.  For continuous or functional standard errors, you can use the {\tt ribbon} grob.  We've have already seen an example of this: the {\tt ribbon} grob is used inside {\tt smooth} to display the standard errors of the smooth.  Because there are so many different ways to calculate standard errors, the calculation is up to you.  {\tt ggplot} only provides facilities for displaying them once you have them.
% 
% For both {\tt ribbon} and {\tt errobar} you can specify confidence internals in two ways:
% 
% \begin{itemize}
%   \item using {\tt upper} and {\tt lower} which specify the upper and lower edges of the confidence band
% 
%   \item using {\tt y}, {\tt plus} and {\tt minus} which specify the estimate and positive and negative displacements (if you only specify one of plus and minus, the other will default to the negative of the one that is supplied)
% \end{itemize}
% 
% [Need an example here]

\section{Plots for weighted data}\label{sec:weighted_data}

When you have aggregated data where each row in the dataset represents multiple observations, you need some way to take into account the weighting variable.  Since there are no variables appropriate for weighting in the diamonds data, we will use some data collected o Midwest states in the 2000 census.  The data consists mainly of percentages (eg. percent white, percent below poverty line, percentage with college degree) and some information for each county (area, total population, population density).

There are few different things we might want to weight by: 

\begin{itemize}
	\item nothing, to look at county numbers
	\item total population, to work with absolute numbers
	\item area, to investigate geographic effects
\end{itemize}

\noindent The choice of a weighting variable profoundly effects what we are looking at in the plot and the conclusions that we will draw.  There are two aesthetic attributes that can be used to adjust for weights.  Firstly, for simple geoms like lines and points, you can make the size of the grob proportional to the number of points, using the {\tt size} aesthetic, as follows:

% decumar<<< 
% interweave({
% midwest <- read.csv("~/Documents/graphics/weighted/midwest.csv")
% qplot(percwhite, percbelowpoverty, data=midwest)
% qplot(percwhite, percbelowpoverty, data=midwest, size=poptotal)
% qplot(percwhite, percbelowpoverty, data=midwest, size=area)
% })
% |||
\begin{alltt}
> midwest <- read.csv("~/Documents/graphics/weighted/midwest.csv")
> qplot(percwhite, percbelowpoverty, data = midwest)
\end{alltt}
\includegraphics[scale=0.5]{./include/35972e9c93667b204a33fa9062fd3bda.pdf}
\begin{alltt}

> qplot(percwhite, percbelowpoverty, data = midwest, size = poptotal)
\end{alltt}
\includegraphics[scale=0.5]{./include/02ca1c2b50ba3186501cabd3b3e8d894.pdf}
\begin{alltt}

> qplot(percwhite, percbelowpoverty, data = midwest, size = area)
\end{alltt}
\includegraphics[scale=0.5]{./include/c69c3072af4afc0b89188dfacaaacd14.pdf}
\begin{alltt}

\end{alltt}
% >>>

For more complicated grobs which involve some statistical transformation, we specify weights with the {\tt weight} aesthetic.  These weights will be passed on to the statistical summary function.  Weights are supported for every case where it makes sense: smoothers, quantile regressions, box plots, histograms, and density plots.  You can't see this weighting variable directly, and it doesn't produce a legend, but it will change the results of the statistical summary.

The following example shows how weighting by population density effects the relationship between percent white and percent below the poverty line.

% decumar<<< 
% interweave({
% qplot(percwhite, percbelowpoverty, data=midwest, geom=c("point","smooth"), method=lm)
% qplot(percwhite, percbelowpoverty, data=midwest, size=popdensity, weight=popdensity,geom=c("point","smooth"), method=lm)
% })
% |||
\begin{alltt}
> qplot(percwhite, percbelowpoverty, data = midwest, geom = c("point", 
+     "smooth"), method = lm)
\end{alltt}
\includegraphics[scale=0.5]{./include/15c28127e14fef5af739837d9ee4f60c.pdf}
\begin{alltt}

> qplot(percwhite, percbelowpoverty, data = midwest, size = popdensity, 
+     weight = popdensity, geom = c("point", "smooth"), method = lm)
\end{alltt}
\includegraphics[scale=0.5]{./include/7e31a1efce5f86396d2daf18bc1ac8ee.pdf}
\begin{alltt}

\end{alltt}
% >>>

When we weight a histogram or density plot by total population, we change from looking at the distribution of the number of counties, to the distribution of the number of people.  This example shows the difference this makes for a histogram and density plot of the percentage below the poverty line.

% decumar<<< 
% interweave({
% qplot(percbelowpoverty, data=midwest, geom="histogram", binwidth=1)
% qplot(percbelowpoverty, data=midwest, geom="histogram", weight=poptotal, binwidth=1)
% })
% |||
\begin{alltt}
> qplot(percbelowpoverty, data = midwest, geom = "histogram", binwidth = 1)
\end{alltt}
\includegraphics[scale=0.5]{./include/23ebd1bac510d8284654c7c76932faaf.pdf}
\begin{alltt}

> qplot(percbelowpoverty, data = midwest, geom = "histogram", weight = poptotal, 
+     binwidth = 1)
\end{alltt}
\includegraphics[scale=0.5]{./include/604d3548b1e7169ae4d98a7a2a6a3c52.pdf}
\begin{alltt}

\end{alltt}
% >>>

\section{Combining plots}\label{sec:combining_plots}

As we have seen, you can combine multiple plot geoms by supplying a vector of geom names to {\tt qplot}.  The geoms will be overlaid in the order that you specified them:

% decumar<<< 
% interweave({
% qplot(colour, price/carat, data=diamonds, geom=c("jitter", "boxplot"))
% qplot(colour, price/carat, data=diamonds, geom=c("boxplot", "jitter"))
% })
% |||
\begin{alltt}
> qplot(colour, price/carat, data = diamonds, geom = c("jitter", 
+     "boxplot"))
\end{alltt}
\includegraphics[scale=0.5]{./include/9b7d93d74d326aeedf7b85a8482d158b.pdf}
\begin{alltt}

> qplot(colour, price/carat, data = diamonds, geom = c("boxplot", 
+     "jitter"))
\end{alltt}
\includegraphics[scale=0.5]{./include/f4289d8cb9300f7707eae70ceb1464c4.pdf}
\begin{alltt}

\end{alltt}
% >>>

The limitation of this technique is that you are plotting exactly the same data, just using a different geom.  You can also use the {\tt add} argument to add more elements to an existing plot.  This is useful when building up a plot from multiple data sources. Doing this is pretty easy: all you have to do is save the output of the {\tt qplot} function and pass it as the {\tt add} argument to the next {\tt qplot} call.

In this example, we add a rug plot to a density plot of weight.

% decumar<<< 
% interweave({
% (p <- qplot(carat, data=diamonds, geom="density", colour=cut))
% qplot(carat, 0, add=p)
% })
% |||
\begin{alltt}
> (p <- qplot(carat, data = diamonds, geom = "density", colour = cut))
\end{alltt}
\includegraphics[scale=0.5]{./include/338d5e09c1d6078a792a5cc81b594aca.pdf}
\begin{alltt}

> qplot(carat, 0, add = p)
\end{alltt}
\includegraphics[scale=0.5]{./include/4f240e9b827fe6678f157e6d7f8108fb.pdf}
\begin{alltt}

\end{alltt}
% >>>

[Need better example here]

\section{Facetting}\label{sec:facetting}

Facetting allows you to display small multiples of subsets of your data, as in this example where we have a histogram of price for each value of cut:

[Argh! buggy plot]

% decumar<<< 
% interweave({
% qplot(price, data=diamonds, facets= cut~ ., geom="histogram")
% })
% |||
\begin{alltt}
> qplot(price, data = diamonds, facets = cut ~ ., geom = "histogram")
\end{alltt}
\includegraphics[scale=0.5]{./include/7bcbe4c9dd371397245134af493742ab.pdf}
\begin{alltt}

\end{alltt}
% >>>

Each small multiple is called a facet, and contains the same plot for a different subset of the data.  The grid is specified with a facetting formula which looks like $row\_var \sim col\_var $.  You can specify as many row and column variables as you like, but in most cases more than one or two variables will produce a plot so large that it is difficult to see on screen.  If you want to facet on columns, or rows, not both, you can use {\tt .} as a place holder.  For example, $row\_var1 \sim .$ will facet by rows with a single variable.  

% decumar<<< 
% interweave({
% qplot(price, data=diamonds, facets= cut~ colour, geom="histogram")
% })
% |||
\begin{alltt}
> qplot(price, data = diamonds, facets = cut ~ colour, geom = "histogram")
\end{alltt}
\includegraphics[scale=0.5]{./include/553b8cbec3504efe9b4845c5bdbd9953.pdf}
\begin{alltt}

\end{alltt}
% >>>

Facetting is used to investigate conditional relationships, e.g. conditional on sex, what is the relationship between amount of smoking and lung cancer.  Facetting can also be useful for creating tables of graphics.  For some examples of this, and more ways to use facetting, see chapter XXX.

\subsection{Margins}\label{sub:margins}

Facetting a plot is like creating a contingency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics.  We can produce graphical margins using the the {\tt margins} argument.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex","age")}.  You can also use \verb|"grand_row"| or \verb|"grand_col"| to produce grand row and grand column margins respectively.

This example shows how the margins appear.  In the first plot, there are no margins, and we only see conditional plots.  In the second example, we see margins over columns, but not rows, and in the final example we see all possible margins.  The facet in the lower right corner displays all data points.

% decumar<<< 
% interweave({
% qplot(price, data=diamonds, facets= cut~ ., geom="histogram")
% })
% |||
\begin{alltt}
> qplot(price, data = diamonds, facets = cut ~ ., geom = "histogram")
\end{alltt}
\includegraphics[scale=0.5]{./include/06f3a070d084328c46857b53374dbbff.pdf}
\begin{alltt}

\end{alltt}
% >>>

Plots with many facets and margins may be more appropriate for printing, rather than on screen display, as the higher resolution allows you to compare many more subsets.

\section{Other options}\label{sec:other_options}

There are a few other options that {\tt qplot} provides to control the output of your graphic.  These all have the same effect as their {\tt plot} equivalents:

\begin{itemize}
	\item {\tt xlim}, {\tt ylim}: set limits for the x- and y-axes, each a numeric vector of length two, e.g. {\tt xlim=c(0, 20)} or {\tt ylim=c(-0.9, -0.5)}.
	\item {\tt log}: a character vector indicating which (if any) axes should be logged.  For example, {\tt log="x"} will log the x-axis, {\tt log="xy"} will log both.
	\item {\tt main}: main title for the plot, displayed in large text at the top-centre of the plot.  This can be a string (eg. {\tt main="plot title"}) or an expression (eg. {\tt main = expression(beta[1] == 1)}).  See {\tt ?plotmath} for more examples of using mathematical formulae.
	\item {\tt xlab}, {\tt ylab}: labels for the x- and y-axes.  As with the plot title, these can be character strings or mathematical expressions.
\end{itemize}

The following examples show the options in action.

% decumar<<< 
% interweave({
% qplot(carats, price, data=diamonds, xlab="Price ($)", ylab="Weight (carats)",  main="Price-weight relationship")
% qplot(carat, price/carat, data=diamonds, ylab=expression(price/carat), ylab="Price ($)",  main="Small diamonds", xlim=c(0,1))
% qplot(carat, price, data=diamonds, log="xy")
% })
% |||
\begin{alltt}
\end{alltt}
Error in scale[[1]]: subscript out of bounds \\ 

% >>>

\input{footer.tex}
