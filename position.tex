\input{_header.tex}
% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.5\textwidth COL: 2
%   INLINE: FALSE
%   CACHE: TRUE
% 

% END

\chapter{Positioning}
\label{cha:position}

\section{Introduction}

This chapter discusses position, particularly how panels are laid out on a page, and how coordinate systems within a panel work.  There are four things that control position.  You have already learned about two of them.  This chapter will describe the other two and show you how they all fit together:

\begin{itemize}
  \item {\bf Position adjustment}s in the layer, previously described in Section~\ref{sec:position}, control how overlapping objects within a panel are adjusted.

  \item {\bf Position scale}s, previously described in Section~\ref{sec:scale-position}, control how values in the data are mapped to positions on the plot.  This process is slightly different for continuous and discrete scales, but the majority of features are common to both.

  \item {\bf Coordinate system}s, described in Section~\ref{sec:coord}, control how the two independent position scales are combined to create a 2d coordinate system.  The most common coordinate system is Cartesian, but other coordinate systems can be useful in special circumstances

  \item {\bf Facetting}, described in Section~\ref{sec:facetting}, is a mechanism for automatically laying out multiple plots on a page.  It splits the data into subsets, and then plots each subset into a different panel on the page.  Such plots are often called small multiples.  
  
\end{itemize}

\section{Facetting}
\label{sec:facetting}

You first encountered facetting in Section~\ref{sec:qplot-facetting}, and you may already have been using it extensively in your plots.  Facetting generates small multiples of the same plot for different subsets of the data.  Small multiples are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different sections of the data and see whether they are the same or different.  This section will discusses how you can fine tune facets, particularly how they interact with position scales, to optimise the appearance of your plot. 

There are two types of facetting provide by ggplot: \code{facet_grid} and \code{facet_wrap}.  Facet grid produces a 2d grid of panels, and facet wrap produces 1d ribbon of panels that is wrapped around into 2d.  Facet grid is similar to the layout of \code{coplot} in base graphics, and facet wrap is similar to the layout of panels in \code{lattice}.

Facetting can be thought of a special type of coordinate system, one that is hierarchical.  At the top level we have a coordinate system created by the categorical variables that we are facetting by, and then within each of these regions another coordinate system generated by the x and y position of each graphic.

You can access either facetting system from \f{qplot}. A 2d facetting specification (e.g.\ \code{x ~ y}) will use \code{facet_grid}, while a 1d specification (e.g.\ \verb| ~ x|) will use \code{facet_wrap}.

\subsection{Facet grid}

The grid facetter lays out plots in a 2d grid and when specifying a facetting formula, you specify a grid of row and column variables. Variables appearing on a row or column together are nested, and only combinations that appear in the data will appear in the plot. Because it is a grid, variables that are specified on rows and columns will be crossed: all combinations will be shown, including those that didn't appear in the original data set.

You specify which variable (or variables) you want laid out in the columns, and which in the rows with a facetting formula:

\begin{itemize}
  \item \code{. ~ .}: The default, neither rows nor columns are facetted, so there is just a single panel.

  % INTERWEAVE
  % 
  % mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f"))
  % qplot(cty, hwy, data = mpg2) + facet_grid(. ~ cyl)
  \input{_include/1a5436d3b8d9da84431b1679ad8ca241.tex}  
  % END


  \item \code{. ~ a}: A single row with multiple columns.  This normally the most useful direction because computer screens are usually wider than they are long.  This direction of facetting facilitates comparisons of y position, because the scales are aligned.

  % INTERWEAVE
  % 
  % qplot(cty, hwy, data = mpg2) + facet_grid(. ~ cyl)
  \input{_include/32d6ddcae14f31a9085228b37e3180aa.tex}  
  % END
  
  \item \code{b ~ .}: A single column with multiple rows.  This direction facilitates comparison of x position (because the x scales are all aligned), and so is particularly useful for comparing distributions visualised as histograms or density plots.  Figure~\ref{fig:facet-hist} on \pageref{fig:facet-hist} is a good example of this use.

  % INTERWEAVE
  % 
  % mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f"))
  % qplot(cty, data = mpg2, geom="histogram", binwidth = 2) +
  %   facet_grid(cyl ~ .)
  \input{_include/85fababf231bbfc952ed68a35a0315b1.tex}  
  % END

  \item \code{a ~ b}: Multiple rows and columns.  You'll usually want to put the variable with the greatest number of levels in the columns, to take advantage of the aspect ratio of your screen.

  % INTERWEAVE
  % 
  % qplot(cty, hwy, data = mpg2) + facet_grid(drv ~ cyl)
  \input{_include/273a6e3611cf3f3fdb87f84208303ded.tex}  
  % END

  \item \code{. ~ a + b} / \code{a + b ~ .}:  Put multiple variables in rows or columns (or both). This is unlikely to be useful unless you have a very wide (or long) screen or the number of factor levels is small.  Or maybe you want to produce a very long, skinny poster.

  % INTERWEAVE
  % 
  % qplot(cty, hwy, data = mpg2) + facet_grid( ~ cyl + drv)
  \input{_include/24650b915f9a27b926a21402d8400f26.tex}  
  % END

\end{itemize}

\subsubsection{Margins}\label{sub:margins}

Facetting a plot is like creating a contingency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics.  We can produce graphical margins using the the {\tt margins} argument.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex", "age")}.  You can also use \verb|"grand_row"| or \verb|"grand_col"| to produce grand row and grand column margins respectively.  The specification of margins matches that of reshape, so please consult the reshape document for more details.

The following example shows what margins look like.  The first plot shows what the data looks like without margins, and the second shows all margins.  The margin column shows all drive trains, the margin row shows all cylinders, and the bottom-right plot (the grand total) shows the full data set.  For this data we can see that as the number of cylinders increases, engine displacement increases and fuel economy decreases, and compared to front wheel drive, as a group four wheel drive vehicles have about the same displacement, but are less fuel efficient.

% INTERWEAVE
% 
% p <- qplot(displ, hwy, data=mpg2) + geom_smooth(method="lm")
% p + facet_grid(cyl ~ drv) 
% p + facet_grid(cyl ~ drv, margins = T)
\input{_include/cb7c2a7a1fb259699a5f74d6c93bd535.tex}
% END

Groups in the margins are controlled in the same way as groups in all other panels, with the interaction of all categorical variables present in the panel.  (See Section~\ref{sub:grouping} for a reminder.)

% INTERWEAVE
% 
% qplot(displ, hwy, data=mpg2) + geom_smooth(aes(colour = drv), method="lm") + 
%   facet_grid(cyl ~ drv, margins = T) 
\input{_include/5b1ae4fd0b0742dc41f6fdff29789e3c.tex}
% END

Plots with many facets and margins may be more appropriate for printing than on screen display, as the higher resolution of print (600 dpi vs 72 dpi) allows you to compare many more subsets.

\subsection{Facet wrap}
\label{sub:facet_wrap}

An alternative is facet wrap.  Instead of having a 2d grid generated by the combination of two (or more) variables, \code{facet_wrap} makes a long ribbon of panels and wraps it into 2d.  This is useful if you have a single variable that with many levels and want to arrange the plots in a more space efficient manner.  This is what trellising in lattice does.

% INTERWEAVE
%   COL: 1 GG-WIDTH: 10 TEX-WIDTH: \textwidth
% 
% movies$decade <- round_any(movies$year, 10, floor)
% qplot(rating, ..density.., data=subset(movies, decade > 1890),
%   geom="histogram", binwidth = 0.5) + facet_wrap(~ decade, ncol = 6)
\input{_include/8986b1e58d228c605726b5e89bd9bdfc.tex}
% END

By default, \code{facet_wrap} will try and layout the panels as close to a square as possible (but with a slight bias towards wider rather than longer rectangles).  You can override the default by setting \code{ncol}, \code{nrow} or both.  See the documentation for more examples.

\subsection{Controlling scales}
\label{sub:controlling_scales}

For both types of facetting you can control whether the position scales are the same in all panels (fixed) or vary between panels (free).  This is controlled by the \code{scales} parameter:

\begin{itemize}
  \item \code{scales = "fixed"}: x and y position scales are fixed across all panels
  \item \code{scales = "free"}: x and y positions vary across panels.
  \item \code{scales = "free_x"}: x is free, and y is fixed.
  \item \code{scales = "free_y"}: y is free, and x is fixed.
\end{itemize}

% INTERWEAVE
% 
% p <- qplot(cty, hwy, data=mpg) # + geom_abline(slope = 0.72)
% p + facet_wrap(~ cyl)
% p + facet_wrap(~ cyl, scales = "free")
\input{_include/d1843aa06e1e3ffa5c426e400fcf9cd6.tex}
% END

Fixed scales allow you to compare subsets on an equal basis, seeing where each fits into the overall pattern.  Free scales zoom in on the region that each subset occupies, allowing you to see more details.  Free scales are useful when we to display multiple times series that were measured on different scales.  To do this, we first need to change from a ``wide'' to ``long'' data format.

% INTERWEAVE
%   COL: 1 GG-WIDTH: 10 TEX-WIDTH: \textwidth
% 
% em <- melt(economics, id = "date")
% qplot(date, value, data = em, geom = "line", group = variable) + 
%   facet_grid(variable ~ ., scale = "free_y")
\input{_include/5d4cee49ee3972b1c115fbf133ae972a.tex}
% END

There is an additional constraint on the scales of \code{facet_grid}: all panels in a column must have the same x scale, and all panels in a row much have the same y scale.  For \code{facet_grid} there is an additional parameter called \code{space}, which takes values \code{"free"} or \code{"fixed"}.  When the space can vary freely, each column (or row) will have width (or height) proportional to the range of the data in that column (or row).  This makes the scales equal across all rows: 1 cm on each panel maps to the same range of data.  (This is somewhat analogous to the ``sliced'' axis limits of lattice).  This is most useful for categorical axes, where we can assign space proportionally based on the number of levels.

% INTERWEAVE
% 
% mpg2 <- within(mpg2, {
%   model <- reorder(model, cty)
%   manufacturer <- reorder(manufacturer, -cty)
% })
% 
% 
% (models <- qplot(cty, model, data = mpg2))
% models + facet_grid(manufacturer ~ ., scales="free", space="free") +  
%   opts(strip.text.y = theme_text())
\input{_include/f4fd6281fe3e63910b9a1d80f8ca7b47.tex}
% END

Note the use of \f{reorder} to sort the factor levels in order of increasing average fuel efficiency, and the use of \f{opts} to rotate the strip labels.

\subsection{Missing facetting columns}
\label{sub:missing_facetting_columns}

If you facet on the original data set and add geom with a new dataset, \ggplot uses a simple heuristic to try and do what you want.  If you combine a facetted dataset with a dataset that lacks those facetting variables, the data will be repeated across the missing combinations. If you need precise control, just make sure that every additional dataset contains all the facetting columns used in the original dataset.

This is usually used for adding annotations or meta data to the plot.  For example, if you're drawing a map in the background, you want that map to be same across all panels.  This is what happens by default.

% INTERWEAVE
%   COL: 1 GG-WIDTH: 10 TEX-WIDTH: 0.8\textwidth
% 
% (ctyhwy <- qplot(cty, hwy, data=mpg) + facet_grid(. ~ cyl))
% 
% # Extract best & worst
% extreme <- subset(mpg, cty < 12 | cty > 30)[c("cty", "hwy", "cyl")]
% 
% # Show extremes on all facets (remove cyl column)
% ctyhwy + geom_point(data=extreme[, 1:2], colour = "red")
% # Show extremes for each facet (keep cyl column)
% ctyhwy + geom_point(data=extreme, colour = "red")
\input{_include/f6734e67549bcbe9bba922ab2285e31e.tex}
% END

\subsection{Grouping vs. facetting}
\label{sub:group-vs-facet}

Facetting is an alternative to using aesthetics (like colour, shape or size) to distinguish different groups.  Each techniques has strengths and weaknesses, centred around the distance between the groups.

With facetting, each group is quite far apart in its own panel: there is no overlap between the groups.  This is good if the groups overlap a lot, but it does make small differences harder to see.  The groups are in the same panel when using aesthetics, so may overlap, but otherwise small differences are easier to see.  Illustrated in Figure~\ref{fig:group-vs-facet}

Facetting will also work with much larger number of groups, and because you can split in two dimensions, you can compare two variables simultaneously more easily than using two different aesthetics (conjunctions are not preattentive).  The other advantage of facetting is that the scales can vary across panels, which is useful if the subsets occupy very different ranges.

% FIGURE
%   LABEL: group-vs-facet
%   CAPTION: Facetting vs grouping.
%   FILETYPE: png
% 
% xmajor <- c(0.1, 0.3, 0.5, 1,3, 5)
% xminor <- as.vector(outer(1:10, 10^c(-1, 0)))
% ymajor <- c(500, 1000, 5000, 10000)
% yminor <- as.vector(outer(1:10, 10^c(2,3,4)))
% dplot <- ggplot(subset(diamonds, color %in% c("D","E","G","J")), 
%   aes(carat, price, colour = color)) + 
%   scale_x_log10(breaks = xmajor, labels = xmajor, minor = xminor) + 
%   scale_y_log10(breaks = ymajor, labels = ymajor, minor = yminor) + 
%   scale_colour_hue(limits = levels(diamonds$color)) + 
%   opts(legend.position = "none")
%
% dplot + geom_point()
% dplot + geom_point() + facet_grid(. ~ color)
% 
% dplot + geom_smooth(method = lm, se=FALSE)
% dplot + geom_smooth(method = lm, se=FALSE) + facet_grid(. ~ color)
\input{_include/49a216405f6ffd8199d2c6010a9194b7.tex}
% END

\subsection{Dodging vs facetting}
\label{sub:dodge-vs-facet}

Facetting can achieve similar effects to dodging.  Figure~\ref{fig:fvd-crossed} shows how dodging and facetting can create plots that look remarkably similar.  The main difference is the labelling: the facetted plot has colour labelled above and cut below; and the dodged below colour below and cut is not explicitly labelled.  Here example the labels in the facetted plot are excessive and very cramped.  

% FIGURE
%   LABEL: fvd-crossed
%   COL: 1 GG-WIDTH: 10 TEX-WIDTH: 0.8\textwidth
%   CAPTION: Dodging (top) vs faceting (bottom) for a completely crossed
%   pair of variables.
% 
% qplot(color, data=diamonds, geom="bar", fill=cut, position="dodge")
% qplot(cut,   data=diamonds, geom="bar", fill=cut, position="dodge", 
%   facets = . ~ color)
\input{_include/c25f859c44744cc781e987610760d7b3.tex}
% END

Apart from labelling, the main differences between dodging and facetting when the two variables are not completely crossed, but there are some combinations that do not occur.  In this case, dodging becomes less useful because it only splits up the bar locally, and there are no labels.  Facetting is more useful as we can control the whether the splitting is local (\code{scales = "free_x"}, \code{space = "free"}) or global (\code{scales = "fixed"}).  Figure~\ref{fig:fvd-nested} compares facetting and dodging for two nested variables from the \code{mpg} dataset: model and manufacturer.

In summary, the choice between facetting and dodging depends on the relationship between the two variables:

\begin{itemize}
  \item Completely crossed: facetting and dodging and basically equivalent.

  \item Almost crossed: facetting with shared scales ensures that all combinations are visible, even if empty.

  \item Nested: facetting with free scales and space allocates just enough space for each higher level group, and labels each item individually.
\end{itemize}

% FIGURE
%   LABEL: fvd-nested
%   COL: 1 GG-WIDTH: 10 TEX-WIDTH: 0.8\textwidth
%   CAPTION: For nested data, there is a clear advantage to facetting (top
%   and middle) compared to dodging (bottom), because it is possible to 
%   carefully control and label the facets.  For this example, the middle
%   plot is not useful, but it will be useful in situations where the data
%   is almost crossed, i.e.\ where a single combination is missing.
% 
% mpg2 <- subset(mpg, manufacturer %in% c("audi", "volkswagen", "jeep"))
% qplot(model, data=mpg2, fill=model, geom="bar") + 
%   facet_grid(. ~ manufacturer) + opts(legend.position = "none")
% last_plot() + 
%   facet_grid(. ~ manufacturer, scales = "free_x", space = "free")
% qplot(manufacturer, data=mpg2, fill=model, geom="bar", position="dodge")
\input{_include/8525de03e5ada38c4dd3433a04cbbd1f.tex}
% END

\subsection{Continuous variables}\label{sub:continuous_variables}

You facet by continuous variables, but usually you will want to discretise them in some way first.  You have two options here:

\begin{itemize}
  \item Have each facet show an equal range or an equal number of points.  A fixed range is easy to interpret, but may produce plots with wildly varying contents; a fixed bin size will make it easier to compare facets, but will not produce ``pretty'' ranges.  Often it will be is impossible to divide into exactly the same number of points: if (e.g.) the number of rows is prime, or there are duplicated values in variable.
    
  \item Specify the number of bins, or the ``width'' of each bin (either the number of points or the range it should occupy).  Generally, specifying the width will be more interpretable, but will require a little more work.
  
\end{itemize}

The facetting formula only works with variables in the data set (not functions of the variables), so you will also need to save your new variable to the data set.

% INTERWEAVE
% 
% mpg$disp_r <- round_any(mpg$displ, 1)
% qplot(cty, hwy, data = mpg, facets =  ~ disp_r)
% 
% mpg$disp_r <- round_any(rank(mpg$displ), 40, floor)
% table(mpg$disp_r)
% qplot(cty, hwy, data = mpg, facets =  ~ disp_r)
% 
% mpg$disp_r <- chop(mpg$displ, 6)
% qplot(cty, hwy, data = mpg, facets =  ~ disp_r)
% 
% mpg$disp_r <- chop(mpg$displ, 6, method="cut")
% qplot(cty, hwy, data = mpg, facets =  ~ disp_r)
\input{_include/497b3e29df8123feaba9defb047d65e8.tex}
% END


\section{Coordinate systems}
\label{sec:coord}

Coordinate systems tie together the position scales to produce a 2d location. Currently, \ggplot comes with six different coordinate systems, listed in Table~\ref{tbl:cord}.  All these coordinate systems are two dimensional, although one day I hope to add 3d graphics too. As with the other components in ggplot2, you generate the R name by joining \code{coord_} and the name of the coordinate system.  Most plots use the default Cartesian coordinate system, \f{coord_cartesian}, where the 2d position of an element is given by the combination of the x and y positions.  

Coordinate systems have two main jobs: 

\begin{itemize}
  \item Combine the two position aesthetics to produce a 2d position on the plot.  The position aesthetics are called \code{x} and \code{y}, but they might be better called position 1 and 2 because their meaning depends on the coordinate system used.  For example, with the polar coordinate system they become radius and angle, and with maps they become latitude and longitude
  
  \item In coordination with the facetter, draw axes and panel backgrounds.  While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system which actually draws them.  This is because their appearance depends on the coordinate system: an angle axis looks quite different to an x axis.  The coordinate system must work together with the facetting system so that 

\end{itemize}

% source("latex.r")
% describe(Coord)

\begin{table}
  \begin{center}
  \begin{tabular}{ll}
    \toprule
    Name      & Description  \\
    \midrule
    cartesian & Cartesian coordinates                  \\
    equal     & Equal scale Cartesian coordinates      \\
    flip      & Flipped Cartesian coordinates          \\
    trans     & Transformed Cartesian coordinate system\\[1em]
    map       & Map projections                        \\
    polar     & Polar coordinates                      \\
    \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{Coordinate systems available in ggplot.  \code{coord_equal}, \code{coord_flip} and \code{coord_trans} are all basically Cartesian in nature (i.e.\ the the dimensions combine orthogonally), while \code{coord_map} and \code{coord_polar} are more complex.}
  \label{tbl:coord}
\end{table}

\subsection{Transformation}
\label{sub:coord-transformation}

Unlike transforming the data or transforming the scales, transforming the data with the coordinate system change the appearance of the grob: in polar coordinates a rectangle becomes a slice of a doughnut; in a map projection, the shortest path between two points will no longer be a straight line.  Figure~\ref{fig:coord-trans-examples} illustrate what happens to a line and a rectangle in each of the different coordinate systems.

% FIGURE
%   LABEL: coord-trans-examples
%   GG-WIDTH: 3  GG-HEIGHT: 3 COL: 4
%   TEX-WIDTH: 0.25\textwidth
%   CAPTION: A set of examples illustrating what a line and rectangle
%   look like when displayed in a variety of coordinate systems.
% 
% rect <- data.frame(x = 0.5, y = 0.5)
% line <- data.frame(x = c(0,2), y = c(1, 0))
% base <- ggplot(mapping = aes(x, y)) + 
%   geom_tile(data = rect, aes(width = 0.5, height = 0.5)) + 
%   geom_line(data = line)
% base
% base + coord_polar("x")
% base + coord_polar("y")
% base + coord_flip()
% base + coord_transform(y = "log10")
% base + coord_equal()
\input{_include/18e8c24958f910178a29d15a76de131c.tex}
% END

This transformation takes part in two steps.  Firstly, the parameterisation of each geom is changed purely location based, rather than location + dimension.  For example, a bar can be represented as an x position, a height and a width.  But how do we interpret height and width in a non-Cartesian coordinate system, where height and width may not be constant?  We solve the problem by using these measurements to give locations in Cartesian space, and then transforming these locations to new locations in the non-Cartesian space.  A rectangle is converted to a polygon parameterised by the positions of the four corners.  This because dimension is difficult to interpret in non-Cartesian coordinate systems.  This allows all geoms to be converted to points, lines and polygons.  

The next step is munching.  The only shape that is invariant under transformation is a point.  How can we convert more complex geoms like lines and polygons?  The basic assumption is that all coordinate transformations are smooth, in the sense that all very short lines will still be linear in the new coordinate system.  This process is called munching: every straight line is munched up into many smaller straight lines.  Figure~\ref{coord-trans} illustrates this procedure.  We start with a line determined by points, then break it done into multiple line segments.  Those points are translated into the new coordinate system, and then connected up again.  In the example, the number of line segments is to be too small, so you can see more easily how it works.  For real use, the number is much large so that the result looks smooth.

% FIGURE
%   LABEL: coord-trans
%   COL: 3 TEX-WIDTH: 0.33\textwidth
%   CAPTION: How coordinate transformations work: converting a line in 
%   Cartesian coordinates to a line in polar coordinates. 
% 
% r_grid <- seq(0, 1, length = 15)
% theta_grid <- seq(0, 3 / 2 * pi, length = 15)
% extents <- data.frame(r = range(r_grid), theta = range(theta_grid))
% base <- ggplot(extents, aes(r, theta)) + opts(aspect.ratio = 1) +
%   scale_y_continuous(expression(theta))
%
% base + geom_point(colour = "red", size = 2) + geom_line()
% pts <- data.frame(r = r_grid, theta = theta_grid)
% base + geom_line() + geom_point(data = pts)
% base + geom_point(data = pts)
% 
% xlab <- scale_x_continuous(expression(x == r * sin(theta)))
% ylab <- scale_y_continuous(expression(x == r * cos(theta)))
% polar <- base %+% pts + aes(x = r * sin(theta), y = r * cos(theta)) + 
%   xlab + ylab
% polar + geom_point()
% polar + geom_point() + geom_path()
% polar + geom_point(data=extents, colour = "red", size = 2) + geom_path() 
\input{_include/a916eb7b5fe67cb949efed7b0b5a04aa.tex}
% END

\subsection{Cartesian coordinate systems}
\label{sub:cartesian}

The four Cartesian based coordinate systems, \code{coord_cartesian}, \code{coord_equal}, \code{coord_flip} and \code{coord_trans} share a number of common features.  They are still essentially Cartesian because the x and y positions map orthogonally to x and y positions on the plot.  

\paragraph{Setting limits.}  The Cartesian coordinate system has arguments \code{xlim} and \code{ylim}.  If you think back to the scales chapter, you might wonder why we need these.  Doesn't the limits argument of the scales already allow use to control what appears on the plot?  The key difference is how the limits work: when setting scale limits, any data outside the limits is thrown away; but when setting coordinate system limits we still use all the data, but we only display a small region of the plot.  Setting coordinate system limits is like looking at the plot under a magnifying glass.  Figures~\ref{fig:limits-smooth} and~\ref{fig:limits-bin} show an example of this.

% FIGURE
%   COL: 3 TEX-WIDTH: 0.33\textwidth
%   LABEL: limits-smooth
%   CAPTION: Setting limits on the coordinate system, vs setting limits
%   on the scales.  Left, entire dataset; middle, x scale limits set to 
%   (325, 500); right, coordinate system x limits set to (325, 500).  Scaling
%   the coordinate limits performs a visual zoom, while setting the scale
%   limits subsets the data and refits the smooth.
% 
% (p <- qplot(disp, wt, data=mtcars) + geom_smooth())
% p + scale_x_continuous(limits = c(325, 500))
% p + coord_cartesian(xlim = c(325, 500))
\input{_include/522fd50a089b1581f7479ed34ab96775.tex}
% END

% FIGURE
%   COL: 3 TEX-WIDTH: 0.33\textwidth
%   LABEL: limits-bin
%   CAPTION: Setting limits on the coordinate system, vs setting limits
%   on the scales.  Left, entire dataset; middle, x scale limits set to 
%   (0, 2); right, coordinate x limits set to (0, 2).  Compare the size of 
%   the bins: when you set the scale limits, there is the same number of bins
%   but they each cover a smaller region of the data; when you set the
%   coordinate limits, there are fewer bins and they cover the same amount of
%   data as the original.
% 
% (d <- ggplot(diamonds, aes(carat, price)) + 
%   stat_bin2d(bins = 25, colour="grey50") + opts(legend.position = "none")) 
% d + scale_x_continuous(limits = c(0, 2))
% d + coord_cartesian(xlim = c(0, 2))
\input{_include/fe491db973f77458fd448aaba833f152.tex}
% END

\paragraph{Flipping the axes.}  Most statistics and geoms assume you are interested in y values conditional on x values (e.g.\ smooth, summary, boxplot, line).  If you are interested in x condition on y (or you just want to rotate the plot 90 degrees), you can use \code{coord_flip} to exchange the x and y axes.  Compare this with just exchanging the variables mapped to x and y

% FIGURE
%   COL: 3 TEX-WIDTH: 0.33\textwidth
%   LABEL: coord-trans
%   CAPTION: Left, a scatterplot and smoother with highway mpg on x axis, and 
%   city on y axis.  Middle, exchanging \var{cty} and \var{hwy} rotates the
%   plot 90 degrees, but the smooth is fit to the rotated data.  Left, using 
%   \code{coord_flip} fits the smooth to the original data, and then rotates
%   the output.
% 
% qplot(hwy, cty, data = mpg) + geom_smooth()
% qplot(cty, hwy, data = mpg) + geom_smooth()
% qplot(hwy, cty, data = mpg) + geom_smooth() + coord_flip()

\paragraph{Transformations.}  Like limits, we can also transform the data in two places: at the scale level or at the coordinate system level.  Transforming at the scale level occurs before statistics are computed and does not change the shape of the geom.  Transforming at the coordinate system level occurs after the statistics have been computed, and does affect the shape of the geom.  Using both together allows us to model the data on a transformed scale and then back transform it for interpretation: a common pattern in analysis.

% INTERWEAVE
%   FILETYPE: PNG
% 
% qplot(carat, price, data = diamonds, log = "xy") + 
%   geom_smooth(method = "lm")
% last_plot() + coord_trans(x = "pow10", y = "pow10")
\input{_include/7ffe994708722c39aab2577204a6b9d2.tex}
% END

\paragraph{Equal scales.}  Use \code{coord_equal} to ensure that the x and y axes have equal scales: i.e.\ 1 cm along the x axis represents the same range in the data as 1 cm along the y axis.  By default it will assume that you want a one-to-one mapping, but you can change this with the \code{ratio} parameter.  The aspect ratio will also be set to ensure that the mapping is maintained regardless of the shape of the output device.

\subsection{Non-Cartesian coordinate systems}

There are two non-Cartesian coordinates systems: polar coordinates and map projections.  These coordinate systems are still somewhat experimental, and there are fewer standards for the layout of axes, so you may need to tweak them to meet your needs using the tools in Chapter~\ref{cha:grid}.

\paragraph{Polar coordinates.}  Using polar coordinates gives rise to pie charts and wind roses (from bar geoms), and radar charts (from line geoms).  Polar coordinates are often used for circular data, particularly time or direction, but the perceptual properties are not good because the angle is harder perceive for small radii than it is for large radii.  The \code{theta} argument determines which position variable is mapped to angle (by default, x) and which to radius.  

\paragraph{Map projections.}  Uses the \code{mapproj} package \citep{mapproj} and \f{coord_map} takes the same arguments as \f{mapproj} for controlling the projection.  See the documentation for more examples, and consult a cartographer for the most appropriate projection for your data.

\input{_footer.tex}