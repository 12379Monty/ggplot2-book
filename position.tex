\input{_header.tex}
\chapter{Positioning}
\label{cha:position}

\section{Introduction}

Introduces ways of arranging small multiples, manipulating the coordinate system


\section{Faceting}\label{sec:faceting}

Faceting is discussed previous in XXX and XXX.  Here I will go into more detail, and provide more examples.  When specifying a faceting formula, you specify a grid of row and column variables.  Variables appearing on a row or column together, is like nesting, only combinations that appear in the data will appear in the plot.  If variables that are specified on rows and columns are crossed: all combinations will be shown, including those that didn't appear in the original data set.  

\subsection{Facet grid}

You can also specify margins to display, by giving the names of the variables you want margins for.  

% decumar<<< 
% interweave({
% str(smiths)
% })
% |||
%>>>

Currently, {\tt ggplot} doesn't make any distinction between structural and non-structural missings in the facets - you can't tell whether a combination did not appear in the original dataset, or if it had no data.  Dealing with this properly may require some extensions to R's missing value system.  

\subsection{Grouping vs. faceting}


\subsection{Facet wrap}

\subsection{Margins}\label{sub:margins}

Faceting a plot is like creating a contingency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics.  We can produce graphical margins using the the {\tt margins} argument.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex","age")}.  You can also use \verb|"grand_row"| or \verb|"grand_col"| to produce grand row and grand column margins respectively.

This example shows how the margins appear.  In the first plot, there are no margins, and we only see conditional plots.  In the second example, we see margins over columns, but not rows, and in the final example we see all possible margins.  The facet in the lower right corner displays all data points.

% decumar<<< 
% interweave({
% qplot(price, data=diamonds, facets= cut~ ., geom="histogram")
% })
% |||
\begin{alltt}
> qplot(price, data = diamonds, facets = cut ~ ., geom = "histogram")
\includegraphics[scale=0.5]{1a07c6d5903b310295255cfcfa587a9a}

\end{alltt}
% >>>

Plots with many facets and margins may be more appropriate for printing, rather than on screen display, as the higher resolution allows you to compare many more subsets.

\subsection{Continuous variables}\label{sub:continuous_variables}

To use continuous variables as faceting variables, you will first need to convert them to categorical.  Also, as the faceting formula currently does not support calculated variables, so you will need to save them in the data frame first.

{\tt ggplot} provides a convenient function for converting a continuous variable to a categorical variable: {\tt chop}.  Chop takes the following arguments:

\begin{itemize}
	\item {\tt x}: vector of numbers to chop up into categorical variable
	\item {\tt n}: number of bins to cut the variable into
	\item {\tt method}: method to use, equal ranges, equal numbers in each range or pretty ranges
\end{itemize}

The following examples shows the use of chop to explore the earthquakes data set.

% decumar<<< 
% ggopt(aspect.ratio = 1)
% interweave({
% quakes$depthc <- chop(quakes$depth)
% qplot(long, lat, . ~ depthc, data=quakes)
% quakes$magc <- chop(quakes$mag, n=6, method="pretty")
% qplot(long, lat, . ~ magc, data=quakes)
% })
% |||
% >>>

Breaking by quantiles, so that each facet has approximately the same number of points, is usually the best choice as it is easier to compare the facets because you know the same number of points are in each, even in the presences of overplotting.

\subsection{Missing faceting columns}\label{sub:missing_faceting_columsn}

If you facet on the original data set and add grobs with a new dataset, {\tt ggplot} follows some simple heuristics to try and do what you want.  

If the new dataset contains all of the faceting columns then each facet will have a specialised grob. If the new dataset contains none of the faceting columns, then each facet will use the same grob.  For anything in between, i.e. the new dataset contains some of the existing faceting columns, then the grobs will be duplicated over the faceting columns that are not present.  This sounds complicated, but most of the time it should do what you want.  If you need precise control, just make sure that every new dataset contains all the faceting columns used in the original dataset.

% decumar<<< 
% interweave({
% auckland <- data.frame(lat=-20 , lat=-25, long=175, label="Auck" )
% p <- ggpoint(ggplot(quakes, formula=. ~ depth, aes=list(x=lat, y=long)))
% ggtext(p, data=auckland, aes=list(label=label))
% })
% |||
% >>>  

\section{Coordinate systems}
\label{sec:coord}

\input{_footer.tex}