\input{_header.tex}
\chapter{Positioning}
\label{cha:position}

\section{Introduction}

Introduces ways of arranging small multiples, manipulating the coordinate system


\section{Coordinate systems}
\label{sec:coord}

99\% of the time we use a Cartesian coordinate system, where the 2d position of an element is made from the independent combination of the two.

Changing the coordinate system changes the appearance of the grob - a straight line maybe no longer be straight.  Illustrate with polar coordinates and coord\_trans.  

Similar to a scale, but inputs and outputs a tuple.

The only thing that is invariant under transformation is a point.  Assumption that coordinate transformations are smooth in some sense, so that very short lines will still be lines in the new coordinate system.

All coordinate systems are two dimensional.  Maybe 3d graphics one day.

Coordinate systems are the most complicated aspect of the grammar to get absolutely correct and many are still are work in progress.  However, do try them and out and report problems that you experience.


Coordinate systems are responsible for drawing the guides within the plot (i.e.\ grid lines) and 

\begin{table}
  \begin{center}
  \begin{tabular}{ll}
    \toprule
    Name      & Description  \\
    \midrule
    cartesian & Cartesian coordinates                  \\
    equal     & Equal scale cartesian coordinates      \\
    flip      & Flipped cartesian coordinates          \\
    map       & Map projections                        \\
    polar     & Polar coordinates                      \\
    trans     & Transformed cartesian coordinate system\\
    \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{Coordinate systems available in ggplot}
  \label{tbl:coord}
\end{table}

As with the other components in ggplot2, you generate the R name by joining {\tt coord\_} and the name of the coordinate system.  For example, the default Cartesian coordinate system is {\tt coord\_cartesian}.

Writing your own coordinate system is described in Section~\ref{sec:my_coord}.


\section{Faceting}
\label{sec:faceting}

Faceting can be thought of a special type of coordinate system, which is hierarchical.  At the top level we have a coordinate system created by the categorical variables that we are faceting by, and then within each of these regions another coordinate system generated by the x and y position of each graphic.

Faceting is discussed previous in XXX and XXX.  Here I will go into more detail, and provide more examples.  When specifying a faceting formula, you specify a grid of row and column variables.  Variables appearing on a row or column together, is like nesting, only combinations that appear in the data will appear in the plot.  If variables that are specified on rows and columns are crossed: all combinations will be shown, including those that didn't appear in the original data set.

Used to generate small multiples of the same plot for different subsets of the data.  Small multiples are a powerful tool for ...  

\subsection{Facet grid}

You can also specify margins to display, by giving the names of the variables you want margins for.  

% decumar<<< 
% interweave({
% str(smiths)
% })
% |||
%>>>

Currently, {\tt ggplot} doesn't make any distinction between structural and non-structural missings in the facets - you can't tell whether a combination did not appear in the original dataset, or if it had no data.  Dealing with this properly may require some extensions to R's missing value system.  


\subsubsection{Margins}\label{sub:margins}

Faceting a plot is like creating a contingency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics.  We can produce graphical margins using the the {\tt margins} argument.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex","age")}.  You can also use \verb|"grand_row"| or \verb|"grand_col"| to produce grand row and grand column margins respectively.

This example shows how the margins appear.  In the first plot, there are no margins, and we only see conditional plots.  In the second example, we see margins over columns, but not rows, and in the final example we see all possible margins.  The facet in the lower right corner displays all data points.

% decumar<<< 
% interweave({
% qplot(price, data=diamonds, facets= cut~ ., geom="histogram")
% })
% |||
\begin{alltt}
> qplot(price, data = diamonds, facets = cut ~ ., geom = "histogram")
\includegraphics[scale=0.5]{1a07c6d5903b310295255cfcfa587a9a}

\end{alltt}
% >>>

Plots with many facets and margins may be more appropriate for printing, rather than on screen display, as the higher resolution allows you to compare many more subsets.

\subsection{Facet wrap}
\label{sub:facet_wrap}

An alternative is facet wrap.  Instead of having a 2d grid generate by the combination of two (or more) variables, facet\_wrap essentially makes a long ribbon of panels and wraps it onto the screen.  

This is useful if you have a single variable that with many levels and want to arrange the plots in a more space efficient manner.

This is very similar to how trellising in lattice works.

\subsection{Controlling scales}
\label{sub:controlling_scales}

For both types of faceting you have some control over how the position scales work across plots.  There are two extremes.  One extreme is the default where all plots can share the same scale.  The other extreme is where each plot has it's own set of position scales.  

There also some intermediate levels of sharing:

\begin{itemize}
  \item shared
  \item individual
  \item rows-columns: each row has its own horizontal scale, and each column has its own vertical scale (facet\_grid only)
  \item variable: each plot has its own scale, but they are sizes so that the mapping between the plot and the data is the same in every panel (facet\_wrap only.)
\end{itemize}



\subsection{Missing faceting columns}\label{sub:missing_faceting_columsn}

If you facet on the original data set and add grobs with a new dataset, {\tt ggplot} follows some simple heuristics to try and do what you want.  

If the new dataset contains all of the faceting columns then each facet will have a specialised grob. If the new dataset contains none of the faceting columns, then each facet will use the same grob.  For anything in between, i.e. the new dataset contains some of the existing faceting columns, then the grobs will be duplicated over the faceting columns that are not present.  This sounds complicated, but most of the time it should do what you want.  If you need precise control, just make sure that every new dataset contains all the faceting columns used in the original dataset.

% decumar<<< 
% interweave({
% auckland <- data.frame(lat=-20 , lat=-25, long=175, label="Auck" )
% p <- ggpoint(ggplot(quakes, formula=. ~ depth, aes=list(x=lat, y=long)))
% ggtext(p, data=auckland, aes=list(label=label))
% })
% |||
% >>>  


\subsection{Grouping vs. faceting}

Faceting is an alternative to using aesthetics (like colour, shape or size) to distinguish different groups.  Each has strengths and weaknesses, centred around the distance between the groups.

With faceting, each group is quite far apart, in its own panel - there is no overlap between the groups.  This is good if the groups overlap a lot, but it does make small differences harder to see.  The groups are in the same panel when using aesthetics, so may overlap, but otherwise small differences are easier to see.  Illustrated in Figure~\ref{fig:facet-vs-groups}

Faceting will also work with much larger number of groups, and because you can split in two dimensions, you can compare two variables simultaneously more easily than using two different aesthetics (conjunctions are not preattentive).

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.19\textwidth]{position-fvg-1}
    \includegraphics[width=0.79\textwidth]{position-fvg-2}

    \includegraphics[width=0.19\textwidth]{position-fvg-3}
    \includegraphics[width=0.79\textwidth]{position-fvg-4}
  \caption{caption}
  \label{fig:facet-vs-groups}
\end{figure}


% \subsection{Continuous variables}\label{sub:continuous_variables}
% 
% To use continuous variables as faceting variables, you will first need to convert them to categorical.  Also, as the faceting formula currently does not support calculated variables, so you will need to save them in the data frame first.
% 
% {\tt ggplot} provides a convenient function for converting a continuous variable to a categorical variable: {\tt chop}.  Chop takes the following arguments:
% 
% \begin{itemize}
%   \item {\tt x}: vector of numbers to chop up into categorical variable
%   \item {\tt n}: number of bins to cut the variable into
%   \item {\tt method}: method to use, equal ranges, equal numbers in each range or pretty ranges
% \end{itemize}
% 
% The following examples shows the use of chop to explore the earthquakes data set.
% 
% % decumar<<< 
% % ggopt(aspect.ratio = 1)
% % interweave({
% % quakes$depthc <- chop(quakes$depth)
% % qplot(long, lat, . ~ depthc, data=quakes)
% % quakes$magc <- chop(quakes$mag, n=6, method="pretty")
% % qplot(long, lat, . ~ magc, data=quakes)
% % })
% % |||
% % >>>
% 
% Breaking by quantiles, so that each facet has approximately the same number of points, is usually the best choice as it is easier to compare the facets because you know the same number of points are in each, even in the presences of overplotting.

\input{_footer.tex}