---
title: position
output: bookdown::html_chapter
bibliography: references.bib
---

```{r position, include = FALSE}
source("common.R")
```

# Positioning {#cha:position}

## Introduction

This chapter discusses position, particularly how facets are laid out on a page, and how coordinate systems within a panel work. There are four components that control position.  You have already learned about two of them that work within a facet: \index{Positioning}

* __Position adjustments__ adjust the position of overlapping objects 
  within a layer These are most useful for bar and other interval geoms, but 
  can be useful in other situations ([link to section](#sec:position)).
  
* __Position scales__ control how the values in the data are mapped to 
  positions on the plot. Common transformations are linear and log, but 
  any other invertible function can also be used 
  ([link to section](#sub:scale-position)).

This chapter will describe the other two components and show you how all four components can be used together:

* __Faceting__ is a mechanism for automatically laying out multiple plots 
  on a page.  It splits the data into subsets, and then plots each subset 
  into a different panel on the page.  Such plots are often called 
  small multiples ([link to section](#sec:faceting)).
  
* __Coordinate systems__ control how the two independent position scales 
  are combined to create a 2d coordinate system.  The most common 
  coordinate system is Cartesian, but other coordinate systems can be useful 
  in special circumstances ([link to section](#sec:coord)).

## Faceting {#sec:faceting}

You first encountered faceting in [getting started](#sec:qplot-faceting) and you may already have been using it in your plots. Faceting generates small multiples each showing a different subset of the data. Small multiples are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different parts of the data and see whether they are the same or different. This section will discuss how you can fine-tune facets, particularly the way in which they interact with position scales. \index{Faceting} \index{Positioning!faceting}

There are three types of faceting: 

* `facet_null()`: a single plot.

* `facet_wrap()` "wraps" a 1d ribbon of panels into 2d. 

* `facet_grid()`: produces a 2d grid of panels defined by variables which 
  form the rows and columns.

These differences are illustrated in Figure \ref{fig:facet-sketch}.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.5\linewidth]{diagrams/position-facets}
  \caption{A sketch illustrating the difference between the two faceting systems. \texttt{facet\_grid} (left) is fundamentally 2d, being made up of two independent components. \texttt{facet\_wrap} (right) is 1d, but wrapped into 2d to save space.}
  \label{fig:facet-sketch}
\end{figure}

There are two basic arguments to the faceting systems: the variables to facet by, and whether position scales should be global or local to the facet. The way these options are specified is a little different for the two systems, so they are described separately below.

Faceted plots have the capability to fill up a lot of space, so for this chapter we will use a subset of the mpg dataset that has a manageable number of levels: three cylinders (4, 6, 8) and two types of drive train (4 and f). This removes 29 vehicles from the original dataset.

```{r mpg2}
mpg2 <- subset(mpg, cyl != 5 & drv %in% c("4", "f"))
```

### Facet wrap {#sub:facet-wrap}

`facet_wrap()` makes a long ribbon of panels (generated by any number of variables) and wraps it into 2d.  This is useful if you have a single variable with many levels and want to arrange the plots in a more space efficient manner.  \index{Faceting!wrapped} \indexf{facet_wrap}

The most useful arguments to `facet_wrap()` are `ncol`, `nrow` and `as.table`. `ncol` and `nrow` control how many rows and columns (you only need to set one). By default, `facet_wrap()` will try to make `nrow` and `ncol` as similar as possible, with a slight bias towards wider rather than taller rectangles. `as.table` controls whether the facets are laid out like a table (`TRUE`) with highest values at the bottom-right, or a plot (`FALSE`), with the highest values at the top-right.

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  facet_wrap(~ class, nrow = 2)
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  facet_wrap(~ class, nrow = 2, as.table = FALSE)
```

### Facet grid

The grid faceter lays out plots in a 2d grid. When specifying a faceting formula, you specify which variables should appear in the columns and which should appear in the rows:  \index{Faceting!grid} \indexf{facet_grid}

*  `. ~ a`: A single row with multiple columns. This is normally the most 
   useful direction because computer screens are usually wider than they are 
   long. This direction of faceting facilitates comparisons of y position,
   because the vertical scales are aligned.

    `r columns(1, 1 / 2, 1)`
    ```{r mpg2-grid}
    ggplot(mpg2, aes(displ, hwy)) + 
      geom_point() +
      facet_grid(. ~ cyl)
    ```
  
*   `b ~ .`: A single column with multiple rows. This direction facilitates
    comparison of x position because the horizontal scales are aligned. This
    makes it particularly useful for comparing distributions:

    ```{r mpg2-hist}
    ggplot(mpg2, aes(cty)) + 
      geom_histogram(binwidth = 2) +  
      facet_grid(cyl ~ .)
    ```

*   `a ~ b`: Multiple rows and columns.  You'll usually want to put the 
    variable with the greatest number of levels in the columns, to take 
    advantage of the aspect ratio of your screen.

    ```{r mpg2-grid-both}
    ggplot(mpg2, aes(displ, hwy)) + 
      geom_point() +
      facet_grid(drv ~ cyl)
    ```

You can use multiple variables in the rows or columns, by "adding" them together, e.g. `a + b ~ c + d`. 

Variables appearing together on the rows or columns are nested in the sense that only combinations that appear in the data will appear in the plot. Variables that are specified on rows and columns will be crossed: all combinations will be shown, including those that didn't appear in the original dataset: this may result in empty panels.

### Controlling scales {#sub:controlling-scales}

For both types of faceting you can control whether the position scales are the same in all panels (fixed) or allowed to vary between panels (free). This is controlled by the `scales` parameter: \index{Faceting!interaction with scales} \index{Scales!interaction with facetting} \index{Faceting!controlling scales}

* `scales = "fixed"`: x and y scales are fixed across all panels.
* `scales = "free"`: x and y scales vary across panels.
* `scales = "free_x"`: the x scale is free, and the y scale is fixed.
* `scales = "free_y"`: the y scale is free, and the x scale is fixed.

```{r fixed-vs-free}
p <- ggplot(mpg2, aes(cty, hwy)) + 
  geom_abline() +
  geom_point() 
p + facet_wrap(~cyl)
p + facet_wrap(~cyl, scales = "free")
```

Fixed scales allow us to compare subsets, seeing where each panel fits into the overall pattern. Free scales zoom in on each panel, making it easier to see differences within a panel, but hard to compare panels. 

Free scales are also useful when we want to display multiple times series that were measured on different scales. To do this, we first need to change from 'wide' to 'long' data, stacking the separate variables into a single column.  An example of this is shown below, and the topic is discussed in more detail in [converting data from wide to long](#sec:melting).

`r columns(1, 1, 0.75)`
```{r time}
em <- economics %>% tidyr::gather(variable, value, -date)
em
ggplot(em, aes(date, value)) + 
  geom_line() + 
  facet_wrap(~variable, scales = "free_y", ncol = 1)
```

There is an additional constraint on the scales of `facet_grid()`: all panels in a column must have the same x scale, and all panels in a row must have the same y scale. This is because each column shares an x axis, and each row shares a y axis.

For `facet_grid()` there is an additional parameter called `space`, which takes values `"free"` or `"fixed"`.  When the space can vary freely, each column (or row) will have width (or height) proportional to the range of the scale for that column (or row).  This makes the scaling equal across the whole plot: 1 cm on each panel maps to the same range of data.  (This is somewhat analogous to the 'sliced' axis limits of lattice.)  For example, if panel a had range 2 and panel b had range 4, one-third of the space would be given to a, and two-thirds to b.  This is most useful for categorical scales, where we can assign space proportionally based on the number of levels in each facet, as illustrated below.

```{r discrete-free}
mpg2$model <- reorder(mpg2$model, mpg2$cty)
mpg2$manufacturer <- reorder(mpg2$manufacturer, -mpg2$cty)
ggplot(mpg2, aes(cty, model)) + 
  geom_point() + 
  facet_grid(manufacturer ~ ., scales = "free", space = "free") +
  theme(strip.text.y = element_text(angle = 0))
```

### Missing faceting variables {#sub:missing-faceting-columns}

If you are using faceting on a plot with multiple datasets, what happens when one of those datasets is missing the faceting variables? This situation commonly arises when you are adding contextual information that should be the same in all panels. For example, imagine you have a spatial display of disease faceted by gender. What happens when you add a map layer that does not contain the gender variable?  Here ggplot will do what you expect: it will display the map in every facet: missing faceting variables are treated like they have all values. \index{Faceting!missing data}

### Grouping vs. faceting {#sub:group-vs-facet}

Faceting is an alternative to using aesthetics (like colour, shape or size) to differentiate groups. Both techniques have strengths and weaknesses, based around the relative positions of the subsets.  \index{Faceting!vs. grouping} \index{Grouping!vs. faceting}

With faceting, each group is quite far apart in its own panel, and there is no overlap between the groups. This is good if the groups overlap a lot, but it does make small differences harder to see. When using aesthetics to differentiate groups, the groups are close together and may overlap, but small differences are easier to see. 

A particularly challenging example is 


With the scatterplots, it is possible to not realise the groups are overlapping when just colour is used to separate them, but with the regression lines they are too far apart to see that D, E and G are grouped together and J is farther away.  The code to produce these figures is shown below.

`r columns(1)`
```{r group-vs-facet, dev='png'}
dplot <- ggplot(diamonds, aes(carat, price)) + 
  scale_x_log10() + 
  scale_y_log10() +
  theme(legend.position = "none")

dplot + 
  geom_point(aes(colour = cut))

dplot + 
  geom_point() +
  facet_wrap(~ cut, nrow = 1)

lm_coef <- coef(lm(log10(price) ~ log10(carat), data = diamonds))
dplot + 
  geom_point() +
  geom_abline(intercept = lm_coef[1], slope = lm_coef[2]) + 
  facet_wrap(~ cut, nrow = 1)
```

Faceting will also work with a much larger number of groups, and because you can split in two dimensions, you can compare two variables simultaneously more easily than using two different aesthetics.  The other advantage of faceting is that the scales can vary across panels, which is useful if the subsets occupy very different ranges.

### Dodging vs. faceting {#sub:dodge-vs-facet}

Faceting can achieve similar effects to dodging. Figure \ref{fig:fvd-crossed} shows how dodging and faceting can create plots that look remarkably similar. The main difference is the labelling: the faceted plot has colour labelled above and cut below; and the dodged plot has colour below and cut is not explicitly labelled. In this example, the labels in the faceted plot need some adjustment to display in a readable way, see the code below for details. \index{Dodging!vs. faceting} \index{Faceting!vs. dodging}  \indexf{geom_bar}

```{r fvd-crossed}
ggplot(diamonds, aes(color)) + 
  geom_bar(aes(fill = cut), position = "dodge") +
  theme(legend.position = "none")

ggplot(diamonds, aes(cut)) + 
  geom_bar(aes(fill = cut)) + 
  facet_wrap(~color, nrow = 1) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, colour = "grey50"),
    legend.position = "none"
  )
```

Apart from labelling, the main difference between dodging and faceting occurs when the two variables are nearly completely crossed, but there are some combinations that do not occur. In this case, dodging becomes less useful because it only splits up the bars locally, and there are no labels. Faceting is more useful as we can control whether the splitting is local (`scales = "free_x"`, `space = "free"`) or global (`scales = "fixed"`). Figure \ref{fig:fvd-nested} compares faceting and dodging for two nested variables from the `mpg` dataset, model and manufacturer, with the code shown below.

`r columns(1, 1/3, 0.8)`
```{r fvd-nested}
mpg4 <- subset(mpg, manufacturer %in% c("audi", "volkswagen", "jeep"))
# Not useful here, but will be in situations where the data is almost crossed, 
# i.e. where a single combination is missing.
ggplot(mpg4, aes(manufacturer, fill = model)) + 
  geom_bar(position = "dodge") + 
  theme(legend.position = "none") 

ggplot(mpg4, aes(model, fill = model)) + 
  geom_bar(position = "dodge") + 
  facet_grid(. ~ manufacturer) +
  theme(legend.position = "none")

ggplot(mpg4, aes(model, fill = model)) + 
  geom_bar(position = "dodge") + 
  facet_grid(. ~ manufacturer, scales = "free_x", space = "free") +
  theme(legend.position = "none")
```

In summary, the choice between faceting and dodging depends on the relationship between the two variables:

* Completely crossed: faceting and dodging are equivalent, apart from labelling.

* Almost crossed: faceting with shared scales ensures that all combinations 
  are visible, even if empty. This is particularly useful if missing 
  combinations are non-structural missings.
  
* Nested: faceting with free scales and space allocates just enough space 
  for each higher level group, and labels each item individually.

### Continuous variables {#sub:continuous-variables}

You can facet by continuous variables, but you will need to convert them into discrete categories first. There are three ways to do this: \index{Faceting!by continuous variables}

* Divide the data into `n` bins each of the same length: `cut_interval(x, n)`
  \indexf{cut_interval}
  
* Divide the data into bins of width `width`: `cut_width(x, width)`.
  \indexf{cut_width}
  
* Divide the data into n bins each containing (approximately) the same 
  number of points: `cut_number(x, n = 10)`.  \indexf{cut_number}

Note that the faceting formula only works with variables in the dataset (not functions of the variables), so you must first create a new variable containing the discretised data.

`r columns(1, 1/4, 1)`
```{r discretising}
# Bins of width 1
mpg2$disp_w <- cut_width(mpg2$displ, 1)
# Six bins of equal length
mpg2$disp_i <- cut_interval(mpg2$displ, 6)
# Six bins containing equal numbers of points
mpg2$disp_n <- cut_number(mpg2$displ, 6)

plot <- ggplot(mpg2, aes(cty, hwy)) +
  geom_point() +
  labs(x = NULL, y = NULL)
plot + facet_wrap(~disp_w, nrow = 1)
plot + facet_wrap(~disp_i, nrow = 1)
plot + facet_wrap(~disp_n, nrow = 1)
```

## Coordinate systems {#sec:coord}

Coordinate systems tie together the two position scales to produce a 2d location. Currently, ggplot comes with six coordinate systems:

* `coord_cartesian()`: the default Cartesian coordinate system, 
  where the 2d position of an element is given by the combination of the x and
  y positions.  

the most common type of coordinate system. on a scale will.

* `coord_fixed()`: Cartesian coordinate system with a fixed aspect ratio.

* `coord_flip()`: Cartesian coordinate system with x and y axes flipped. 

* `coord_map()`/`coord_quickmap()`: Map projections.

* `coord_polar()`: Polar coordinates.

* `coord_trans()`: Apply arbitrary transformations to x and y positions,
  after the data has been processed by the stat.

Coordinate systems have two main jobs: 

* Combine the two position aesthetics to produce a 2d position on the plot.
  The position aesthetics are called `x` and `y`, but they might be better 
  called position 1 and 2 because their meaning depends on the coordinate 
  system used. For example, with the polar coordinate system they become angle 
  and radius (or radius and angle), and with maps they become latitude and 
  longitude.

* In coordination with the faceter, coordinate systems draw axes and panel
  backgrounds. While the scales control the values that appear on the axes, and
  how they map from data to position, it is the coordinate system which 
  actually draws them. This is because their appearance depends on the 
  coordinate system: an angle axis looks quite different than an x axis. 


### Setting limits

`coord_cartesian()` has arguments `xlim` and `ylim`.  If you think back to the scales chapter, you might wonder why we need these.  Doesn't the limits argument of the scales already allow us to control what appears on the plot?  The key difference is how the limits work: when setting scale limits, any data outside the limits is thrown away; but when setting coordinate system limits we still use all the data, but we only display a small region of the plot. Setting coordinate system limits is like looking at the plot under a magnifying glass.

`r columns(3, 1)`
```{r limits-smooth}
base <- ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth()

# Full dataset
base
# Scaling to 5--7 throws away data outside that range
base + scale_x_continuous(limits = c(5, 7))
# Zooming to 5--7 keeps all the data but only shows some of it
base + coord_cartesian(xlim = c(5, 7))
```

## Linear coordinate systems {#sub:cartesian}

There are three linear coordinate systems: `coord_cartesian()`, `coord_equal()`, `coord_flip()`. \index{Coordinate systems!Cartesian} \indexf{coord_cartesian}

## Flipping the axes with `coord_flip()`

Most statistics and geoms assume you are interested in y values conditional on x values (e.g., smooth, summary, boxplot, line): in most statistical models, the x values are assumed to be measured without error.  If you are interested in x conditional on y (or you just want to rotate the plot 90 degrees), you can use `coord_flip()` to exchange the x and y axes.  Compare this with just exchanging the variables mapped to x and y: \index{Rotating} \index{Coordinate systems!flipping the axes} \indexf{coord_flip}

```{r coord-flip}
ggplot(mpg, aes(displ, cty)) + 
  geom_point() + 
  geom_smooth()
# Exchanging cty and displ rotates the plot 90 degrees, but the smooth 
# is fit to the rotated data.
ggplot(mpg, aes(cty, displ)) + 
  geom_point() + 
  geom_smooth()
# coord_flip() fits the smooth to the original data, and then rotates 
# the output
ggplot(mpg, aes(displ, cty)) + 
  geom_point() + 
  geom_smooth() + 
  coord_flip()
```

### Equal scales with `coord_equal()`

`coord_equal()` fixes the ratio of length on the x and y axes. The default `ratio`, ensures that the x and y axes have equal scales: i.e., 1 cm along the x axis represents the same range of data as 1 cm along the y axis. The aspect ratio will also be set to ensure that the mapping is maintained regardless of the shape of the output device.  See the documentation of `coord_equal()` for more details. \index{Aspect ratio} \index{Coordinate systems!Equal scales} \indexf{coord_equal}

## Non-linear coordinate systems

There are two non-Cartesian coordinate systems: polar coordinates and map projections. Unlike linear coordinates, non-linear coordinates can change the shape of geoms. For example, in polar coordinates a rectangle becomes a slice of a doughnut; in a map projection, the shortest path between two points is not necessarily a straight line.The code below shows how a line and a rectangle are rendered in a few different coordinate systems. \index{Transformation!coordinate system} \index{Coordinate systems!non-linear}

`r columns(3, 1)`
```{r coord-trans-examples,}
rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, height = 50)) + 
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)
base
base + coord_polar("x")
base + coord_polar("y")
base + coord_flip()
base + coord_trans(y = "log10")
base + coord_equal()
```

This transformation takes part in two steps. Firstly, the parameterisation of each geom is changed to be purely location-based, rather than location and dimension based. For example, a bar can be represented as an x position (a location), a height and a width (two dimensions). But how do we interpret height and width in a non-Cartesian coordinate system, where a rectangle may not have constant height and width? We solve the problem by using a purely location-based representation, the location of the four corners of the rectangle, and then transforming these locations: we have converted a rectangle to a polygon. By doing this, we effectively convert all geoms to a combination of points, lines and polygons. \index{Geoms!parameterisation} \index{Coordinate systems!transformation}

With all geoms in this consistent, location-based, representation, the next step is to transform each location into the new coordinate system. It is easy to transform points, because a point is still a point no matter what coordinate system you are in, but lines and polygons are harder, because a straight line may no longer be straight in the new coordinate system. To make the problem tractable we assume that all coordinate transformations are smooth, in the sense that all very short lines will still be very short straight lines in the new coordinate system. With this assumption in hand, we can transform lines and polygons by breaking them up into many small line segments and transforming each segment. This process is called munching and is illustrated below: \index{Munching}

1.  We start with a line parameterised by its two endpoints:
      
    `r columns(1, 1, 0.40)`
    ```{r}
    df <- data.frame(r = c(0, 1), theta = c(0, 3 / 2 * pi))
    ggplot(df, aes(r, theta)) + 
      geom_line() + 
      geom_point(size = 4, colour = "red")
    ```
    
1.  We break it into multiple line segments, each with two endpoints. 

    ```{r}
    interp <- function(rng, n) {
      seq(rng[1], rng[2], length = n)
    }
    munched <- data.frame(
      r = interp(df$r, 15),
      theta = interp(df$theta, 15)
    )

    ggplot(munched, aes(r, theta)) + 
      geom_line() + 
      geom_point(size = 4, colour = "red")
    ```

1.  We transform the locations of each piece:

    ```{r}
    transformed <- transform(munched,
      x = r * sin(theta),
      y = r * cos(theta)
    )

    ggplot(transformed, aes(x, y)) + 
      geom_path() + 
      geom_point(size = 4, colour = "red")
    ```

For practical use, we use many more segments so that the result looks smooth.


###  Transformations

Like limits, we can also transform the data in two places: at the scale level or at the coordinate system level. `coord_trans()` has arguments `x` and `y` which should be strings naming the transformer (see [continous position scales](#sub:scale-position)) to use for that axis. Transforming at the scale level occurs before statistics are computed and does not change the shape of the geom.  Transforming at the coordinate system level occurs after the statistics have been computed, and does affect the shape of the geom. Using both together allows us to model the data on a transformed scale and then backtransform it for interpretation: a common pattern in analysis. \index{Transformation!coordinate system} \index{Coordinate systems!transformation} \indexf{coord_trans}

```{r backtrans}
# Linear model on original scale is poor fit
base <- ggplot(diamonds, aes(carat, price)) + 
  geom_bin2d() + 
  geom_smooth(method = "lm") + 
  xlab(NULL) + ylab(NULL) + 
  theme(legend.position = "none")
base

# Better fit on log scale, but harder to interpret
base +
  scale_x_log10() + 
  scale_y_log10()

# Fit on log scale, then backtransform to original.
# Highlights lack of expensive diamonds with large carats
pow10 <- scales::exp_trans(10)
base +
  scale_x_log10() + 
  scale_y_log10() + 
  coord_trans(x = pow10, y = pow10)
```

### Polar coordinates

Using polar coordinates gives rise to pie charts and wind roses (from bar geoms), and radar charts (from line geoms). Polar coordinates are often used for circular data, particularly time or direction, but the perceptual properties are not good because the angle is harder to perceive for small radii than it is for large radii.  The `theta` argument determines which position variable is mapped to angle (by default, x) and which to radius.  Figure \ref{fig:polar} shows how by changing the coordinate system we can turn a bar chart into a pie chart or a bullseye chart. The documentation includes other examples of polar charts. \index{Polar coordinates} \index{Coordinate systems!polar} \indexf{coord_polar}

`r columns(3)`
```{r polar}
# Stacked barchart
(pie <- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
  geom_bar(width = 1))
# Pie chart
pie + coord_polar(theta = "y")

# The bullseye chart
pie + coord_polar()
```

### Map projections

These are still rather experimental, and rely on the **mapproj** package [@mapproj].  `coord_map()` takes the same arguments as `mapproj()` for controlling the projection.  See the documentation of `coord_map()` for more examples, and consult a cartographer for the most appropriate projection for your data. \index{Maps!projections} \index{Coordinate systems!map projections} \indexf{coord_map}

`coord_quickmap()` is similar to `coord_map()`, but it does the quickest and dirtiest approximation using only the aspect ratio. It sets the aspect ratio to ensure than 1m of latitude and 1 m of longitude are the same distance in the middle of the plot. If you know nothing more about maps, this is a reasonable place to start to get a decent looking map.

`r columns(3, 1)`
```{r}
# Prepare a map of NZ
nzmap <- ggplot(map_data("nz"), aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

# Plot it in cartesian coordinates
nzmap
# With correct mercator projection
nzmap + coord_map()
# With the aspect ratio approximation
nzmap + coord_quickmap()
```
