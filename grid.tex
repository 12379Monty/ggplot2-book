\input{_header.tex}

\chapter{Manipulating plot rendering with \code{grid}}
\label{cha:grid}

\section{Introduction}

% The are two ways to do this: common options are exposed by the {\tt ggopt} function, or you can use the grid package to modify the graphical output of ggplot.  The few options provided by {\tt ggopt} allow you to easily modify the most commonly tweaked parts of ggplot graphics, but for more control you can use the power of grid to delve into the dark depths of {\tt ggplot} and tweak to your heart's content.

What is \pkg{grid}?  It's the graphics engine that powers ggplot.  It is responsible for drawing the graphic object onto the screen or saving it to a graphics file.  It provides a system of viewports, which define regions on the plot, and a comprehensive set of units for describing size and position. This chapter can not hope to provide a comprehensive introduction to grid, but should hopefully provide enough examples to get you going.   I highly recommend the book ``R Graphics'' \citep{murrell:2005}, by the author of grid,  as a companion to this chapter.  If you can't get the book, at least read Chapter 5, ``The grid graphics model'', which is available online for free at  \url{http://www.stat.auckland.ac.nz/~paul/RGraphics/chapter5.pdf}.

The grobs (graphical objects) used in this chapter are a bit different to the geoms (geometric objects) used in previous chapters.  A grob is the object that is actually drawn onto the screen, while a geom is a more abstract object which describes the type of object used to draw a plot.  An example may make this more clear. In a line plot, the geom describes that the data should be visualised with a line, and the grobs draw the line itself, as well as the other lines that appear in the grid and axes.

The chapter begins with a discussion of the structure of viewports (\S \ref{sec:plot-viewports}) and grobs (\S \ref{sec:plot-grobs}) used by \ggplot, and then continues to describe the four principle ways to enhance a plot with grid:

\begin{itemize}
  \item Edit existing objects on the plot, \S \ref{sec:grid-existing}.
  \item Add annotations to the plot, \S \ref{sec:grid-new}.
  \item Removing grobs from a plot, \S \ref{sec:grid-delete}.
  \item Arrange multiple plots on a single page, \S \ref{sec:grid-layout}.
\end{itemize}

\section{Plot viewports}
\label{sec:plot-viewports}

Viewports define the basic regions of the plot.  The structure will vary slightly from plot to plot, depending on the type of faceting used, but the basics will remain the same. 

The {\tt panels} viewport contains the meat of the plot: strip labels, axes and faceted panels.  The viewports are named according to both their job and their position on the plot.  A prefix (listed below) describes the contents of the viewport, and is followed by integer x and y position (counting from bottom left) separated by ``\_''.  Figure~\ref{fig:panelvp} illustrates this naming scheme for a 2$\times$2 plot.

\begin{itemize}
  \item {\tt strip\_h}: horizontal strip labels
  \item {\tt strip\_v}: vertical strip labels
  \item {\tt axis\_h}: horizontal axes
  \item {\tt axis\_v}: vertical axes
  \item {\tt panel}: faceting panels
\end{itemize}

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.5 \textwidth]{grid-panelvp}
  \caption{Naming scheming of the panel viewports}
  \label{fig:panelvp}
\end{figure}

The \code{panels} viewport is contained inside the \code{background} viewport which also contains the following viewports:

\begin{itemize}
  \item \code{title}, \code{xlabel}, and \code{ylabel}: for the plot title, and x and y axis labels
  \item \code{legend_box}: for all of the legends for the plot
\end{itemize}

\noindent Figure~\ref{fig:viewports} labels a plot with a representative sample of these viewports.  To get a list of all viewports on the current plot, run \code{current.vpTree(all=TRUE)}.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=\textwidth]{grid-viewports.pdf}
  \caption{Diagram showing the structure and names of viewports.}
  \label{fig:viewports}
\end{figure}

\section{Plot grobs}
\label{sec:plot-grobs}

Grob names have three components: the name of the grob, the class of the grob, and a unique numeric suffix.  The three components are joined together with ``.'' to give a name like {\tt title.text.435} or {\tt ticks.segments.15}.  These three components ensure that all grob names are unique, and allow you to select multiple grobs with the same name at the same time.

You can see a list of all the grobs in the current plot with {\tt grid.ls()}.  If you only want to see the ggplot name of the grob, {\tt grid.ls(only.name=TRUE)} will reduce a lot of the output.  Here's an example after drawing the a simple plot:

\begin{alltt}
plot-surrounds::
 background
 plot::
  background
  guide:: (background, major-horizontal, major-vertical, 
           minor-horizontal, minor-vertical, border)
  xaxis::
   ticks
   labels:: (label, label, label, label, label, label, label, label)
  yaxis::
   ticks
   labels:: (label, label, label, label, label)
  geom_point
 ylabel
 xlabel
 title
\end{alltt}

Figure~\ref{fig:grobs} labels some of these grobs.  The grobs are arranged hierarchically, but it's hard to capture this in a diagram.

\begin{figure}[htbp]
  \centering
    \includegraphics[width=\textwidth]{grid-grobs}
  \caption{A selection of the most important grobs.  \code{geom_point}, \code{major-vertical} and \code{label} point to a single element of the grob.}
  \label{fig:grobs}
\end{figure}

The most important components are:

\begin{itemize}
  \item The geom displayed in the plot: {\tt geom\_point}.

  \item {\tt xaxis} and {\tt yaxis}, the axes, containing {\tt labels} and {\tt ticks}.

	\item Axis labels and title: {\tt xlabel}, {\tt ylabel}, {\tt title}.

  \item {\tt guide}, the internal guides within a panel (background, and grid lines)

\end{itemize}

\section{Editing existing objects on the plot}
\label{sec:grid-existing}

Most of the difficulty in modifying elements of the plot is figuring out what the grob you want to modify is called.  Once you have that you can use {\tt grid.gedit}, to locate and then modify that grob. 

To fully identify a grob, you need to use a \code{gPath}.  A gPath can either be a string specifying a single grob name, or a sequence of grob names that describe hierarchy to travel down to get to the grob of interest with the {\tt gPath} function.  Using a string will find all grobs with that name regardless of their position in the hierarchy.  For example, {\tt "label"} will find all grobs called label, regardless of where they are.  To be more specific, using {\tt gPath("parent", "child")} will only find grobs named ``child'' with a parent called ``parent''.  For example, {\tt gPath("xaxis", "label")} will locate only labels on the x-axis.

Modifying a grob requires some knowledge of the different parameters of the grob.  This is where the second part of the grob name is useful, as it will tell you whether you are modifying a line, or a rect or a text grob.  You can get more information by looking at the documentation for that grob, eg. {\tt ?grid.rect, ?grid.text, ?grid.lines}   As well as individual parameters, all grobs share a common set of graphical parameters described in Table \ref{tbl:gpar}. Appendix~\ref{cha:specifications} describes the values that these may take.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Grid parameter & \ggplot aesthetic &  Description \\
    \midrule
    lwd & size & Line width (in pts) \\
    col & colour & Border colour \\
    fill  & fill & Fill colour \\
    fontsize & size & Font size (in pts) \\
    fontface & --- & Font face (bold, italic, ...) \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Common graphical parameters for grid grobs.  Note that point size is controlled separately.}
  \label{tbl:gpar}
\end{table}

In this example, we edit the font of all labels.

\begin{alltt}
qplot(mpg, wt, data=mtcars, facets = . ~ cyl)
\includegraphics[width=0.5\textwidth]{grid1}
grid.gedit("label", gp=gpar(fontsize=14, col="red"))
\includegraphics[width=0.5\textwidth]{grid2}
\end{alltt}
% dev.save("_include/grid1.pdf")
% dev.save("_include/grid2.pdf")

To edit just one type of label, we need to use the hierarchy of grobs and the {\tt gPath} function:

\begin{alltt}
qplot(mpg, wt, data=mtcars, facets = . ~ cyl)
grid.gedit(gPath("strip","label"), gp=gpar(fontface="bold"))
\includegraphics[width=0.5\textwidth]{grid3}
grid.gedit(gPath("yaxis", "labels"), gp=gpar(col="red"))
\includegraphics[width=0.5\textwidth]{grid4}
\end{alltt}

\section{Removing grobs}
\label{sec:grid-delete}

You can use \f{grid.remove} to completely remove a grob.  However, the space it takes up will remain there:

\begin{alltt}
qplot(mpg, wt, data=mtcars, facets = . ~ cyl)
grid.gremove(gPath("strip", "background"))
grid.gremove(gPath("guide", "background"))
grid.gremove("major")
grid.gremove("axis")
\end{alltt}

You can use an alternative method to remove top level viewports.  There are plot-level options \code{keep} and \code{drop}, which specify which viewports to keep or drop respectively.  For example:

\begin{lstlisting}
p <- qplot(mpg, wt, data=mtcars, main = "My plot")
p + opts(keep = "panel")
p + opts(ignore = c("xlabel", "ylabel"))
\end{lstlisting}

\section{Adding annotations}\label{sec:adding_annotation}
\label{sec:grid-new}

Many annotations can be done with {\tt geom\_text}, {\tt geom\_abline}, {\tt geom\_vline} and {\tt geom\_hline}, so try those first.  If you need more flexibility you can add annotations with grid.  When you add annotations to a plot you need to specify where they will appear.  In grid this is described by a system of viewports.  Different viewports describe different regions of output on the plot, for example, the axes, the plotting region and the faceting strips.

To add annotations to a plot you have to specify the viewport when you add extra grobs.  For example:

\begin{lstlisting}[language = R]
qplot(wt, mpg, data=mtcars, colour=cyl)
grid.circle(vp="layout::panel_1_1")
\end{lstlisting}

Panel viewports will have a coordinate system set up for points, while x- and y- axes will only have one dimension defined.  For example, on the x-axis there will be native coordinates for the x-dimension, but not the y-dimension.

\begin{lstlisting}[language = R]
qplot(wt, mpg, data=mtcars, colour=cyl)
grid.lines(x=unit(c(0,1), "npc"), y=unit(23, "native"), vp="layout::panel_1_1")
grid.lines(x=unit(c(0,1), "npc"), y=unit(23, "native"), vp="layout::axis_v_1_1")
\end{lstlisting}



\section{Customising layout}
\label{sec:grid-layout}

By default, showing a {\tt ggplot} object at the R command prompt will display to the screen.  To exercise more control, you can call {\tt print} explicitly.  This section describes some of the things you can do.  For more details see {\tt ?print.ggplot} and {\tt ?ggplot\_print}.

If you just want the plot (no labels, titles or legends) you can use {\tt pretty = FALSE}

\begin{lstlisting}[language = R]
p <- qplot(wt, mpg, data=mtcars, colour=cyl)
print(p, pretty = FALSE)
\end{lstlisting}

By default, {\tt ggplot} always clears the screen and draws to the entire device.  You customise this in two ways. One way is to setup a viewport and push it on to the display, then draw the plot with {\tt newpage=FALSE}. {\tt pushViewport} adds the viewport to the list of viewports on the display.   Afterwards, {\tt upViewport} returns you to the viewport for the entire page, preparing you for the next set of output.

\begin{lstlisting}[language = R]
p <- qplot(wt, mpg, data=mtcars, colour=cyl)
grid.newpage()
pushViewport(viewport(height=0.4, width=0.4, x=0.4, y=0.8))
print(p, newpage=FALSE, pretty=FALSE)
upViewport()
\end{lstlisting}

Alternatively, you can set up your own set of viewports, and then specify which one the plot should be drawn to.  Here we use {\tt upViewport} before displaying the plot so we are in the top level viewport before we start plotting.

\begin{lstlisting}[language = R]
grid.newpage()
pushViewport(viewport(height=0.5, width=0.5, x=0.5, y=0.5, name="small", angle=40))
upViewport()
print(p, vp="small")
\end{lstlisting}

Obviously, this is very useful if you want to layout plots in a complicated grid.  In this case, {\tt grid.layout} is very useful, as it allows you to set up a grid of viewports with arbitrary heights and widths.  You still need to create each viewport, but instead of explicitly specifying the position and size, you can specify the row and column of the layout.

\begin{lstlisting}[language = R]
p <- qplot(wt, mpg, data=mtcars, colour=cyl)

vplayout <- function(x, y) viewport(layout.pos.row=x, layout.pos.col=y)
grid.newpage()
pushViewport(viewport(layout=grid.layout(3,3)))

print(p, vp=vplayout(1,1))
print(p, vp=vplayout(2:3,2:3))
print(p, vp=vplayout(1, 2:3))
print(p, vp=vplayout(2:3, 1))
\end{lstlisting}

This is useful for arranging plots in a wider range of ways than what you can do with faceting.   You should be careful to ensure that scales are consistent over the different plots.  There is currently no easy way to do this, except to keep track of the maximum and minimum yourself, and then manually set the scales of the plot.

\section{Saving your work} 
\label{sec:grid-save}

Using \f{grid.gedit} works fine if you are editing the plot on screen, but if you want to save it to disk you need take some extra steps, or you will end up with multiple pages of output, each showing one change.  The key is not to modify the plot on screen, but to modify the plot grob, and then draw it once you have made all the changes.  

\begin{lstlisting}[language = R]
p <- qplot(wt, mpg, data=mtcars, colour=cyl)
# Get the plot grob
grob <- ggplotGrob(p)
# Modify it place
grob <- geditGrob(grob, gPath("strip","label"), gp=gpar(fontface="bold"))

# Draw it
grid.newpage()
grid.draw(grob)
\end{lstlisting}

\input{_footer.tex}
