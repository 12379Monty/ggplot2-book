\chapter{Manipulating data}\label{cha:data}

So far this book has assumed you have your data in a nicely structured
data frame ready to feed to \texttt{ggplot()} or \texttt{qplot()}. If
this is not the case, then you'll need to do some transformation.

In \hyperref[sec:plyr]{an introduction to plyr}, you will learn how to
use the \textbf{plyr} package to reproduce the statistical
transformations performed by the layers, and then in
\hyperref[sec:melting]{converting data from wide to long} you will learn
a little about `molten' (or long) data, which is useful for time series
and parallel coordinates plots, among others.
\hyperref[sec:methods]{\texttt{ggplot()} methods} shows you how to write
methods that let you plot objects other than data frames, and
demonstrates how \texttt{ggplot} can be used to re-create a more
flexible version of the built in linear-model diagnostics.

Data cleaning, manipulation and transformation is a big topic and this
chapter only scratches the surface of topics closely related to
\texttt{ggplot}. I recommend the following references which go into
considerably more depth on this topic:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \emph{Data Manipulation with R}, by Phil Spector. Published by
  Springer, 2008.
\item
  ``plyr: divide and conquer for data analysis'', Hadley Wickham.
  Available from \url{http://had.co.nz/plyr}. This is a full description
  of the package used in \hyperref[sec:plyr]{an introduction to plyr}.
\item
  ``Reshaping data with the reshape package'', Hadley Wickham.
  \emph{Journal of Statistical Software}, 21(12), 2007.
  \url{http://www.jstatsoft.org/v21/i12/}. This describes the complement
  of the melt function used in \hyperref[sec:melting]{converting data
  from wide to long}, which can be used like pivot tables to create a
  wide range of data summaries and rearrangements.
\end{itemize}

\hyperdef{}{sec:plyr}{\section{An introduction to plyr}\label{sec:plyr}}

With faceting, \texttt{ggplot} makes it very easy to create identical
plots for different subsets of your data. \index{Package!plyr} This
section introduces \texttt{ddply()} from the \textbf{plyr} package, a
function that makes it easy to do the same thing for numerical
summaries. \textbf{plyr} provides a comprehensive suite of tools for
breaking up complicated data structures into pieces, processing each
piece and then joining the results back together. The \textbf{plyr}
package as a whole provides tools for breaking and combining lists,
arrays and data frames. Here we will focus on the \texttt{ddply()}
function which breaks up a data frame into subsets based on row values,
applies a function to each subset and then joins the results back into a
data frame. The basic syntax is
\texttt{ddply(.data, .variables, .fun, ...)}, where \indexf{ddply}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{.data} is the dataset to break up (e.g., the data that you are
  plotting).
\item
  \texttt{.variables} is a description of the grouping variables used to
  break up the dataset. This is written like \texttt{.(var1, var2)}, and
  to match the plot should contain all the grouping and faceting
  variables that you've used in the plot.
\item
  \texttt{.fun} is the summary function you want to use. The function
  can return a vector or data frame. The result does not need to contain
  the grouping variables: these will be added on automatically if
  they're needed. The result can be a much reduced aggregated dataset
  (maybe even one number), or the original data modified or expanded in
  some way.
\end{itemize}

More information and examples are available in the documentation,
\texttt{?ddply}, and on the package website,
\url{http://had.co.nz/plyr}. The following examples show a few useful
summary functions that solve common data manipulation problems.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Using \texttt{subset()} allows you to select the top (or bottom) n (or
  x\%) of observations in each group, or observations above (or below)
  some group-specific threshold: \indexf{subset}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Select the smallest diamond in each colour}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), subset, carat ==}\StringTok{ }\KeywordTok{min}\NormalTok{(carat))}

\CommentTok{# Select the two smallest diamonds}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), subset, }\KeywordTok{order}\NormalTok{(carat) <=}\StringTok{ }\DecValTok{2}\NormalTok{)}

\CommentTok{# Select the 1% largest diamonds in each group}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), subset, carat >}\StringTok{ }
\StringTok{        }\KeywordTok{quantile}\NormalTok{(carat, }\FloatTok{0.99}\NormalTok{))}

\CommentTok{# Select all diamonds bigger than the group average}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), subset, price >}\StringTok{ }\KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Using \texttt{transform()} allows you to perform group-wise
  transformations with very little work. This is particularly useful if
  you want to add new variables that are calculated on a per-group
  level, such as a per-group standardisation.
  \hyperref[sub:time-series]{Multiple time series} shows another use of
  this technique for standardising time series to a common scale.
  \index{Transformation!group-wise} \indexf{transform}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Within each colour, scale price to mean 0 and variance 1}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), transform, }\DataTypeTok{price =} \KeywordTok{scale}\NormalTok{(price))}

\CommentTok{# Subtract off group mean}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), transform, }
      \DataTypeTok{price =} \NormalTok{price -}\StringTok{ }\KeywordTok{mean}\NormalTok{(price))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If you want to apply a function to every column in the data frame, you
  might find the \texttt{colwise()} function handy. This function
  converts a function that operates on vectors to a function that
  operates column-wise on data frames. This is rather different than
  most functions: instead of returning a vector of numbers,
  \texttt{colwise()} returns a new function. The following example
  creates a function to count the number of missing values in a vector
  and then shows how we can use \texttt{colwise()} to apply it to every
  column in a data frame. \index{Transformation!column-wise}
  \indexf{colwise}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nmissing <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\KeywordTok{nmissing}\NormalTok{(msleep$name)}
\CommentTok{#> [1] 0}
\KeywordTok{nmissing}\NormalTok{(msleep$brainwt)}
\CommentTok{#> [1] 27}

\NormalTok{nmissing_df <-}\StringTok{ }\KeywordTok{colwise}\NormalTok{(nmissing)}
\KeywordTok{nmissing_df}\NormalTok{(msleep)}
\CommentTok{#>   name genus vore order conservation sleep_total sleep_rem}
\CommentTok{#> 1    0     0    7     0           29           0        22}
\CommentTok{#>   sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1          51     0      27      0}
\CommentTok{# This is shorthand for the previous two steps}
\KeywordTok{colwise}\NormalTok{(nmissing)(msleep)}
\CommentTok{#>   name genus vore order conservation sleep_total sleep_rem}
\CommentTok{#> 1    0     0    7     0           29           0        22}
\CommentTok{#>   sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1          51     0      27      0}
\end{Highlighting}
\end{Shaded}

The specialised version \texttt{numcolwise()} does the same thing, but
works only with numeric columns. For example,
\texttt{numcolwise(median)} will calculate a median for every numeric
column, or \texttt{numcolwise(quantile)} will calculate quantiles for
every numeric column. Similarly, \texttt{catcolwise()} only works with
categorical columns. \indexf{numcolwise} \indexf{catcolwise}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep2 <-}\StringTok{ }\NormalTok{msleep[, -}\DecValTok{6}\NormalTok{] }\CommentTok{# Remove a column to save space}
\KeywordTok{numcolwise}\NormalTok{(median)(msleep2, }\DataTypeTok{na.rm =} \NormalTok{T)}
\CommentTok{#>   sleep_rem sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1       1.5        0.33    14   0.012    1.7}
\KeywordTok{numcolwise}\NormalTok{(quantile)(msleep2, }\DataTypeTok{na.rm =} \NormalTok{T)}
\CommentTok{#>   sleep_rem sleep_cycle awake brainwt  bodywt}
\CommentTok{#> 1       0.1        0.12   4.1 0.00014 5.0e-03}
\CommentTok{#> 2       0.9        0.18  10.2 0.00290 1.7e-01}
\CommentTok{#> 3       1.5        0.33  13.9 0.01240 1.7e+00}
\CommentTok{#> 4       2.4        0.58  16.1 0.12550 4.2e+01}
\CommentTok{#> 5       6.6        1.50  22.1 5.71200 6.7e+03}
\KeywordTok{numcolwise}\NormalTok{(quantile)(msleep2, }\DataTypeTok{probs =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.25}\NormalTok{, }\FloatTok{0.75}\NormalTok{), }
                     \DataTypeTok{na.rm =} \NormalTok{T)}
\CommentTok{#>   sleep_rem sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1       0.9        0.18    10  0.0029   0.17}
\CommentTok{#> 2       2.4        0.58    16  0.1255  41.75}
\end{Highlighting}
\end{Shaded}

Combined with \texttt{ddply()}, this makes it easy to produce per-group
summaries: \index{Summary!group-wise}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ddply}\NormalTok{(msleep2, .(vore), }\KeywordTok{numcolwise}\NormalTok{(median), }\DataTypeTok{na.rm =} \NormalTok{T)}
\CommentTok{#>      vore sleep_rem sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1   carni      1.95        0.38  13.6  0.0445 20.490}
\CommentTok{#> 2   herbi      0.95        0.22  13.7  0.0123  1.225}
\CommentTok{#> 3 insecti      3.00        0.17   5.9  0.0012  0.075}
\CommentTok{#> 4    omni      1.85        0.50  14.1  0.0066  0.950}
\CommentTok{#> 5    <NA>      2.00        0.18  13.4  0.0030  0.122}
\KeywordTok{ddply}\NormalTok{(msleep2, .(vore), }\KeywordTok{numcolwise}\NormalTok{(mean), }\DataTypeTok{na.rm =} \NormalTok{T)}
\CommentTok{#>      vore sleep_rem sleep_cycle awake brainwt bodywt}
\CommentTok{#> 1   carni       2.3        0.37  13.6  0.0793  90.75}
\CommentTok{#> 2   herbi       1.4        0.42  14.5  0.6216 366.88}
\CommentTok{#> 3 insecti       3.5        0.16   9.1  0.0215  12.92}
\CommentTok{#> 4    omni       2.0        0.59  13.1  0.1457  12.72}
\CommentTok{#> 5    <NA>       1.9        0.18  13.8  0.0076   0.86}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  If none of the previous shortcuts is appropriate, make your own
  summary function which takes a data frame as input and returns an
  appropriately summarised data frame as output. The following function
  calculates the rank correlation of price and carat and compares it to
  the regular correlation of the logged values.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_summary <-}\StringTok{ }\NormalTok{function(df) \{}
  \KeywordTok{with}\NormalTok{(df, }\KeywordTok{data.frame}\NormalTok{(}
    \DataTypeTok{pc_cor =} \KeywordTok{cor}\NormalTok{(price, carat, }\DataTypeTok{method =} \StringTok{"spearman"}\NormalTok{),}
    \DataTypeTok{lpc_cor =} \KeywordTok{cor}\NormalTok{(}\KeywordTok{log}\NormalTok{(price), }\KeywordTok{log}\NormalTok{(carat))}
    \NormalTok{))}
\NormalTok{\}}
\KeywordTok{ddply}\NormalTok{(diamonds, .(cut), my_summary)}
\CommentTok{#>         cut pc_cor lpc_cor}
\CommentTok{#> 1      Fair   0.91    0.91}
\CommentTok{#> 2      Good   0.96    0.97}
\CommentTok{#> 3 Very Good   0.97    0.97}
\CommentTok{#> 4   Premium   0.96    0.97}
\CommentTok{#> 5     Ideal   0.95    0.97}
\KeywordTok{ddply}\NormalTok{(diamonds, .(color), my_summary)}
\CommentTok{#>   color pc_cor lpc_cor}
\CommentTok{#> 1     D   0.96    0.96}
\CommentTok{#> 2     E   0.96    0.96}
\CommentTok{#> 3     F   0.96    0.96}
\CommentTok{#> 4     G   0.96    0.97}
\CommentTok{#> 5     H   0.97    0.98}
\CommentTok{#> 6     I   0.98    0.99}
\CommentTok{#> 7     J   0.98    0.99}
\end{Highlighting}
\end{Shaded}

Note how our summary function did not need to output the group
variables. This makes it much easier to aggregate over different groups.

The common pattern of all these problems is that they are easy to solve
if we have the right subset. Often the solution for a single case might
be a single line of code. The difficulty comes when we want to apply the
function to multiple subsets and then correctly join back up the
results. This may take a lot of code, especially if you want to preserve
group labels. \texttt{ddply()} takes care of all this for you.

The following case study shows how you can use \textbf{plyr} to
reproduce the statistical summaries produced by \texttt{ggplot}. This is
useful if you want to save them to disk or apply them to other datasets.
It's also useful to be able to check that \texttt{ggplot} is doing
exactly what you think!

\subsection{Fitting multiple models}\label{sub:multiple-models}

In this section, we'll work through the process of generating the
smoothed data produced by \texttt{stat\_smooth()}. This process will be
the same for any other statistic, and should allow you to produce more
complex summaries that \texttt{ggplot} can't produce by itself.
Figure\textasciitilde{}\ref{fig:smooth} shows the group-wise smoothes
produced by the following code. \index{Model!fitting multiple models}
\indexf{stat_smooth}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(carat, price, }\DataTypeTok{data =} \NormalTok{diamonds, }\DataTypeTok{geom =} \StringTok{"smooth"}\NormalTok{, }
  \DataTypeTok{colour =} \NormalTok{color)}
\NormalTok{dense <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(diamonds, carat <}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(carat, price, }\DataTypeTok{data =} \NormalTok{dense, }\DataTypeTok{geom =} \StringTok{"smooth"}\NormalTok{, }
  \DataTypeTok{colour =} \NormalTok{color,  }\DataTypeTok{fullrange =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datasmooth-1} \includegraphics[width=0.49\linewidth]{figures/datasmooth-2} \caption{A plot showing the smoothed trends for price vs. carat for each colour of diamonds. With the full range of carats (left), the standard errors balloon after around two carats because there are relatively few diamonds of that size. Restricting attention to diamonds of less than two carats (right) focuses on the region where we have plenty of data.\label{fig:smooth}}
\end{figure}

How can we re-create this by hand? First we read the
\texttt{stat\_smooth()} documentation to determine what the model is:
for large data it's \texttt{gam(y \textasciitilde{} s(x, bs = "cs"))}.
To get the same output as \texttt{stat\_smooth()}, we need to fit the
model, then predict it on an evenly spaced grid of points. This task is
performed by the \texttt{smooth()} function in the following code. Once
we have written this function it is straightforward to apply it to each
diamond colour using \texttt{ddply()}. \index{Package!mgcv}

Figure\textasciitilde{}\ref{fig:smooth-by-hand} shows the results of
this work, which are identical to what we got with \texttt{ggplot} doing
all the work.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(mgcv)}
\NormalTok{smooth <-}\StringTok{ }\NormalTok{function(df) \{}
  \NormalTok{mod <-}\StringTok{ }\KeywordTok{gam}\NormalTok{(price ~}\StringTok{ }\KeywordTok{s}\NormalTok{(carat, }\DataTypeTok{bs =} \StringTok{"cs"}\NormalTok{), }\DataTypeTok{data =} \NormalTok{df)}
  \NormalTok{grid <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{carat =} \KeywordTok{seq}\NormalTok{(}\FloatTok{0.2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{length =} \DecValTok{50}\NormalTok{))}
  \NormalTok{pred <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(mod, grid, }\DataTypeTok{se =} \NormalTok{T)}
  
  \NormalTok{grid$price <-}\StringTok{ }\NormalTok{pred$fit}
  \NormalTok{grid$se <-}\StringTok{ }\NormalTok{pred$se.fit}
  \NormalTok{grid}
\NormalTok{\}}
\NormalTok{smoothes <-}\StringTok{ }\KeywordTok{ddply}\NormalTok{(dense, .(color), smooth)}
\KeywordTok{qplot}\NormalTok{(carat, price, }\DataTypeTok{data =} \NormalTok{smoothes, }\DataTypeTok{colour =} \NormalTok{color, }
  \DataTypeTok{geom =} \StringTok{"line"}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(carat, price, }\DataTypeTok{data =} \NormalTok{smoothes, }\DataTypeTok{colour =} \NormalTok{color, }
  \DataTypeTok{geom =} \StringTok{"smooth"}\NormalTok{, }\DataTypeTok{ymax =} \NormalTok{price +}\StringTok{ }\DecValTok{2} \NormalTok{*}\StringTok{ }\NormalTok{se, }\DataTypeTok{ymin =} \NormalTok{price -}\StringTok{ }\DecValTok{2} \NormalTok{*}\StringTok{ }\NormalTok{se)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datasmooth-by-hand-1} \includegraphics[width=0.49\linewidth]{figures/datasmooth-by-hand-2} \caption{Figure~\ref{fig:smooth} with all statistical calculations performed by hand.  The predicted values (left), and with standard errors (right).\label{fig:smooth-by-hand}}
\end{figure}

Doing the summary by hand gives you much more flexibility to fit models
where the grouping factor is explicitly included as a covariate. For
example, the following model models price as a non-linear function of
carat, plus a constant term for each colour. It's not a very good model
as it predicts negative prices for small, poor-quality diamonds, but
it's a starting point for a better model.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{mod <-}\StringTok{ }\KeywordTok{gam}\NormalTok{(price ~}\StringTok{ }\KeywordTok{s}\NormalTok{(carat, }\DataTypeTok{bs =} \StringTok{"cs"}\NormalTok{) +}\StringTok{ }\NormalTok{color, }\DataTypeTok{data =} \NormalTok{dense)}
\NormalTok{>}\StringTok{ }\NormalTok{grid <-}\StringTok{ }\KeywordTok{with}\NormalTok{(diamonds, }\KeywordTok{expand.grid}\NormalTok{(}
\NormalTok{+}\StringTok{   }\DataTypeTok{carat =} \KeywordTok{seq}\NormalTok{(}\FloatTok{0.2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{length =} \DecValTok{50}\NormalTok{),}
\NormalTok{+}\StringTok{   }\DataTypeTok{color =} \KeywordTok{levels}\NormalTok{(color)}
\NormalTok{+}\StringTok{ }\NormalTok{))}
\NormalTok{>}\StringTok{ }\NormalTok{grid$pred <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(mod, grid)}
\NormalTok{>}\StringTok{ }\KeywordTok{qplot}\NormalTok{(carat, pred, }\DataTypeTok{data =} \NormalTok{grid, }\DataTypeTok{colour =} \NormalTok{color, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=0.49\linewidth]{figures/datagam-1}

See also \hyperref[sub:different-aesthetics]{varying aesthetics and
data} and \hyperref[sec:uncertainty]{revealing uncertainty} for other
ways of combining models and data.

\hyperdef{}{sec:melting}{\section{Converting data from wide to
long}\label{sec:melting}}

In \texttt{ggplot} graphics, groups are defined by rows, not by columns.
This makes it easy to draw a line for each group defined by the value of
a variable (or set of variables) but difficult to draw a separate line
for each variable. In this section you will learn how to transform your
data to a form in which you can draw a line for each variable. This
transformation converts from `wide' data to `long' data, where each
variable now occupies its own set of rows. \index{Data!wide-to-long}
\index{Converting data!from wide to long}

To perform this transformation we will use the \texttt{melt()} function
from the \textbf{reshape} package (Wickham 2007). Reshape also provides
the \texttt{cast()} function to flexibly reshape and aggregate data,
which you may want to read about yourself.
Table\textasciitilde{}\ref{tbl:melt} gives an example. The
\texttt{melt()} function has three arguments: \index{Package!reshape}
\indexf{melt}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{data}: the data frame you want to convert to long form.
\item
  \texttt{id.vars}: Identifier (id) variables identify the unit that
  measurements take place on. Id variables are usually discrete, and are
  typically fixed by design. In \texttt{anova()} notation (\(Y_{ijk}\)),
  id variables are the indices on the variables (\(i, j, k\)); in
  database notation, id variables are a composite primary key.
\item
  \texttt{measure.vars}: Measured variables represent what is measured
  on that unit (\(Y\)). These will be the variables that you want to
  display simultaneously on the plot.
\end{itemize}

If you're familiar with Wilkinson's grammar of graphics, you might
wonder why there is no equivalent to the algebra. There is no equivalent
to the algebra within \texttt{ggplot} itself because there are many
other facilities for transforming data in R, and it is in line with the
\texttt{ggplot} philosophy of keeping data transformation and
visualisation as separate as possible.

\begin{table}[ht]
\centering
\begin{tabular}{rlr}
  \hline
date & variable & value \\ 
  \hline
-916.00 & pce & 507.80 \\ 
  -885.00 & pce & 510.90 \\ 
  -854.00 & pce & 516.70 \\ 
  -824.00 & pce & 513.30 \\ 
  -793.00 & pce & 518.50 \\ 
  -763.00 & pce & 526.20 \\ 
   \hline
\end{tabular}
\caption{Economics data in wide, left, and long, right, formats. The data stored in each table is equivalent, just the arrangement is different. It it easy to use the wider format with \texttt{ggplot} to produce a line for each variable.} 
\label{melt}
\end{table}

The following sections explore two important uses of molten data in more
detail: plotting multiple time series and creating parallel coordinate
plots. You will also see how to use \texttt{ddply()} to rescale the
variables, and learn about the features of \texttt{ggplot} that are most
useful in conjunction with this sort of data.

\hyperdef{}{sub:time-series}{\subsection{Multiple time
series}\label{sub:time-series}}

Take the \texttt{economics} dataset. It contains information about
monthly economic data like the number of people unemployed
(\texttt{unemploy}) and the median length of unemployment
(\texttt{uempmed}). We might expect these two variables to be related.
Each of these variables is stored in a column, which makes it easy to
compare them with a scatterplot, and draw individual time series, as
shown in Figure\textasciitilde{}\ref{fig:series-wide}. But what if we
want to see the time series simultaneously?
\index{Time series!multivariate} \indexf{geom_line}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(date, uempmed, }\DataTypeTok{data =} \NormalTok{economics, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(date, unemploy, }\DataTypeTok{data =} \NormalTok{economics, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(unemploy, uempmed, }\DataTypeTok{data =} \NormalTok{economics) +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.32\linewidth]{figures/dataseries-wide-1} \includegraphics[width=0.32\linewidth]{figures/dataseries-wide-2} \includegraphics[width=0.32\linewidth]{figures/dataseries-wide-3} \caption{When the economics dataset is stored in wide format, it is easy to create separate time series plots for each variable (left and centre), and easy to create scatterplots comparing them (right).\label{fig:series-wide}}
\end{figure}

One way is to build up the plot with a different layer for each
variable, as you saw in \hyperref[sub:scale-manual]{the manual discrete
scale}. However, this quickly becomes tedious when you have many
variables, and a better alternative is to melt the data into a long
format and then visualise that. In the molten data the time series have
their value stored in the \texttt{value} variable and we can distinguish
between them with the \texttt{variable} variable. The code below shows
these two alternatives. The plots they produce are very similar, and are
shown in Figure\textasciitilde{}\ref{fig:series-methods}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(economics, }\KeywordTok{aes}\NormalTok{(date)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_line}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{unemploy, }\DataTypeTok{colour =} \StringTok{"unemploy"}\NormalTok{)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_line}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{uempmed, }\DataTypeTok{colour =} \StringTok{"uempmed"}\NormalTok{)) +}\StringTok{ }
\StringTok{  }\KeywordTok{scale_colour_hue}\NormalTok{(}\StringTok{"variable"}\NormalTok{)}

\NormalTok{emp <-}\StringTok{ }\NormalTok{tidyr::}\KeywordTok{gather}\NormalTok{(economics, variable, value, uempmed, unemploy)}
\KeywordTok{qplot}\NormalTok{(date, value, }\DataTypeTok{data =} \NormalTok{emp, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{, }\DataTypeTok{colour =} \NormalTok{variable)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/dataseries-methods-1} \includegraphics[width=0.49\linewidth]{figures/dataseries-methods-2} \caption{The two methods of displaying both series on a single plot produce identical plots, but using long data is much easier when you have many variables.  The series have radically different scales, so we only see the pattern in the \texttt{unemploy} variable. You might not even notice \texttt{uempmed} unless you're paying close attention: it's the line at the bottom of the plot.\label{fig:series-methods}}
\end{figure}

There is a problem with these plots: the two variables have radically
different scales, and so the series for \texttt{uempmed} appears as a
flat line at the bottom of the plot. There is no way to produce a plot
with two axes in \texttt{ggplot} because this type of plot is
fundamentally misleading. Instead there are two perceptually
well-founded alternatives: rescale the variables to have a common range,
or use faceting with free scales. These alternatives are created with
the code below and are shown in
Figure\textasciitilde{}\ref{fig:series-scaling}. \index{Axis!multiple}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{range01 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{rng <-}\StringTok{ }\KeywordTok{range}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
  \NormalTok{(x -}\StringTok{ }\NormalTok{rng[}\DecValTok{1}\NormalTok{]) /}\StringTok{ }\KeywordTok{diff}\NormalTok{(rng)}
\NormalTok{\}}
\NormalTok{emp2 <-}\StringTok{ }\KeywordTok{ddply}\NormalTok{(emp, .(variable), transform, }\DataTypeTok{value =} \KeywordTok{range01}\NormalTok{(value))}
\KeywordTok{qplot}\NormalTok{(date, value, }\DataTypeTok{data =} \NormalTok{emp2, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{, }
  \DataTypeTok{colour =} \NormalTok{variable, }\DataTypeTok{linetype =} \NormalTok{variable)}
\KeywordTok{qplot}\NormalTok{(date, value, }\DataTypeTok{data =} \NormalTok{emp, }\DataTypeTok{geom =} \StringTok{"line"}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{facet_grid}\NormalTok{(variable ~}\StringTok{ }\NormalTok{., }\DataTypeTok{scales =} \StringTok{"free_y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/dataseries-scaling-1} \includegraphics[width=0.49\linewidth]{figures/dataseries-scaling-2} \caption{When the series have very different scales we have two alternatives: left, rescale the variables to a common scale, or right, display the variables on separate facets and using free scales.\label{fig:series-scaling}}
\end{figure}

\subsection{Parallel coordinates plot}\label{sub:molten-data}

In a similar manner, we can use molten data to create a parallel
coordinates plot (Inselberg 1985,wegman:1990), which has the `variable'
variable on the x axis and value on the y axis. We need a new variable
to record the row that each observation came from, which is used as a
grouping variable for the lines (so we get one line per observation).
The easiest value to use for this is the data frame \texttt{rownames},
and we give it an unusual name \texttt{.row}, so we don't squash any of
the existing variables. Once we have the data in this form, creating a
parallel coordinates plot is easy. \index{Parallel coordinates plot}

The following code does exactly that for the ratings of 840 movies with
over 10,000 votes. This dataset has a moderate number of variables (10)
and many cases, and will allow us to experiment with a common technique
for dealing with large data in parallel coordinates plots: transparency
and clustering. Each variable gives the proportion of votes given to
each rating between 0 (very bad) and 10 (very good). Since this data is
already on a common scale we don't need to rescale it, but in general,
we would need to use the technique from the previous section to ensure
the variables are comparable. This is particularly important if we are
going to use other multidimensional techniques to analyse the data.
\index{Rescaling}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{popular <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(movies, votes >}\StringTok{ }\FloatTok{1e4}\NormalTok{)}
\NormalTok{ratings <-}\StringTok{ }\NormalTok{popular[, }\DecValTok{7}\NormalTok{:}\DecValTok{16}\NormalTok{]}
\NormalTok{ratings$.row <-}\StringTok{ }\KeywordTok{rownames}\NormalTok{(ratings)}
\NormalTok{molten <-}\StringTok{ }\NormalTok{tidyr::}\KeywordTok{gather}\NormalTok{(ratings, variable, value, -.row)}
\end{Highlighting}
\end{Shaded}

Once the data is in this form, creating a parallel coordinates plot is
easy. All we need is a line plot with \texttt{variable} on the x axis,
\texttt{value} on the y axis and the lines grouped by \texttt{.row}.
This data needs a few tweaks to the default because the values are
highly discrete. In the following code, we experiment with jittering and
alpha blending to better display where the bulk of the movies lie. The
results are shown in Figure\textasciitilde{}\ref{fig:pcp}. Most are
rated as sevens or eights by around 25\% of voters, with a few
exceptional movies getting 35\% of more perfect 10s. However, the large
number of lines makes it difficult to distinguish individual movies and
it's hard to draw firm conclusions. \indexf{geom_line}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pcp <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(molten, }\KeywordTok{aes}\NormalTok{(variable, value, }\DataTypeTok{group =} \NormalTok{.row))}
\NormalTok{pcp +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{()}
\NormalTok{pcp +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{alpha =} \DecValTok{1} \NormalTok{/}\StringTok{ }\DecValTok{20}\NormalTok{)}
\NormalTok{jit <-}\StringTok{ }\KeywordTok{position_jitter}\NormalTok{(}\DataTypeTok{width =} \FloatTok{0.25}\NormalTok{, }\DataTypeTok{height =} \FloatTok{2.5}\NormalTok{)}
\NormalTok{pcp +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{position =} \NormalTok{jit)}
\NormalTok{pcp +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{alpha =} \DecValTok{1} \NormalTok{/}\StringTok{ }\DecValTok{20}\NormalTok{, }\DataTypeTok{position =} \NormalTok{jit)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datapcp-1} \includegraphics[width=0.49\linewidth]{figures/datapcp-2} \includegraphics[width=0.49\linewidth]{figures/datapcp-3} \includegraphics[width=0.49\linewidth]{figures/datapcp-4} \caption{Variants on the parallel coordinates plot to better display the patterns in this highly discrete data.  To improve the default pcp (top left) we experiment with alpha blending (top right), jittering (bottom left) and then both together (bottom right).\label{fig:pcp}}
\end{figure}

To make the patterns more clear we will cluster the movies into groups
of similar rating patterns. The following code uses kmeans clustering
(Hartigan and Wong 1979) to produce six groups of similar movies. To
make the clusters a little more interpretable, they are relabelled so
that cluster 1 has the lowest average rating and cluster six the
highest. \index{Clustering}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cl <-}\StringTok{ }\KeywordTok{kmeans}\NormalTok{(ratings[}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{], }\DecValTok{6}\NormalTok{)}
\NormalTok{ratings$cluster <-}\StringTok{ }\KeywordTok{reorder}\NormalTok{(}\KeywordTok{factor}\NormalTok{(cl$cluster), popular$rating)}
\KeywordTok{levels}\NormalTok{(ratings$cluster) <-}\StringTok{ }\KeywordTok{seq_along}\NormalTok{(}\KeywordTok{levels}\NormalTok{(ratings$cluster))}
\NormalTok{molten <-}\StringTok{ }\NormalTok{tidyr::}\KeywordTok{gather}\NormalTok{(ratings, variable, value, r1:r10)}
\end{Highlighting}
\end{Shaded}

There are many different ways that we can visualise the result of this
clustering. One popular method is shown in
Figure\textasciitilde{}\ref{fig:pcp-colour} where line colour is mapped
to group membership. This plot is supplemented with a plot that just
shows averages for each group. These plots are both straightforward to
create, as shown in the following code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pcp_cl <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(molten, }
  \KeywordTok{aes}\NormalTok{(variable, value, }\DataTypeTok{group =} \NormalTok{.row, }\DataTypeTok{colour =} \NormalTok{cluster)) }
\NormalTok{pcp_cl +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{position =} \NormalTok{jit, }\DataTypeTok{alpha =} \DecValTok{1}\NormalTok{/}\DecValTok{5}\NormalTok{)}
\NormalTok{pcp_cl +}\StringTok{ }\KeywordTok{stat_summary}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =} \NormalTok{cluster), }\DataTypeTok{fun.y =} \NormalTok{mean, }
  \DataTypeTok{geom =} \StringTok{"line"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datapcp-colour-1} \includegraphics[width=0.49\linewidth]{figures/datapcp-colour-2} \caption{Displaying cluster membership on a parallel coordinates plot. (Left) Individual movies coloured by group membership and (right) group means.\label{fig:pcp-colour}}
\end{figure}

These plots are good for showing the differences between groups, but
they don't tell us a lot about whether we've done a good job clustering
the data. Figure\textasciitilde{}\ref{fig:pcp-facet} uses faceting to
display each group in its own panel. This plot highlights the variation
within many of the groups, suggesting that perhaps more clusters would
be appropriate.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pcp_cl +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{position =} \NormalTok{jit, }\DataTypeTok{alpha =} \DecValTok{1}\NormalTok{/}\DecValTok{5}\NormalTok{) +}
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(~}\StringTok{ }\NormalTok{cluster)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=\linewidth]{figures/datapcp-facet-1} \caption{Faceting allows us to display each group in its own panel, highlighting the fact that there seems to be considerable variation within each group, and suggesting that we need more groups in our clustering.\label{fig:pcp-facet}}
\end{figure}

\hyperdef{}{sec:methods}{\section{\texttt{ggplot()}
methods}\label{sec:methods}}

\texttt{ggplot()} is a generic function, with different methods for
different types of data. The most common input, and what we have used
until now, is a data frame. As with base and lattice graphics, it is
possible to extend \texttt{ggplot()} to work with other types of data.
However, the way this works with \texttt{ggplot} is fundamentally
different: \texttt{ggplot()} will not give you a complete plot, but
instead will give you the tools you need to make any plot you desire.
\index{ggplot!methods}

This process is mediated by the \texttt{fortify()} method, which takes
an object, and optional data frame, and creates a version of the object
in a form suitable for plotting with \texttt{ggplot}, i.e., as a data
frame. The name fortify comes from thinking about combining a model with
its data: the model fortifies the data, and the data fortifies the
model, and the result can be used to simultaneously visualise the model
and the data. An example will make this concrete, as you will see when
we describe the fortify method for linear models. \index{Fortify}
\indexf{fortify}

This section describes how the \texttt{fortify()} method works, and how
you can create new methods that are aligned with the \texttt{ggplot}
philosophy. The most important philosophical consideration is that data
transformation and display should be kept as separate as possible. This
maximises reusability, as you are no longer trapped into the single
display that the author envisaged.

These different types of input also work with \texttt{qplot()}: remember
that \texttt{qplot()} is just a thin wrapper around \texttt{ggplot()}.

\subsection{Linear models}

Currently, \texttt{ggplot} provides only one fortify method, for linear
models. Here we'll show how this method works, and how you can use it to
create tailored plots for better understanding your data and models.
Figure\textasciitilde{}\ref{fig:plot-lm} shows the output of
\texttt{plot.lm()} for a simple model. The graphics are a set of
pre-chosen model summary plots. These are useful for particular
problems, but are completely inflexible: there is no way to modify them
apart from opening up the source code for \texttt{plot.lm()} and
modifying it. This is hard because the data transformation and display
are inextricably entangled, making the code difficult to understand.
\index{Model!diagnostics} \index{Model!linear} \index{Linear models}
\indexf{fortify.lm}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(cty ~}\StringTok{ }\NormalTok{displ, }\DataTypeTok{data =} \NormalTok{mpg)}
\KeywordTok{plot}\NormalTok{(mod)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.4\linewidth]{figures/dataplot-lm-1} \includegraphics[width=0.4\linewidth]{figures/dataplot-lm-2} \includegraphics[width=0.4\linewidth]{figures/dataplot-lm-3} \includegraphics[width=0.4\linewidth]{figures/dataplot-lm-4} \caption{The output from \texttt{plot.lm()} for a simple model.\label{fig:plot-lm}}
\end{figure}

The \texttt{ggplot} approach completely separates data transformation
and display. The \texttt{fortify()} method does the transformation, and
then we use \texttt{ggplot} as usual to create the display that we want.
Currently \texttt{fortify()} adds the variables listed in
Table\textasciitilde{}\ref{tbl:fortify-vars} to the original dataset.
These are basically all the variables that \texttt{plot.lm()} creates in
order to produce its summary plots. The variables have a leading
\texttt{.} (full stop) in their names, so there is little risk that they
will clobber variables already in the dataset.

\begin{table}
  \centering
  \begin{tabular}{lp{2.5in}}
    \toprule
    Variable & Description \\
    \midrule
    \code{.cooksd}   & Cook's distances \\
    \code{.fitted}   & Fitted values \\
    \code{.hat}      & Diagonal of the hat matrix \\
    \code{.resid}    & Residuals \\
    \code{.sigma}    & Estimate of residual standard deviation when corresponding observation is dropped from model \\
    \code{.stdresid} & Standardised residuals \\
    \bottomrule
  \end{tabular}
  \caption{The diagnostic variables that \texttt{fortify.lm} assembles and adds to the model data.}
  \label{tbl:fortify-vars}
\end{table}

To demonstrate these techniques, we're going to fit the very simple
model with code below, which also creates the plot in
Figure\textasciitilde{}\ref{fig:fortify-mod}. This model clearly doesn't
fit the data well, so we should be able to use model diagnostics to
figure out how to improve it. A sample of the output from fortifying
this model is shown in Table\textasciitilde{}\ref{tbl:fortify-out}.
Because we didn't supply the original data frame, it contains the two
variables used in the model as well as the six diagnostic variables.
It's easy to see exactly what data our plot will be working with and we
could easily add more variables if we wanted.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(displ, cty, }\DataTypeTok{data =} \NormalTok{mpg) +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{)}
\NormalTok{mpgmod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(cty ~}\StringTok{ }\NormalTok{displ, }\DataTypeTok{data =} \NormalTok{mpg)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datafortify-mod-1} \caption{A simple linear model that doesn't fit the data very well.\label{fig:fortify-mod}}
\end{figure}

With a fortified dataset in hand we can easily re-create the plots
produced by \texttt{plot.lm()}, and even better, we can adapt them to
our needs. The example below shows how we can re-create and then extend
the first plot produced by \texttt{plot.lm()}. Once we have the basic
plot we can easily enhance it: use standardised residuals instead of raw
residuals, or make size proportional to Cook's distance. The results are
shown in Figure\textasciitilde{}\ref{fig:fortify-fr}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(cty ~}\StringTok{ }\NormalTok{displ, }\DataTypeTok{data =} \NormalTok{mpg)}
\NormalTok{basic <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mod, }\KeywordTok{aes}\NormalTok{(.fitted, .resid)) +}
\StringTok{  }\KeywordTok{geom_hline}\NormalTok{(}\DataTypeTok{yintercept =} \DecValTok{0}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"grey50"}\NormalTok{, }\DataTypeTok{size =} \FloatTok{0.5}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.5}\NormalTok{, }\DataTypeTok{se =} \NormalTok{F)}
\NormalTok{basic}
\NormalTok{basic +}\StringTok{ }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{.stdresid)}
\NormalTok{basic +}\StringTok{ }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{size =} \NormalTok{.cooksd) +}\StringTok{ }\KeywordTok{scale_size_area}\NormalTok{(}\StringTok{"Cook's distance"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.32\linewidth]{figures/datafortify-fr-1} \includegraphics[width=0.32\linewidth]{figures/datafortify-fr-2} \includegraphics[width=0.32\linewidth]{figures/datafortify-fr-3} \caption{(Left) Basic fitted values-residual plot. (Middle) With standardised residuals. (Right) With size proportional to Cook's distance. It is easy to modify the basic plots when we have access to all of the data.\label{fig:fortify-fr}}
\end{figure}

Additionally, we can fortify the whole dataset and add to the plot
variables that are in the original data but not in the model. This helps
us to understand what variables are useful to improve the model.
Figure\textasciitilde{}\ref{fig:fortify-full} colours the residuals by
the number of cylinders, and suggests that this variable would be good
to add to the model: within each cylinder group, the pattern is close to
linear.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{full <-}\StringTok{ }\NormalTok{basic %+%}\StringTok{ }\KeywordTok{fortify}\NormalTok{(mod, mpg)}
\NormalTok{full +}\StringTok{ }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \KeywordTok{factor}\NormalTok{(cyl))}
\NormalTok{full +}\StringTok{ }\KeywordTok{aes}\NormalTok{(displ, }\DataTypeTok{colour =} \KeywordTok{factor}\NormalTok{(cyl))}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/datafortify-full-1} \includegraphics[width=0.49\linewidth]{figures/datafortify-full-2} \caption{Adding variables from the original data can be enlightening. Here when we add the number of cylinders we see that instead of a curvi-linear relationship between displacement and city mpg, it is essentially linear, conditional on the number of cylinders.\label{fig:fortify-full}}
\end{figure}

\subsection{Writing your own}

To write your own \texttt{fortify()} method, you will need to think
about what variables are most useful for model diagnosis, and how they
should be returned to the user. The method for linear models adds them
on to the original data frame, but this might not be the best approach
in other circumstances, and you may instead want to return a list of
data frames giving information at different levels of aggregation.

You can also use \texttt{fortify()} with non-model functions. The
following example shows how we could write a \texttt{fortify()} method
to make it easier to add images to your plots. The \textbf{EBImage} from
bioconductor is used to get the image into R, and then the fortify
method converts it into a form (a data frame) that \texttt{ggplot} can
render. Should you even need a picture of me on your plot, the following
code will allow you to do so. \indexf{fortify.Image}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This example can and should be improved. }
\CommentTok{# I'm not sure that fortifying an image is a great example anymore }
\CommentTok{# since we have annotation_custom:}
\KeywordTok{library}\NormalTok{(}\StringTok{"jpeg"}\NormalTok{)}
\NormalTok{tmp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{download.file}\NormalTok{(}\StringTok{"http://had.co.nz/me.jpg"}\NormalTok{, tmp)}
\NormalTok{jpeg <-}\StringTok{ }\KeywordTok{readJPEG}\NormalTok{(tmp)}
\NormalTok{g <-}\StringTok{ }\KeywordTok{rasterGrob}\NormalTok{(jpeg, }\DataTypeTok{interpolate=}\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{geom =} \StringTok{"blank"}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{annotation_custom}\NormalTok{(g)}
\end{Highlighting}
\end{Shaded}

This approach cleanly separates the display of the data from its
production, and dramatically improves reuse. However, it does not
provide any conveniently pre-packaged functions. If you want to create a
diagnostic plot for a linear model you have to assemble all the pieces
yourself. Once you have the basic structure in place, so that people can
always dig back down and alter the individual pieces, you can write a
function that joins all the components together in a useful way. See
\hyperref[sec:functions]{plot functions} for some pointers on how to do
this.

Hartigan, J. A., and M. A. Wong. 1979. ``A K-Means Clustering
Algorithm.'' \emph{Applied Statistics} 28: 100--108.

Inselberg, A. 1985. ``The Plane with Parallel Coordinates.'' \emph{The
Visual Computer} 1: 69--91.

Wickham, Hadley. 2007. ``Reshaping Data with the Reshape Package.''
\emph{Journal of Statistical Software} 21 (12).
\url{http://www.jstatsoft.org/v21/i12/paper}.
