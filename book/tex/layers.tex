\chapter{Build a plot layer by layer}\label{cha:layers}

\section{Introduction}

Layering is the mechanism by which additional data elements are added to
a plot. Each layer can come from a different dataset and have a
different aesthetic mapping, allowing us to create plots that could not
be generated using \texttt{qplot()}, which permits only a single dataset
and a single set of aesthetic mappings.

This chapter is mainly a technical description of how layers, geoms,
statistics and position adjustments work: how you call and customise
them. The next chapter, the ``toolbox'', describes how you can use
different geoms and stats to solve particular visualisation problems.
These two chapters are companions, with this chapter explaining the
theory and the next chapter explaining the practical aspects of using
layers to achieve your graphical goals.

\hyperref[sec:ggplot]{Creating a plot} will teach you how to initialise
a plot object by hand, a task that \texttt{qplot()} performs for us. The
plot is not ready to be displayed until at least one layer is added, as
described in \hyperref[sec:layers]{Layers}. This section first describes
the complete layer specification, which helps you see exactly how the
components of the grammar are realised in R code, and then shows you the
shortcuts that will save you a lot of time. As you have learned in the
previous chapter, there are five components of a layer:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The \textbf{data}, which must be an R data frame, and can be changed
  after the plot is created (\hyperref[sec:data]{link to section}).
\item
  A set of \textbf{aesthetic mappings}, which describe how variables in
  the data are mapped to aesthetic properties of the layer. This section
  includes a description of how layer settings override the plot
  defaults, the difference between setting and mapping, and the
  important group aesthetic (\hyperref[sec:aes]{link to section}).
\item
  The \textbf{geom}, which describes the geometric used to draw the
  layer. The geom defines the set of available aesthetic properties
  (\hyperref[sec:geom]{link to section}).
\item
  The \textbf{stat}, which takes the raw data and transforms it in some
  useful way. The stat returns a data frame with new variables that can
  also be mapped to aesthetics with a special syntax
  (\hyperref[sec:stat]{link to section}).
\item
  The \textbf{position adjustment}, which adjusts elements to avoid
  overplotting (\hyperref[sec:position]{link to section}).
\end{itemize}

To conclude, \hyperref[sec:pull-together]{pulling it all together} shows
you some plotting techniques that pull together everything you have
learned in this chapter to create novel visualisations and to visualise
model information along with your data.

\hyperdef{}{sec:ggplot}{\section{Creating a plot}\label{sec:ggplot}}

When we used \texttt{qplot()}, it did a lot of things for us: it created
a plot object, added layers, and displayed the result, using many
default values along the way. To create the plot object ourselves, we
use \texttt{ggplot()}. This has two arguments: \textbf{data} and
aesthetic \textbf{mapping}. These arguments set up defaults for the plot
and can be omitted if you specify data and aesthetics when adding each
layer. The data argument needs little explanation: It's the data frame
that you want to visualise. You are already familiar with aesthetic
mappings from \texttt{qplot()}, and the syntax here is quite similar,
although you need to wrap the pairs of aesthetic attribute and variable
name in the \texttt{aes()} function. \texttt{aes()} is described more
fully in \hyperref[sec:aes]{aesthetic mappings}, but it's not very
tricky. The following example specifies a default mapping of x to
\texttt{carat}, y to \texttt{price} and colour to \texttt{cut}.
\indexf{ggplot}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{colour =} \NormalTok{cut))}
\end{Highlighting}
\end{Shaded}

This plot object cannot be displayed until we add a layer: there is
nothing to see!

\hyperdef{}{sec:layers}{\section{Layers}\label{sec:layers}}

A minimal layer may do nothing more than specify a \textbf{geom}, a way
of visually representing the data. If we add a point geom to the plot we
just created, we create a scatterplot, which can then be rendered.
\indexf{layer}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\NormalTok{p +}\StringTok{ }\KeywordTok{layer}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"point"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note how we use \texttt{+} to \textbf{add} the layer to the plot.
\index{Layers!adding} \indexc{+} This layer uses the plot defaults for
data and aesthetic mapping and it uses default values for two optional
arguments: the statistical transformation (the stat) and the position
adjustment. A more fully specified layer can take any or all of these
arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{layer}\NormalTok{(geom, geom_params, stat, stat_params, data, mapping, }
      \NormalTok{position)}
\end{Highlighting}
\end{Shaded}

Here is what a more complicated call looks like. It produces a histogram
(a combination of bars and binning) coloured `steelblue' with a bin
width of 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{carat))}
\NormalTok{p <-}\StringTok{ }\NormalTok{p +}\StringTok{ }\KeywordTok{layer}\NormalTok{(}
  \DataTypeTok{geom =} \StringTok{"bar"}\NormalTok{, }
  \DataTypeTok{geom_params =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"steelblue"}\NormalTok{),}
  \DataTypeTok{stat =} \StringTok{"bin"}\NormalTok{,}
  \DataTypeTok{stat_params =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{2}\NormalTok{)}
\NormalTok{)}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

This layer specification is precise but verbose. We can simplify it by
using shortcuts that rely on the fact that every geom is associated with
a default statistic and position, and every statistic with a default
geom. This means that you only need to specify one of \texttt{stat} or
\texttt{geom} to get a completely specified layer, with parameters
passed on to the geom or stat as appropriate. This expression generates
the same layer as the full layer command above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{2}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"steelblue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

All the shortcut functions have the same basic form, beginning with
\texttt{geom\_} or \texttt{stat\_}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{geom_XXX}\NormalTok{(mapping, data, ..., stat, position)}
\KeywordTok{stat_XXX}\NormalTok{(mapping, data, ..., geom, position)}
\end{Highlighting}
\end{Shaded}

Their common parameters define the components of the layer:

\begin{itemize}
\item
  \textbf{mapping} (optional): A set of aesthetic mappings, specified
  using the \texttt{aes()} function and combined with the plot defaults
  as described in \hyperref[sec:aes]{aesthetic mappings}.
\item
  \textbf{data} (optional): A dataset which overrides the default plot
  dataset. It is most commonly omitted, in which case the layer will use
  the default plot data. See \hyperref[sec:data]{data}.
\item
  \textbf{\ldots{}}: Parameters for the geom or stat, such as bin width
  in the histogram or bandwidth for a loess smoother. You can also use
  aesthetic properties as parameters. When you do this you \textbf{set}
  the property to a fixed value, not \textbf{map} it to a variable in
  the dataset. The example above showed setting the fill colour of the
  histogram to ``steelblue''. See \hyperref[sub:setting-mapping]{setting
  vs.~mapping} for more examples.
\item
  \textbf{geom} or \textbf{stat} (optional): You can override the
  default \texttt{stat} for a \texttt{geom}, or the default
  \texttt{geom} for a \texttt{stat}. This is a text string containing
  the name of the geom to use. Using the default will give you a
  standard plot; overriding the default allows you to achieve something
  more exotic, as shown in \hyperref[sub:new-plot-types]{combining geoms
  and stats}.
\item
  \textbf{position} (optional): Choose a method for adjusting
  overlapping objects, as described in
  \hyperref[sec:position]{position}.
\end{itemize}

Note that the order of \texttt{data} and \texttt{mapping} arguments is
switched between \texttt{ggplot()} and the layer functions. This is
because you almost always specify data for the plot, and almost always
specify aesthetics---but \emph{not} data---for the layers. We suggest
explicitly naming all other arguments rather than relying on positional
matching. This makes the code more readable and is the style followed in
this book.

Layers can be added to plots created with \texttt{ggplot()} or
\texttt{qplot()}. Remember, behind the scenes, \texttt{qplot()} is doing
exactly the same thing: it creates a plot object and then adds layers.
The following example shows the equivalence between these two ways of
making plots.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(msleep, }\KeywordTok{aes}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\CommentTok{# which is equivalent to}
\KeywordTok{qplot}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake, }\DataTypeTok{data =} \NormalTok{msleep)}

\CommentTok{# You can add layers to qplot too:}
\KeywordTok{qplot}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake, }\DataTypeTok{data =} \NormalTok{msleep) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{()}
\CommentTok{# This is equivalent to }
\KeywordTok{qplot}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake, }\DataTypeTok{data =} \NormalTok{msleep, }
  \DataTypeTok{geom =} \KeywordTok{c}\NormalTok{(}\StringTok{"point"}\NormalTok{, }\StringTok{"smooth"}\NormalTok{))}
\CommentTok{# or}
\KeywordTok{ggplot}\NormalTok{(msleep, }\KeywordTok{aes}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

You've seen that plot objects can be stored as variables. The summary
function can be helpful for inspecting the structure of a plot without
plotting it, as seen in the following example.
\index{Summary!of plot object} The summary shows information about the
plot defaults, and then each layer. In later chapters, you will learn
about \hyperref[cha:scales]{scales} and
\hyperref[cha:position]{faceting}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(msleep, }\KeywordTok{aes}\NormalTok{(sleep_rem /}\StringTok{ }\NormalTok{sleep_total, awake))}
\NormalTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(p)}
\CommentTok{#> data: name, genus, vore, order, conservation,}
\CommentTok{#>   sleep_total, sleep_rem, sleep_cycle, awake, brainwt,}
\CommentTok{#>   bodywt [83x11]}
\CommentTok{#> mapping:  x = sleep_rem/sleep_total, y = awake}
\CommentTok{#> faceting: facet_null()}
\NormalTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{p <-}\StringTok{ }\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\NormalTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(p)}
\CommentTok{#> data: name, genus, vore, order, conservation,}
\CommentTok{#>   sleep_total, sleep_rem, sleep_cycle, awake, brainwt,}
\CommentTok{#>   bodywt [83x11]}
\CommentTok{#> mapping:  x = sleep_rem/sleep_total, y = awake}
\CommentTok{#> faceting: facet_null() }
\CommentTok{#> -----------------------------------}
\CommentTok{#> geom_point: na.rm = FALSE }
\CommentTok{#> stat_identity:  }
\CommentTok{#> position_identity: (width = NULL, height = NULL)}
\end{Highlighting}
\end{Shaded}

Layers are regular R objects and so can be stored as variables, making
it easy to write clean code that reduces duplication.
\index{Layers!saving as variables} For example, a set of plots can be
initialised using different data then enhanced with the same layer. If
you later decide to change that layer, you only need to do so in one
place. The following shows a simple example, where we create a layer
that displays a translucent thick blue line of best fit.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bestfit <-}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{, }\DataTypeTok{se =} \NormalTok{F, }
  \DataTypeTok{colour =} \KeywordTok{alpha}\NormalTok{(}\StringTok{"steelblue"}\NormalTok{, }\FloatTok{0.5}\NormalTok{), }\DataTypeTok{size =} \DecValTok{2}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(sleep_rem, sleep_total, }\DataTypeTok{data =} \NormalTok{msleep) +}\StringTok{ }\NormalTok{bestfit}
\KeywordTok{qplot}\NormalTok{(awake, brainwt, }\DataTypeTok{data =} \NormalTok{msleep, }\DataTypeTok{log =} \StringTok{"y"}\NormalTok{) +}\StringTok{ }\NormalTok{bestfit}
\KeywordTok{qplot}\NormalTok{(bodywt, brainwt, }\DataTypeTok{data =} \NormalTok{msleep, }\DataTypeTok{log =} \StringTok{"xy"}\NormalTok{) +}\StringTok{ }\NormalTok{bestfit}
\end{Highlighting}
\end{Shaded}

The following sections describe data and mappings in more detail, then
go on to describe the available geoms, stats and position adjustments.

\hyperdef{}{sec:data}{\section{Data}\label{sec:data}}

The restriction on the data is simple: it must be a data frame.
\index{Data} \indexc{data.frame} This is restrictive, and unlike other
graphics packages in R. Lattice functions can take an optional data
frame or use vectors directly from the global environment. Base methods
often work with vectors, data frames or other R objects. However, there
are good reasons for this restriction. Your data is very important, and
it's better to be explicit about exactly what is done with it. It also
allows a cleaner separation of concerns so that \texttt{ggplot()} deals
only with plotting data, not wrangling it into different forms, for
which you might find the \textbf{dplyr} or \textbf{tidyr} packages
helpful. A single data frame is also easier to save than a multitude of
vectors, which means it's easier to reproduce your results or send your
data to someone else.

This restriction also makes it very easy to produce the same plot for
different data: you just change the data frame. You can replace the old
dataset with \texttt{\%+\%}, as shown in the following example.
\index{Data!replacing} (You might expect that this would use \texttt{+}
like all the other components, but unfortunately due to a restriction in
R this is not possible.) \indexc{\%+\%} Swapping out the data makes it
easy to experiment with imputation schemes or model fits, as shown in
\hyperref[sub:different-aesthetics]{varying aesthetics and data}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mtcars, }\KeywordTok{aes}\NormalTok{(mpg, wt, }\DataTypeTok{colour =} \NormalTok{cyl)) +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\NormalTok{p}
\NormalTok{mtcars <-}\StringTok{ }\KeywordTok{transform}\NormalTok{(mtcars, }\DataTypeTok{mpg =} \NormalTok{mpg ^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{p %+%}\StringTok{ }\NormalTok{mtcars}
\end{Highlighting}
\end{Shaded}

Any change of values or dimensions is legitimate. However, if a variable
changes from discrete to continuous (or vice versa), you will need to
change the default scales, as described in
\hyperref[sec:scale-usage]{scale usage}.

It is not necessary to specify a default dataset except when using
faceting; faceting is a global operation (i.e., it works on all layers)
and it needs to have a base dataset which defines the set of facets for
all datasets. See \hyperref[sub:missing-faceting-columns]{missing
faceting variables} for more details. If the default dataset is omitted,
every layer must supply its own data.

The data is stored in the plot object as a copy, not a reference. This
has two important consequences: if your data changes, the plot will not;
and \texttt{ggplot} objects are entirely self-contained so that they can
be \texttt{save}d to disk and later \texttt{load}ed and plotted without
needing anything else from that session.

\hyperdef{}{sec:aes}{\section{Aesthetic mappings}\label{sec:aes}}

To describe the way that variables in the data are mapped to things that
we can perceive on the plot (the `aesthetics'), we use the
\texttt{aes()} function. The \texttt{aes()} function takes a list of
aesthetic-variable pairs like these: \index{Mappings}
\index{Aesthetics!mappings|see{Mappings}} \indexf{aes}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{weight, }\DataTypeTok{y =} \NormalTok{height, }\DataTypeTok{colour =} \NormalTok{age)}
\end{Highlighting}
\end{Shaded}

Here we are mapping x-position to weight, y-position to height and
colour to age. The first two arguments can be left without names, in
which case they correspond to the x and y variables. This matches the
way that \texttt{qplot()} is normally used. You should never refer to
variables outside of the dataset (e.g., with \texttt{diamonds\$carat}),
as this makes it impossible to encapsulate all of the data needed for
plotting in a single object.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{aes}\NormalTok{(weight, height, }\DataTypeTok{colour =} \KeywordTok{sqrt}\NormalTok{(age))}
\end{Highlighting}
\end{Shaded}

Note that functions of variables can be used.

Any variable in an \texttt{aes()} specification must be contained inside
the plot or layer data. This is one of the ways in which \texttt{ggplot}
objects are guaranteed to be entirely self-contained, so that they can
be stored and re-used.

\section{Plots and layers}\label{sub:plots-and-layers}

The default aesthetic mappings can be set when the plot is initialised
or modified later using \texttt{+}, as in this example:
\index{Mappings!defaults} \indexc{+}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mtcars)}
\NormalTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(p)}
\CommentTok{#> data: mpg, cyl, disp, hp, drat, wt, qsec, vs, am,}
\CommentTok{#>   gear, carb [32x11]}
\CommentTok{#> faceting: facet_null()}
\NormalTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{p <-}\StringTok{ }\NormalTok{p +}\StringTok{ }\KeywordTok{aes}\NormalTok{(wt, hp)}
\NormalTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(p)}
\CommentTok{#> data: mpg, cyl, disp, hp, drat, wt, qsec, vs, am,}
\CommentTok{#>   gear, carb [32x11]}
\CommentTok{#> mapping:  x = wt, y = hp}
\CommentTok{#> faceting: facet_null()}
\end{Highlighting}
\end{Shaded}

One reason you might want to do this is shown in
\hyperref[sub:different-aesthetics]{varying aesthetics and data}. We
have seen several examples of using the default mapping when adding a
layer to a plot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mtcars, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{mpg, }\DataTypeTok{y =} \NormalTok{wt))}
\NormalTok{>}\StringTok{ }\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=0.49\linewidth]{figures/layerslayer14-1} \end{flushleft}

The default mappings in the plot \texttt{p} can be extended or
overridden in the layers, as with the following code.
\index{Mappings!overriding} The results are shown in Figure
\ref{fig:aes-override}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \KeywordTok{factor}\NormalTok{(cyl)))}
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{disp))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersaes-override-1} \includegraphics[width=0.49\linewidth]{figures/layersaes-override-2} 

}

\caption{Overriding aesthetics. (Left) Overriding colour with \texttt{factor(cyl)} and (right) overriding y-position with \texttt{disp}\label{fig:aes-override}}
\end{figure}

The rules are summarised in Table \ref{tbl:aes-override}. Aesthetic
mappings specified in a layer affect only that layer. For that reason,
unless you modify the default scales, axis labels and legend titles will
be based on the plot defaults. The way to change these is described in
\hyperref[sec:guides]{legends and axes}.

\begin{table}[ht]
\centering
\begin{tabular}{lll}
  \hline
Operation & Layer aesthetics & Result \\ 
  \hline
Add & $\backslash$texttt\{aes(colour = cyl)\} & $\backslash$texttt\{aes(mpg, wt, colour = cyl)\} \\ 
  Override & $\backslash$texttt\{aes(y = disp)\} & $\backslash$texttt\{aes(mpg, disp)\} \\ 
  Remove & $\backslash$texttt\{aes(y = NULL)\} & $\backslash$texttt\{aes(mpg)\} \\ 
   \hline
\end{tabular}
\caption{Rules for combining layer mappings with the default mapping of \texttt{aes(mpg, wt)}.  Layer aesthetics can add to, override, and remove the default mappings.} 
\label{tbl:aes-override}
\end{table}

\hyperdef{}{sub:setting-mapping}{\section{Setting
vs.~mapping}\label{sub:setting-mapping}}

Instead of mapping an aesthetic property to a variable, you can set it
to a single value by specifying it in the layer parameters. Aesthetics
can vary for each observation being plotted, while parameters do not. We
\textbf{map} an aesthetic to a variable (e.g.,
\texttt{aes(colour = cut)}) or \textbf{set} it to a constant (e.g.,
\texttt{colour = "red"}). For example, the following layer sets the
colour of the points, using the colour parameter of the layer:
\index{Aesthetics!setting|textbf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mtcars, }\KeywordTok{aes}\NormalTok{(mpg, wt))}
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

This sets the point colour to be dark blue instead of black. This is
quite different than

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

This \textbf{maps} (not sets) the colour to the value `darkblue'. This
effectively creates a new variable containing only the value `darkblue'
and then maps colour to that new variable. Because this value is
discrete, the default colour scale uses evenly spaced colours on the
colour wheel, and since there is only one value this colour is pinkish.
The difference between setting and mapping is illustrated in Figure
\ref{fig:qplot-setting}.

With \texttt{qplot()}, you can do the same thing by putting the value
inside of \texttt{I()}, e.g. \texttt{colour = I("darkblue")}. Chapter
\hyperref[cha:specifications]{Specifications} describes how values
should be specified for the various aesthetics. \indexf{I}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(mpg, wt, }\DataTypeTok{data=}\NormalTok{mtcars, }\DataTypeTok{colour =} \KeywordTok{I}\NormalTok{(}\StringTok{"darkblue"}\NormalTok{))}
\KeywordTok{qplot}\NormalTok{(mpg, wt, }\DataTypeTok{data=}\NormalTok{mtcars, }\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersqplot-setting-1} \includegraphics[width=0.49\linewidth]{figures/layersqplot-setting-2} 

}

\caption{The difference between (left) setting colour to 'darkblue' and (right) mapping colour to 'darkblue'. When 'darkblue' is mapped to colour, it is treated as a regular value and scaled with the default colour scale. This results in pinkish points and a legend.\label{fig:qplot-setting}}
\end{figure}

\hyperdef{}{sub:grouping}{\section{Grouping}\label{sub:grouping}}

In \texttt{ggplot}, geoms can be roughly divided into individual and
collective geoms. An individual geom has a distinctive graphical object
for each row in the data frame. For example, the point geom has a single
point for each observation. On the other hand, collective geoms
represent multiple observations. This may be a result of a statistical
summary, or may be fundamental to the display of the geom, as with
polygons. Lines and paths fall somewhere in between: each overall line
is composed of a set of straight segments, but each segment represents
two points. How do we control which observations go in which individual
graphical element? This is the job of the \texttt{group} aesthetic.
\index{Grouping}

By default, the \texttt{group} is set to the interaction of all discrete
variables in the plot. This often partitions the data correctly, but
when it does not, or when no discrete variable is used in the plot, you
will need to explicitly define the grouping structure, by mapping group
to a variable that has a different value for each group. The
\texttt{interaction()} function is useful if a single pre-existing
variable doesn't cleanly separate groups, but a combination does.

There are three common cases where the default is not enough, and we
will consider each one below. In the following examples, we will use a
simple longitudinal dataset, \texttt{Oxboys}, from the \textbf{nlme}
package. It records the heights (\texttt{height}) and centered ages
(\texttt{age}) of 26 boys (\texttt{Subject}), measured on nine occasions
(\texttt{Occasion}). \index{Package!nlme}

\textbf{Multiple groups, one aesthetic.}

In many situations, you want to separate your data into groups, but
render them in the same way. When looking at the data in aggregate you
want to be able to distinguish individual subjects, but not identify
them. This is common in longitudinal studies with many subjects, where
the plots are often descriptively called spaghetti plots.
\index{Data!longitudinal}

The first plot in Figure \ref{fig:group-lines} shows a set of time
series plots, one for each boy. You can see the separate growth
trajectories for each boy, but there is no way to see which boy belongs
to which trajectory. This plot was generated with: \index{Time series}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(Oxboys, }\KeywordTok{aes}\NormalTok{(age, height, }\DataTypeTok{group =} \NormalTok{Subject)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

We specified the \texttt{Subject} as the grouping variable to get a line
for each boy. The second plot in the figure shows the result of leaving
this out: we get a single line which passes through every point. This is
not very useful! Line plots with an incorrect grouping specification
typically have this characteristic appearance. \indexf{geom_line}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersgroup-lines-1} \includegraphics[width=0.49\linewidth]{figures/layersgroup-lines-2} 

}

\caption{(Left) Correctly specifying {\tt group = Subject} produces one line per subject.  (Right) A single line connects all observations. This pattern is characteristic of an incorrect grouping aesthetic, and is what we see if the group aesthetic is omitted, which in this case is equivalent to {\tt group = 1}.\label{fig:group-lines}}
\end{figure}

\textbf{Different groups on different layers.}

Sometimes we want to plot summaries based on different levels of
aggregation. Different layers might have different group aesthetics, so
that some display individual level data while others display summaries
of larger groups.

Building on the previous example, suppose we want to add a single smooth
line to the plot just created, based on the ages and heights of
\emph{all} the boys. If we use the same grouping for the smooth that we
used for the line, we get the first plot in Figure
\ref{fig:group-smooths}. \indexf{geom_smooth}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =} \NormalTok{Subject), }\DataTypeTok{method=}\StringTok{"lm"}\NormalTok{, }\DataTypeTok{se =} \NormalTok{F)}
\end{Highlighting}
\end{Shaded}

This is not what we wanted; we have inadvertently added a smoothed line
for each boy. This new layer needs a different group aesthetic,
\texttt{group = 1}, so that the new line will be based on all the data,
as shown in the second plot in the figure. The modified layer looks like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =} \DecValTok{1}\NormalTok{), }\DataTypeTok{method=}\StringTok{"lm"}\NormalTok{, }\DataTypeTok{size =} \DecValTok{2}\NormalTok{, }\DataTypeTok{se =} \NormalTok{F)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersgroup-smooths-1} \includegraphics[width=0.49\linewidth]{figures/layersgroup-smooths-2} 

}

\caption{Adding smooths to the Oxboys data.  (Left) Using the same grouping as the lines results in a line of best fit for each boy.  (Right) Using \texttt{aes(group = 1)} in the smooth layer fits a single line of best fit across all boys.\label{fig:group-smooths}}
\end{figure}

Note how we stored the first plot in the variable \texttt{p}, so we
could experiment with the code to generate the second layer without
having to re-enter any of the code for the first layer. This is a useful
time-saving technique, and is expanded upon in
\hyperref[cha:duplication]{duplication}.

\textbf{Overriding the default grouping.}

The plot has a discrete scale but you want to draw lines that connect
\emph{across} groups. This is the strategy used in interaction plots,
profile plots, and parallel coordinate plots, among others. For example,
we draw boxplots of height at each measurement occasion, as shown in the
first figure in Figure \ref{fig:group-boxplots}: \indexf{geom_boxplot}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boysbox <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(Oxboys, }\KeywordTok{aes}\NormalTok{(Occasion, height)) +}\StringTok{ }\KeywordTok{geom_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

There is no need to specify the group aesthetic here; the default
grouping works because occasion is a discrete variable. To overlay
individual trajectories we again need to override the default grouping
for that layer with \texttt{aes(group = Subject)}, as shown in the
second plot in the figure.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boysbox +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =} \NormalTok{Subject), }\DataTypeTok{colour =} \StringTok{"#3366FF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We change the line colour in the second layer to make them distinct from
the boxes. This is another example of setting an aesthetic to a fixed
value. The colour is a rendering attribute, which has no corresponding
variable in the data. \index{Aesthetics!setting}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersgroup-boxplots-1} \includegraphics[width=0.49\linewidth]{figures/layersgroup-boxplots-2} 

}

\caption{(Left) If boxplots are used to look at the distribution of heights at each occasion (a discrete variable), the default grouping works correctly.  (Right) If trajectories of individual boys are overlaid with \texttt{geom\_line()}, then \texttt{aes(group = Subject)} is needed for the new layer.\label{fig:group-boxplots}}
\end{figure}

\subsection{Matching aesthetics to graphic objects}\label{sub:matching}

Another important issue with collective geom is how the aesthetics of
the individual observations are mapped to the aesthetics of the complete
entity. For individual geoms, this isn't a problem, because each
observation is represented by a single graphical element. However, high
data densities can make it difficult (or impossible) to distinguish
between individual points and in some sense the point geom becomes a
collective geom, a single blob of points.
\index{Aesthetics!matching to geoms}

Lines and paths operate on an off-by-one principle: there is one more
observation than line segment, and so the aesthetic for the first
observation is used for the first segment, the second observation for
the second segment and so on. This means that the aesthetic for the last
observation is not used, as shown in Figure \ref{fig:matching-lines}. An
additional limitation for paths and lines is that that line type must be
constant over each individual line, in R there is no way to draw a
joined up line which has varying line type. \indexf{geom_line}
\indexf{geom_path}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersmatching-lines-1} \includegraphics[width=0.49\linewidth]{figures/layersmatching-lines-2} 

}

\caption{For lines and paths, the aesthetics of the line segment are determined by the aesthetic of the beginning observation. If colour is categorical (left) there is no meaningful way to interpolate between adjacent colours. If colour is continuous (right), there is, but this is not done by default.\label{fig:matching-lines}}
\end{figure}

You could imagine a more complicated system where segments smoothly
blend from one aesthetic to another. This would work for continuous
variables like size or colour, but not for line type, and is not used in
\texttt{ggplot}. If this is the behaviour you want, you can perform the
linear interpolation yourself, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{xgrid <-}\StringTok{ }\KeywordTok{with}\NormalTok{(df, }\KeywordTok{seq}\NormalTok{(}\KeywordTok{min}\NormalTok{(x), }\KeywordTok{max}\NormalTok{(x), }\DataTypeTok{length =} \DecValTok{50}\NormalTok{))}
\NormalTok{>}\StringTok{ }\NormalTok{interp <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
\NormalTok{+}\StringTok{   }\DataTypeTok{x =} \NormalTok{xgrid,}
\NormalTok{+}\StringTok{   }\DataTypeTok{y =} \KeywordTok{approx}\NormalTok{(df$x, df$y, }\DataTypeTok{xout =} \NormalTok{xgrid)$y,}
\NormalTok{+}\StringTok{   }\DataTypeTok{colour =} \KeywordTok{approx}\NormalTok{(df$x, df$colour, }\DataTypeTok{xout =} \NormalTok{xgrid)$y  }
\NormalTok{+}\StringTok{ }\NormalTok{)}
\NormalTok{>}\StringTok{ }\KeywordTok{qplot}\NormalTok{(x, y, }\DataTypeTok{data =} \NormalTok{df, }\DataTypeTok{colour =} \NormalTok{colour, }\DataTypeTok{size =} \KeywordTok{I}\NormalTok{(}\DecValTok{5}\NormalTok{)) +}\StringTok{ }
\NormalTok{+}\StringTok{   }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{data =} \NormalTok{interp, }\DataTypeTok{size =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=0.49\linewidth]{figures/layersmatching-lines2-1} \end{flushleft}

For all other collective geoms, like polygons, the aesthetics from the
individual components are only used if they are all the same, otherwise
the default value is used. This makes sense for fill as it is a property
of the entire object: it doesn't make sense to think about having a
different fill colour for each point on the border of the polygon.
\indexf{geom_polygon}

These issues are most relevant when mapping aesthetics to continuous
variable, because, as described above, when you introduce a mapping to a
discrete variable, it will by default split apart collective geoms into
smaller pieces. This works particularly well for bar and area plots,
because stacking the individual pieces produces the same shape as the
original ungrouped data. This is illustrated in Figure
\ref{fig:bar-split}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(color, }\DataTypeTok{data =} \NormalTok{diamonds)}
\KeywordTok{qplot}\NormalTok{(color, }\DataTypeTok{data =} \NormalTok{diamonds, }\DataTypeTok{fill =} \NormalTok{cut)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersbar-split-1} \includegraphics[width=0.49\linewidth]{figures/layersbar-split-2} 

}

\caption{Splitting apart a bar chart (left) produces a plot (right) that has the same outline as the original.\label{fig:bar-split}}
\end{figure}

\hyperdef{}{sec:geom}{\section{Geoms}\label{sec:geom}}

Geometric objects, or \textbf{geoms} for short, perform the actual
rendering of the layer, control the type of plot that you create. For
example, using a point geom will create a scatterplot, while using a
line geom will create a line plot. Table \ref{tbl:geoms} lists all of
the geoms available in \texttt{ggplot}.

Each geom has a set of aesthetics that it understands, and a set that
are required for drawing. For example, a point requires x and y
position, and understands colour, size and shape aesthetics. A bar
requires height (\texttt{ymax}), and understands width, border colour
and fill colour. These are listed for all geoms in Table
\ref{tbl:geom-aesthetics}. \indexf{geom_bar}

Some geoms differ primarily in the way that they are parameterised. For
example, the tile geom is specified in terms of the location of its
centre and its height and width, while the rect geom is parameterised in
terms of its top (\texttt{ymax}), bottom (\texttt{ymin}), left
(\texttt{xmin}) and right (\texttt{right}) positions. \indexf{geom_rect}
Internally, the rect geom is described as a polygon, and its parameters
are the locations of the four corners. This is useful for non-Cartesian
coordinate systems, as you will learn in
\hyperref[cha:position]{position}. \index{Geoms!parameterisation}

Every geom has a default statistic, and every statistic a default geom.
For example, the bin statistic defaults to using the bar geom to produce
a histogram. These defaults are listed in Table
\ref{tbl:geom-aesthetics}. Overriding these defaults will still produce
valid plots, but they may violate graphical conventions. See examples in
\hyperref[sub:new-plot-types]{combining geoms and stats}.
\index{Geoms!defaults}

\hyperdef{}{sec:stat}{\section{Stat}\label{sec:stat}}

A statistical transformation, or \textbf{stat}, transforms the data,
typically by summarising it in some manner. For example, a useful stat
is the smoother, which calculates the mean of y, conditional on x,
subject to some restriction that ensures smoothness. All currently
available stats are listed in Table \ref{tbl:stats}. To make sense in a
graphic context a stat must be location-scale invariant:
\(\mbox{f}(x + a) = \mbox{f}(x) + a\) and
\(\mbox{f}(b \cdot x) = b \cdot \mbox{f}(x)\). This ensures that the
transformation stays the same when you change the scales of the plot.

\input{tbls/stats}

A stat takes a dataset as input and returns a dataset as output, and so
a stat can add new variables to the original dataset. It is possible to
map aesthetics to these new variables. For example, \texttt{stat\_bin},
the statistic used to make histograms, produces the following variables:
\index{Stats!creating new variables} \indexf{stat_bin}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{count}, the number of observations in each bin
\item
  \texttt{density}, the density of observations in each bin (percentage
  of total / bar width)
\item
  \texttt{x}, the centre of the bin
\end{itemize}

These generated variables can be used instead of the variables present
in the original dataset. For example, the default histogram geom assigns
the height of the bars to the number of observations (\texttt{count}),
but if you'd prefer a more traditional histogram, you can use the
density (\texttt{density}). The following example shows a density
histogram of \texttt{carat} from the diamonds dataset.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(carat)) +}\StringTok{ }
\NormalTok{+}\StringTok{   }\KeywordTok{geom_histogram}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{..density..), }\DataTypeTok{binwidth =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=\linewidth]{figures/layershist-1} \end{flushleft}

The names of generated variables must be surrounded with \texttt{..}
when used. This prevents confusion in case the original dataset includes
a variable with the same name as a generated variable, and it makes it
clear to any later reader of the code that this variable was generated
by a stat. Each statistic lists the variables that it creates in its
documentation. \indexc{..}

The syntax to produce this plot with \texttt{qplot()} is very similar:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qplot}\NormalTok{(carat, ..density.., }\DataTypeTok{data =} \NormalTok{diamonds, }\DataTypeTok{geom=}\StringTok{"histogram"}\NormalTok{, }
  \DataTypeTok{binwidth =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{sec:position}{\section{Position
adjustments}\label{sec:position}}

Position adjustments apply minor tweaks to the position of elements
within a layer. Table \ref{fig:position} lists all of the position
adjustments available within \texttt{ggplot}. Position adjustments are
normally used with discrete data. Continuous data typically doesn't
overlap exactly, and when it does (because of high data density) minor
adjustments, like jittering, are usually insufficient to fix the
problem. \index{Position adjustments} \index{Adjustments!position}
\index{Positioning!position adjustments}

\input{tbls/position}

The different types of adjustment are best illustrated with a bar chart.
Figure \ref{fig:position-bar} shows stacking, filling and dodging.
Stacking puts bars on the same x on top of one another; filling does the
same, but normalises height to 1; and dodging places the bars
side-by-side. Dodging is rather similar to faceting, and the advantages
and disadvantages of each method are described in
\hyperref[sub:dodge-vs-facet]{dodging vs.~faceting}. For these
operations to work, each bar must have the same width and not overlap
with any others. The identity adjustment (i.e., do nothing) doesn't make
much sense for bars, but is shown in Figure \ref{fig:position-identity}
along with a line plot of the same data for reference. \index{Dodging}
\index{Side-by-side|see{Dodging}} \index{Stacking}
\indexf{position_dodge} \indexf{position_fill} \indexf{position_stack}
\indexf{geom_bar}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplot <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(clarity, }\DataTypeTok{fill =} \NormalTok{cut))}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"stack"}\NormalTok{)}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"fill"}\NormalTok{)}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.32\linewidth]{figures/layersposition-bar-1} \includegraphics[width=0.32\linewidth]{figures/layersposition-bar-2} \includegraphics[width=0.32\linewidth]{figures/layersposition-bar-3} 

}

\caption{Three position adjustments applied to a bar chart.  From left to right, stacking, filling and dodging.\label{fig:position-bar}}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{)}
\KeywordTok{qplot}\NormalTok{(clarity, }\DataTypeTok{data =} \NormalTok{diamonds, }\DataTypeTok{geom=}\StringTok{"line"}\NormalTok{, }\DataTypeTok{colour =} \NormalTok{cut, }
  \DataTypeTok{stat=}\StringTok{"bin"}\NormalTok{, }\DataTypeTok{group=}\NormalTok{cut)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/layersposition-identity-1} \includegraphics[width=0.49\linewidth]{figures/layersposition-identity-2} 

}

\caption{The identity positon adjustment is not useful for bars, (left) because each bar obscures the bars behind.  (Right) It is useful for lines, however, because lines do not have the same problem.\label{fig:position-identity}}
\end{figure}

\hyperdef{}{sec:pull-together}{\section{Pulling it all
together}\label{sec:pull-together}}

Once you have become comfortable with combining layers, you will be able
to create graphics that are both intricate and useful. The following
examples demonstrate some of the ways to use the capabilities of layers
that have been introduced in this chapter. These are just to get you
started. You are limited only by your imagination!

\hyperdef{}{sub:new-plot-types}{\subsection{Combining geoms and
stats}\label{sub:new-plot-types}}

By connecting geoms with different statistics, you can easily create new
graphics. Figure \ref{fig:hist-variations} shows three variations on a
histogram. They all use the same statistical transformation underlying a
histogram (the bin stat), but use different geoms to display the
results: the area geom, the point geom and the tile geom.
\index{Geoms!combining with stats} \index{Stats!combining with geoms}

(The use of \texttt{xlim} will be discussed in
\hyperref[sub:scale-position]{position scales}, in the presentation of
the use of scales and axes, but you can already guess that it is used
here to set the limits of the horizontal axis.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(carat)) +}\StringTok{ }\KeywordTok{xlim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{d +}\StringTok{ }\KeywordTok{stat_bin}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{ymax =} \NormalTok{..count..), }\DataTypeTok{binwidth =} \FloatTok{0.1}\NormalTok{, }\DataTypeTok{geom =} \StringTok{"area"}\NormalTok{)}
\NormalTok{d +}\StringTok{ }\KeywordTok{stat_bin}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{size =} \NormalTok{..density..), }\DataTypeTok{binwidth =} \FloatTok{0.1}\NormalTok{, }
  \DataTypeTok{geom =} \StringTok{"point"}\NormalTok{, }\DataTypeTok{position=}\StringTok{"identity"}\NormalTok{)}
\NormalTok{d +}\StringTok{ }\KeywordTok{stat_density}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \KeywordTok{factor}\NormalTok{(}\DecValTok{1}\NormalTok{), }\DataTypeTok{fill =} \NormalTok{..count..), }
  \DataTypeTok{geom =} \StringTok{"tile"}\NormalTok{, }\DataTypeTok{position=}\StringTok{"identity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics[width=0.32\linewidth]{figures/layershist-variations-1} \includegraphics[width=0.32\linewidth]{figures/layershist-variations-2} \includegraphics[width=0.32\linewidth]{figures/layershist-variations-3} 

}

\caption{Three variations on the histogram. (Left) A frequency polygon; (middle) a scatterplot with both size and height mapped to frequency; (right) a heatmap representing frequency with colour.\label{fig:hist-variations}}
\end{figure}

A number of the geoms available in \texttt{ggplot} were derived from
other geoms in a process like the one just described, starting with an
existing geom and making a few changes in the default aesthetics or
stat. For example, the jitter geom is simply the point geom with the
default position adjustment set to jitter. Once it becomes clear that a
particular variant is going to be used a lot or used in a very different
context, it makes sense to create a new geom. Table
\ref{tbl:aliased-geoms} lists these ``aliased'' geoms.
\index{Geoms!aliases}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aliased geom & Base geom & Changes in default \\
    \midrule
    area      & ribbon & \verb!aes(min = 0, max = y), position = "stack"!  \\
    density   & area   & \verb!stat = "density"!    \\
    freqpoly  & line   & \verb!stat = "bin"!        \\
    histogram & bar    & \verb!stat = "bin"!        \\
    jitter    & point  & \verb!position = "jitter"! \\
    quantile  & line   & \verb!stat = "quantile"!   \\
    smooth    & ribbon & \verb!stat = "smooth"!     \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms that were created by modifying the defaults of another geom.}
  \label{tbl:aliased-geoms}
\end{table}

\subsection{Displaying precomputed statistics}\label{sub:precomputed}

If you have data which has already been summarised, and you just want to
use it, you'll need to use \texttt{stat\_identity}, which leaves the
data unchanged, and then map the appropriate variables to the
appropriate aesthetics. \index{Stats!precomputed} \indexf{stat_identity}

\hyperdef{}{sub:different-aesthetics}{\subsection{Varying aesthetics and
data}\label{sub:different-aesthetics}}

One of the more powerful capabilities of \texttt{ggplot} is the ability
to plot different datasets on different layers. This may seem strange:
Why would you want to plot different data on the same plot? In practice,
you often have related datasets that should be shown together. A very
common example is supplementing the data with predictions from a model.
While the smooth geom can add a wide range of different smooths to your
plot, it is no substitute for an external quantitative model that
summarises your understanding of the data.

Let's look again at the \texttt{Oxboys} dataset which was used in
\hyperref[sub:grouping]{grouping}. In Figure \ref{fig:group-smooths}, we
showed linear fits for individual boys (left) and for the whole group
(right). Neither model is particularly appropriate: The group model
ignores the within-subject correlation and the individual model doesn't
use information about the typical growth pattern to more accurately
predict individuals. In practice we might use a mixed model to do
better. This section explores how we can combine the output from this
more sophisticated model with the original data to gain more insight
into both the data and the model. \index{Model!diagnostics}

First we'll load the \textbf{nlme} package, and fit a model with varying
intercepts and slopes. (Exploring the fit of individual models shows
that this is a reasonable first pass.) We'll also create a plot to use
as a template. This regenerates the first plot in Figure
\ref{fig:group-lines}, but we're not going to render it until we've
added data from the model.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(}\StringTok{"nlme"}\NormalTok{)}
\NormalTok{>}\StringTok{ }\NormalTok{model <-}\StringTok{ }\KeywordTok{lme}\NormalTok{(height ~}\StringTok{ }\NormalTok{age, }\DataTypeTok{data =} \NormalTok{Oxboys, }
\NormalTok{+}\StringTok{  }\DataTypeTok{random =} \NormalTok{~}\StringTok{ }\DecValTok{1} \NormalTok{+}\StringTok{ }\NormalTok{age |}\StringTok{ }\NormalTok{Subject)}
\NormalTok{>}\StringTok{ }\NormalTok{oplot <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(Oxboys, }\KeywordTok{aes}\NormalTok{(age, height, }\DataTypeTok{group =} \NormalTok{Subject)) +}\StringTok{ }
\NormalTok{+}\StringTok{   }\KeywordTok{geom_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Next we'll compare the predicted trajectories to the actual
trajectories. We do this by building up a grid that contains all
combinations of ages and subjects. This is overkill for this simple
linear case, where we only need two values of age to draw the predicted
straight line, but we show it here because it is necessary when the
model is more complex. Next we add the predictions from the model back
into this dataset, as a variable called \texttt{height}.
\indexf{geom_line}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{age_grid <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(-}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DataTypeTok{length =} \DecValTok{10}\NormalTok{)}
\NormalTok{>}\StringTok{ }\NormalTok{subjects <-}\StringTok{ }\KeywordTok{unique}\NormalTok{(Oxboys$Subject)}
\NormalTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{preds <-}\StringTok{ }\KeywordTok{expand.grid}\NormalTok{(}\DataTypeTok{age =} \NormalTok{age_grid, }\DataTypeTok{Subject =} \NormalTok{subjects)}
\NormalTok{>}\StringTok{ }\NormalTok{preds$height <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(model, preds)}
\end{Highlighting}
\end{Shaded}

Once we have the predictions we can display them along with the original
data. Because we have used the same variable names as the original
\texttt{Oxboys} dataset, and we want the same group aesthetic, we don't
need to specify any aesthetics; we only need to override the default
dataset. We also set two aesthetic parameters to make it a bit easier to
compare the predictions to the actual values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{oplot +}\StringTok{ }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{data =} \NormalTok{preds, }\DataTypeTok{colour =} \StringTok{"#3366FF"}\NormalTok{, }\DataTypeTok{size=} \FloatTok{0.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=0.49\linewidth]{figures/layerslayer26-1} \end{flushleft}

It seems that the model does a good job of capturing the high-level
structure of the data, but it's hard to see the details: plots of
longitudinal data are often called spaghetti plots, and with good
reason. Another way to compare the model to the data is to look at
residuals, so let's do that. We add the predictions from the model to
the original data (\texttt{fitted}), calculate residuals
(\texttt{resid}), and add the residuals as well. The next plot is a
little more complicated: We update the plot dataset (recall the use of
\texttt{\%+\%} to update the default data), change the default y
aesthetic to \texttt{resid}, and add a smooth line for all observations.
\indexf{geom_smooth}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{Oxboys$fitted <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(model)}
\NormalTok{>}\StringTok{ }\NormalTok{Oxboys$resid <-}\StringTok{ }\KeywordTok{with}\NormalTok{(Oxboys, fitted -}\StringTok{ }\NormalTok{height)}
\NormalTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{oplot %+%}\StringTok{ }\NormalTok{Oxboys +}\StringTok{ }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{resid) +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=0.49\linewidth]{figures/layerslayer27-1} \end{flushleft}

The smooth line makes it evident that the residuals are not random,
showing a deficiency in the model. We add a quadratic term, refit the
model, recalculate predictions and residuals, and replot. There is now
less evidence of model inadequacy.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>}\StringTok{ }\NormalTok{model2 <-}\StringTok{ }\KeywordTok{update}\NormalTok{(model, height ~}\StringTok{ }\NormalTok{age +}\StringTok{ }\KeywordTok{I}\NormalTok{(age ^}\StringTok{ }\DecValTok{2}\NormalTok{))}
\NormalTok{>}\StringTok{ }\NormalTok{Oxboys$fitted2 <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(model2)}
\NormalTok{>}\StringTok{ }\NormalTok{Oxboys$resid2 <-}\StringTok{ }\KeywordTok{with}\NormalTok{(Oxboys, fitted2 -}\StringTok{ }\NormalTok{height)}
\NormalTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{oplot %+%}\StringTok{ }\NormalTok{Oxboys +}\StringTok{ }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{resid2) +}\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{flushleft}\includegraphics[width=0.49\linewidth]{figures/layerslayer28-1} \end{flushleft}

Notice how easily we were able to modify the plot object. We updated the
data and replotted twice without needing to reinitialise \texttt{oplot}.
Layering in \texttt{ggplot} is designed to work well with the iterative
process of fitting and evaluating models.
