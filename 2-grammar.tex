\input{header.tex}

% decumar<<< 
% source("~/documents/ggplot/ggplot/load.r")
% library(xtable)
% doptions(width=8, height=4.8, lscale=0.5)
% ggopt(axis.color = "black")
% set.seed(1410)
% dsmall <- diamonds[sample(nrow(diamonds), 1000),]
% >>>

\chapter{Understanding the grammar}

\section{Introduction}\label{sec:introduction}

You can choose to use just {\tt qplot}, without any understanding of the underlying grammar, but you will not be able to use the full power of ggplot.  By learning more about the grammar, and the components that make it up, you will be able to create a wider range of plots, as well as being able to combine multiple sources of data, and write functions that operate on plots.

This chapter describes of the grammar of graphics, and how the grammar of ggplot differs from the grammar of \citep{wilkinson:2006}.  In this chapter I will refer to the grammar of ggplot as my grammar, and The Grammar of Graphics as Wilkinson's grammar, and for the remainder of the book it may be assumed that whenever I refer to the grammar, I refer to my grammar.

In this chapter I will present two ways to think about the grammar: as an answer to a question, and as a pipeline of transformations.  You will also learn the R syntax used to create and combine the components to form an actual plot. This chapter is fairly theoretical, so you won't find too many examples of drawing plots.  However, a good understanding of how everything fits together will help you in creating your own plots.   The following chapters, 3-7, describe the different components in depth and provide many practical examples.  

\section{What is a plot?}\label{sec:what_is_a_plot}

One way to think about the grammar of graphics is as a question: what is a plot?  The grammar answers this by describing a plot as a collection of independent components, each describing an independent part of the plot.  There are three basic things we need for a plot: one or more layers, scales to map variables from data space to visual space, and a coordinate system.  These are described below.

\begin{itemize}
  \item One or more layers.  A layer is composed of data and a description of which data variables should be mapped to which aesthetic properties, a geometric object, and a statistical transformation:
  
  \begin{itemize}
  	\item Data is obviously the most important part, and it is what you provide.  This is what you are displaying visually to aid communication or analysis.  You also need to describe how variables in the dataset are mapped to visual properties.  For example, in Figure 2.X we mapped diamond price to y position, carat to y position and colour to colour.
  	
  	\item {\bf Geoms}, short for geometric objects, control the type of plot that you create.  For example, using a point geom will create a scatterplot, while using a line geom will create a line plot.

  	\item {\bf Stats}, or statistical transformations, reduce or augment the data in a statistical manner.  For example, a useful stat is the smoother, which shows the mean of y, conditional on x.  Another common stat is the binner, which bins data in to bins.   Every geom has a default statistic, and every statistic a default geom.  For example, the bin statistic has defaults to using the bar geom to produce a histogram.
  \end{itemize}

  \item A scale for all the aesthetic properties.  {\bf Scales} control the mapping from data attributes to aesthetic attributes.  They also provide an inverse mapping in the form of a guide, an axis or legend, which facilitates reading the final graphic.  Aesthetic attributes are things like position, size, colour---anything that you can perceive.  The function that maps data to aesthetic attributes is a scale. It takes values in data space (continuous or categorical) and maps them into an aesthetic space (eg. colour, size, shape).  A scale also provides guides to convert back from the aesthetic attribute to the original data.  Guides are either axes (for position) or legends (for everything else)

  \item A coordinate system.  A {\bf coord}, or coordinate systems, maps the position of objects on to the plane of the plot.  Typically we will use the cartesian coordinate system, but sometimes others are useful.
\end{itemize}

There is also another thing that turns out to be sufficiently useful that we should include it in our general framework: facetting (also known as conditioned or trellis plots). This allows us to easily create small multiples of different subsets of an entire dataset. This is a powerful tool when investigating whether patterns hold across all conditions.

To clarify the role of each of these elements, here are a couple of simple examples, taken from Chapter 2.  First, we'll start with a bubble chart of price by carat, with size proportional to the clarity of the diamond.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, size=clarity)
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, size = clarity)
\includegraphics[scale=0.5]{./include/a93a648e1fc6260da923c5e970b76a87}

\end{alltt}
% >>>

This plot has one layer, three scales and a cartesian coordinate system.  To make these parts more clear, we can instead create the plot using these commands:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, aes(x = carat, y = price, size = clarity),
  geom = "point", stat = "identity"
)
\end{alltt}

This makes the single layer obvious, it uses a point geom and the identity transformation, but where are the definitions of the scales and the coordinate system?  By default, ggplot automatically adds sensible scales and the default coordinate system, however, we can be more explicit and add them ourselves:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price, colour = clarity),
  geom = "point", stat = "identity"
) + 
scale_size() + 
scale_y_continuous() + 
scale_x_continuous() + 
coord_cartesian()
\end{alltt}

Compared to the initial qplot example, this is extremely verbose, but perfectly explicit.  We  can clearly see the single layer, the three scales (x position, y position and size) and the coordinate system.  

The next example includes multiple layers, and demonstrates the effect of modifying the scale parameters.  This is another example from chapter two: a scatterplot of price vs carat, with logged axes and a linear smooth layered on top.  The qplot code is shown below.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, geom=c("smooth", "point"), method="lm", log="xy")
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("smooth", "point"), 
+     method = "lm", log = "xy")
\includegraphics[scale=0.5]{./include/9dbf752d1450a53b3313b99f21c5f22c}

\end{alltt}
% >>>

Here we have two layers, two scales and the same cartesian coordinate system:

\begin{alltt}
ggplot() + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price),
  geom = "point", stat = "identity"
) + 
layer(
  data = diamonds, mapping = aes(x = carat, y = price),
  geom = "smooth", stat = "smooth", method = "lm"
  
) + 
scale_y_log10() + 
scale_x_log10() + 
coord_cartesian()
\end{alltt}

There is some duplication in this example, which we can reduce by using plot defaults.

\begin{alltt}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) + 
layer(geom = "point", stat = "identity") + 
layer(geom = "smooth", stat = "smooth", method = "lm") + 
scale_y_log10() + 
scale_x_log10() + 
coord_cartesian()
\end{alltt}

\subsection{Differences from Wilkinson's grammar}

The breakdown into components is very similar Wilkinson's grammar, but there are some important differences.  In Wilkinson's grammar, there is no notion of a layer, and there are few examples where multiple datasets are plotted on the same figure.  There are also three components that are missing in my grammar: the algebra, the transformations, and the guides.  These are not included in ggplot because they can performed using other functionality in R:

\begin{itemize}
	\item The algebra describes how to reshape data for display.  In R, this can be done instead with the reshape package \citep{reshape}.  This is part of my philosophy that data manipulation should be separate from display.

	\item The explicit transformation stage was dropped because variable transformations are already so easy in R: they do not need to be part of the grammar.
	
	\item In ggplot, guides (axes and legends) are largely drawn automatically.  For example, in Wilkinson's grammar you explicitly specify that you want a legend, or how the axes should be annotated, but this is determined by the scale in ggplot.  Annotative guides can be created with geoms if data dependent, or grid can be used to draw directly onto the plot.
\end{itemize}

Finally, I have renamed the element component to geom (after consultation with Lee Wilkinson) to make the name less generic.  

% \section{The pipeline}\label{sec:the_pipeline}
% 
% Another way of thinking about the grammar of graphics is as a pipeline which takes in raw data and outputs plots.  Each stage of the pipeline performs a transformation described by one of the components of the grammar.  For example, one of the first stages performs the statistical transformation described by the stat component.  
% 
% [Insert diagram of the pipelines here.]
% 
% You will notice there are two passes of the 
% 
% 
% \subsection{Differences from Wilkinson's grammar}
% 
% The pipelines of ggplot and the GoG differ slightly.  In ggplot, every stage takes a data frame as input and returns a data frame as output, apart from the final stage, which outputs grid grobs (graphical objects).  The GoG has three intermediate data formats: a varset (the same as a data frame), a graph and a graphic.
% 
% [Insert diagram of the pipelines here.]
% 
% The pipeline is a little more complicated when multiple data sources and geoms are involved.  The complication arises because all data must share the same scales and coordinate system, but may use different mappings, geoms and statistics.  All pipelines must share the same coordinate system, so this is where the connection occurs.  For this reason, ggplot has the layer, as discussed above, which combines the geom, stat, data and mapping.
% 
% [Insert more complicated diagram here]

\section{Converting between grammar syntaxes}

The biggest difference between Lee's grammar and mine is how the grammar is written; the syntax of the grammars are quite different.  The Grammar of Graphics uses two specifications.  A concise format is used to caption figures, and a more detailed xml format stored on disk.  The following example of the concise format is adapted from \citet[][Figure 1.5, page 13]{wilkinson:2006}.

\begin{verbatim}
DATA: source("demographics")
DATA: longitude, latitude = map(source("World"))
TRANS: bd = max(birth - death, 0)
COORD: project.mercator()
ELEMENT: point(position(lon * lat), size(bf), color(color.red))
ELEMENT: polygon(position(longitude * latitude))
\end{verbatim}

This is relatively simple to adapt to the syntax of ggplot:

\begin{itemize}
	
	\item {\tt ggplot()} is used to specify the default data and default aesthetic mappings.  {\tt aes} is short for aesthetic mapping and specifies which variables in the data should be mapped to which aesthetic attributes.
	
	\item Data is provided as standard R data.frames existing in the global environment; it does not need to be explicitly loaded.  We also use a slightly different world data set, with columns lat and long.  This lets us use the same aesthetic mappings for both datasets. Layers can override the default data and aesthetic mappings provided by the plot. 
	
	\item We replace {\sf TRANS} with an explicit transformation by R code.

	\item {\sf ELEMENT}s are replaced with layers, which explicitly specify where the data comes from.  Each geom has a default statistic which is used to transform the data prior to plotting.  For the geoms in this example, the default statistic is the identity function.  Fixed aesthetics (the colour red in this example) are supplied as additional arguments to the layer, rather than as special constants.

	\item The {\sf SCALE} component has been omitted from this example (so that the defaults are used)In both the ggplot and GoG examples, scales are defined by default.  In ggplot you can override the defaults by adding a scale object, e.g. {\tt scale\_colour} or {\tt scale\_size}

	\item {\sf COORD} uses a slightly different format.  In general, most of the components specifications in ggplot are slightly different to those in GoG, in order to be more familiar to R users.

	\item Each component is added together with $+$ to create the final plot

\end{itemize}

This gives us:

\begin{verbatim}
demographics <- transform(demographics, bd = max(birth - death, 0))

ggplot(data = demographic, mapping = aes(x = lon, y = lat)) + 
layer(geom = "point", mapping = aes(size = bd), colour="red") +
layer(geom = "polygon", data = world) +
coord_map(projection = "mercator")
\end{verbatim}




\input{footer.tex}
