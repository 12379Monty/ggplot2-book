\input{header.tex}

% decumar<<< 
% library(ggplot)
% doptions(width=6, height=4)
% .img(.print( <- function(...) .img(.print(qplot(...)))
% >>>

% decumar <<< 
% interweave({
% })
% |||
% >>>
\dominitoc \faketableofcontents

\setchapterpreamble[u]{% 
\dictum[Friedrich Nietzsche]{He who fights with monsters might take care lest he thereby become a monster. And if you gaze for long into an abyss, the abyss gazes also into you.}} 
\chapter{Getting started with ggplot: qplot}

%\minitoc

\section{Introduction}

Plotting data is the most important part of a graphics package and this chapter gets you started with you first ggplot function, {\tt qplot} (short for {\bf q}uick plot).  If you have used the {\tt plot} function in base R before, {\tt qplot} should be easy to use as most of the arguments have the same use.  While you don't get full control over the options with {\tt qplot}, you can start producing plots very quickly. 

\section{Basic use}\label{sec:basic_use}

Remember that you can get a summary of this chapter within R using {\tt ?qplot}.

Let get started using {\tt qplot}.  Just like {\tt plot}, the first two arguments are {\tt x} and {\tt x}, giving the x- and y-coordinates for the objects on the plot.  

There is also an optional {\tt data} argument.  If this is specified, {\tt qplot} will look inside that data frame first before looking for objects in your workspace.  I'd highly recommend that you store all the data necessary in one data.frame.  This makes it very easy to produce the same plot for different data sets.  A single data.frame is also easier to save than a multitude of vectors, which means it's easier to reproduce your results later or send them to someone else.  Chapter XXX provides more suggestions on the best way to deal with your data.  

\begin{figure}[htbp]
	\begin{center}
		% decumar<<< 
		% .img(.print(qplot(mpg, wt, data=mtcars)))
		% |||
\includegraphics[scale=1]{./include/280ea111effb4b6398794ce57fefed0c-001.pdf}
		% >>>
	\end{center}
	\caption{{\tt qplot(mpg, wt, data=mtcars)}}
	
	\label{fig:first}
\end{figure}

Figure \ref{fig:first} shows a simple example of using {\tt qplot}.

The big difference with using {\tt qplot} compared to traditional R graphics comes when you want to assign visual properties, e.g. colours or sizes to your plot.  In the past, you always had to work out how to convert your data (eg. ``apples'', ``bananas'', ``pears'') to something that the plot knew how to use (eg. ``red'', ``yellow'', ``green'').  Now, {\tt qplot} will do this for you automatically, and provide a legend to make it easier to map back from the appearance on the plot to the original data values.

Figure XXX demonstrates three visual attributes that apply to points: colour, size and shape.   Notice that a legend is automatically displayed for each of them.  Colour and shape work well with categorical variables, while size works better with continuous variables.  You can always convert a continuous variable to a categorical one using the {\tt chop} function.

Thoroughout the rest of the book, I will avoid using colour alone so that the book still makes sense plotted in black and white.  To this end, there is a special {\tt group} visual attribute which will map a variable to multiple visual attributes, and produce only one legend.  (This was inspired by the lattice {\tt group} argument which performs much the same role.).  This is shown in figure XXX.

% decumar<<< 
% .img(.print(qplot(mpg, wt, data=mtcars, colour=cyl)))
% catn()
% .img(.print(qplot(mpg, wt, data=mtcars, size=factor(cyl))), lscale=0.5)
% .img(.print(qplot(mpg, wt, data=mtcars, shape=cyl)), lscale=0.5)
% #.img(.print(qplot(mpg, wt, data=mtcars, group=cyl)), lscale=0.5)
% |||
\includegraphics[scale=1]{./include/8619fc99b901709d6a94acf854e77166-001.pdf}

\includegraphics[scale=0.5]{./include/377ce93cf309882725b0fce8967a6e7f-001.pdf}
\includegraphics[scale=0.5]{./include/447474a097d579e496ff027075cd81a3-001.pdf}
% >>>

Note that you are not limited to specifying names of existing vectors.  You can apply functions to them or create new ones, as shown in this example.

\begin{verbatim}
qplot(rnorm(10), rnorm(10))
qplot(mpg ^ 2, wt * 3 + 1, data=mtcars)
\end{verbatim}

However, I recommend that you create the columsn explicitly.

\section{Plot types}\label{sec:plot_types}

By default, the plot uses points to create a scatterplot, but you can easily change this using the the {\tt type} argument.  The {\tt type} argument controls the type of graphical objects that appear on the plot.  Unlike traditional graphics, the appearance of the plot is determined by what graphical objects you add, not the type of the plot. 

Simple plot types just display the data in some way.  Some of the simple plots types availabe in ggplot are:

\begin{itemize}
	\item points (the default), produces scatterplot
	\item paths and lines, draw lines between the data points.  
	\item bars, for barcharts
	\item error bars, to help indicate uncertainty associated with measurements
	\item box and whisker plot, to summarise the distribution of a set of points
\end{itemize}

More complicated plot types perform some kind of statistical processing on the data first.

\begin{itemize}
	\item smooth, fits a smoother to the data and displays the smooth and standard errors.  You can change the type of smooth using the 
	\item contours
	\item histogram
	\item densityplot
\end{itemize}

Visual attributes:

\begin{itemize}
	\item colour
	\item size
	\item shape
	\item id
	\item weight
\end{itemize}

These correspond to the graphical objects (grobs) described in chapter XXX, and you can find out more about them there.  To get help on the different options that these types take, add {\tt gg} to the front of their name and look them up with {\tt ?}. For example, if you want help on the point type, you will need {\tt ?ggpoint}. 

If you provide a vector of type names, the types will be overlayed in the order that you specified them:

% decumar<<< 
% .img(.print(qplot(mpg, wt, data=mtcars, type=c("line", "point"))))
% |||
\includegraphics[scale=1]{./include/65ee3f9ccb33b22e6690cda02ffb8346-001.pdf}
% >>>

In the following sections, I illustrate {\tt qplot} using some of the most commonly used plot types: line and path plots, bar charts, error bars, smooths and histograms.  You can find out more about these plot types in chapter XXX.  However, in most places they are prefixed by {\tt gg} to disambiguate them from other R functions with the same name.

\subsection{Line and path plot}\label{sub:line_plot}

Line and path plots take the following options in addition to .  Remember that the difference between line and path plots is that line plots always join the points from left to right, path plots join them in the order that they appear in the data set.

\begin{itemize}
	\item {\tt linetype}: The type of the line, dotted, dashed etc.
	\item {\tt id}: A variable that identifies different lines.  If a line is represented by multiple variables, use {\tt interaction} to create a single key from them.
\end{itemize}

Just like with points, you can use {\tt colour} and {\tt size} to control the colour and size of the lines respectively.

% decumar<<< 
% .img(.print(qplot(time, potato, data=french_fries, type="line", id=interaction(subject,treatment,rep))), lscale=0.5)
% .img(.print(qplot(time, potato, data=french_fries, col=treatment, type="line", id=interaction(subject,treatment,rep))), lscale=0.5)
% |||
\includegraphics[scale=0.5]{./include/73f179e15a9b48317bbb5b226af83048-001.pdf}
\includegraphics[scale=0.5]{./include/c83721ac4f289ca11a5c531ce4b52343-001.pdf}
% >>>

\subsection{Bar plots}\label{sub:bar_plots}

Bar plot are typically used for displaying categorical data.  Bar plots in {\tt ggplot} can be adjusted to be stacked or dodged (displayed side-by-side) using the {\tt position} argument.  For bar plots, there is really only one visual attribute that you can control, {\tt fill}, because all of the others are constrained by the shape of the bar.	


\section{Combining plots}\label{sec:combining_plots}

You can also use qplot to add more elements to an existing plot.  This is useful when building up a plot from multiple data sources.  Note, however, that there are some limitations on legends which means that you may need to arrange your data into one data frame first.  XXX describes this in detail.

Doing this is pretty easy: all you have to do is save the output of the {\tt qplot} function and pass it as the {\tt add} argument to the next {\tt qplot} call.

\begin{altt}
p <- qplot(wt, mpg, data=mtcars)
qplot(add=p)	
\end{altt}

Notice that the scales automatically increase to make sure that all data points are displayed.

\subsection{Error bars}\label{sub:error_bars}

This type allows you to easily add error bars to your plot.  Calculating them is left up to you because there are so many different types. 

If you have symmetric confidence intervals you can specify upper or lower, if they are asymmetric you must specify both.  The values of {\tt upper} and {\tt lower} should be the offsets from the estimated value, not the values of the confidence interval.

Please remember that in many analyses combining point wise confidence intervals does not give the correct result.

\section{Facetting}\label{sec:facetting}

Facetting allows you to display small multiples of subsets of your data.  It is very similar to trellising or latticing (reference), but currently a little more restricted.  Facetting always produces a grid of facets, each containing a single plot.  You have control over how the grid is broken down into columns and rows.  Facetting is specified by a facetting formula which looks like $row\_var1 + row\_var2 \sim col\_var1 + col\_var2$.  You can specify as many row and column variables as you like, but in most cases more than one or two variables will produce a plot so large that it is difficult to see on screen.  If you want to facet on columns, or rows, not both, you can use {\tt .} as a place holder.  For example, $row\_var1 \sim .$ will facet by rows with a single variable.  This may sound a little complicated but it is easy to use in practice.

Facetting is useful to investigate conditional relationships, e.g. conditional on sex, what is the relationship between amount of smoking and lung cancer.  Facetting can also be useful for creating tables of graphics, although you may need to rearrange your data with {\tt melt} and {\tt cast} first.  For some examples of this, see chapter XXX.

If you want to facet on a continuous variable, you will first need to convert it into a categorical variable.  The {\tt chop} function provides a number of ways to do this, including creating equally spaced intervals, or intervals with equal numbers of points in (recommended).  Currently shingles (overlapping continuous subsets) are not supported.  

\subsection{Margins}\label{sub:margins}

Facetting a plot like this is very much like creating a contigency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics, as with the {\tt margins} argument to {\tt qplot}.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex","age" )}.  You can also use {\tt "grand\_row"} or {\tt "grand\_col"} to produce grand row and grand column margins respectively.

\section{Other options}\label{sec:other_options}

There are a few other options that {\tt qplot} provides to control the output of your graphic.  These all have the same effect as their {\tt plot} equivalents.

\begin{itemize}
	\item {\tt xlim}, {\tt ylim}: limits for the x- and y-axes, each a numeric vector of length two, e.g. {\tt xlim=c(0, 20)} or {\tt ylim=c(-0.9, -0.5)}.
	\item {\tt log}: a character vector indicating which (if any) axes should be logged.  For example, {\tt log="x"} will log the x-axis, {\tt log="xy"} will log both.
	\item {\tt main}: main title for the plot, displayed in large text at the top-centre of the plot.  This can be a string (eg. {\tt main="plot title"}) or an expression (eg. {\tt main = expression(beta[1] == 1)}).  See {\tt ?plotmath} for more exampels of using mathematical formulae.
	\item {\tt xlab}, {\tt y-lab}: labels for the x- and y-axes.  As with the plot title, these can be character strings or mathematical expressions.
\end{itemize}

The following examples shows the options in action.

\begin{verbatim}
qplot(wt, mpg, data=mtcars, 
  xlab="miles per gallon", ylab="weight", 
  main="Fuel effeciency")

qplot(wt, mpg, data=mtcars, 
  xlab=expression(miles/gallon), ylab="weight", 
  main="Small cars", ylim=c(10,20))

qplot(wt, mpg, data=mtcars, 
  main="Small cars", ylim=c(10,20), log="xy")
\end{verbatim}

\section{Weighted data}\label{sec:weighted_data}

When you have aggregated data where each row in the dataset represents multiple observations, you need some way to take into account the weighting variable.  There are two aesthetic attributes that control this in {\tt ggplot}.  Firstly, for simple graphical objects like lines and points, you can make the size of the grob proportional to the number of points, using the size aesthetic. eg:

\begin{alltt}
qplot(x, y, size=w)
qplot(x, y, size=w, id=id, type="line")
\end{alltt}

For more complicate grobs which involve some statistical transformation, you need to use the {\tt weight} argument.  These weights will be passed on to the statistical summary function.  Weights are supported for every case where it makes sense: smoothers ({\tt smooth}), quantile regression ({\tt quantile}), box plots ({\tt boxplot}), hexagon plots ({\tt hexagon}), histograms ({\tt histogram}), and density plots ({\tt density}).  You can't see this weighting variable directly, and it doesn't produce a legend, but it will change the results of the statistical summary.

\begin{alltt}
qplot(wt, mpg, data=mtcars, type=c("point", "smooth"), method=lm)
qplot(wt, mpg, data=mtcars, weight=cyl, size=cyl, type=c("point", "smooth"), method=lm)

qplot(wt, data=mtcars, type=c("density", "histogram"))
qplot(wt, data=mtcars, weight=cyl, type=c("density", "histogram"))
\end{alltt}



\section{Summary}

In this chapter you have learned how to use {\tt qplot} to create plots quickly and easily. You have learned how to:

\begin{itemize}
	\item change the plot type to create many different types of plots
	\item use facets and margining to explore condition and marginal relationships
	\item fine tune the appearance of your graphic using additional options
\end{itemize}

While it is very easy to create a plot with {\tt qplot}, you don't have that much control over the options for each graphic type.  The next chapter teaches you about the components of a plot and how to build up a plot piece by piece.  This gives you full control and lets you exercise the full powers of ggplot.  



\input{footer.tex}
