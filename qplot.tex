\input{header.tex}


% qplot chapter suggestions:
% 
% * exercises - see plot and then try and create on your own
% * wall chart of different plot types
% * more error bar and ribbon examples
% * conclusion weak
% * more info about bin widths
% * expand on span, adjust etc
% * table of options

% decumar<<< 
% library(ggplot2)
% library(xtable)
% doptions(width=8, height=4.8, lscale=0.5)
% ggopt(axis.color = "black")
% >>>

%\setchapterpreamble[u]{% 
%\dictum[Friedrich Nietzsche]{He who fights with monsters might take care lest he thereby become a monster. And if you gaze for long into an abyss, the abyss gazes also into you.}} 

\chapter{Getting started with ggplot: {\tt qplot}}

\section{Introduction} 

In this chapter, you will learn to make a wide variety of plots with your first ggplot function, {\tt qplot}, short for {\bf q}uick plot. qplot makes it easy to produce complex plots, normally requiring several lines of code in R, in one line. qplot can do this because it's based on the grammar of graphics, which allows users to create simple yet expressive descriptions of the plot.  In later chapters you will learn to fully use the expressive power of the grammar, here you'll get started reproducing relatively simple plots.

{\tt qplot} has been designed be very similar to {\tt plot}, which should make it easy if you're already familiar with plotting in R.  Remember, during an R session you can get a summary of all the arguments to {\tt qplot} with R help, {\tt ?qplot}.

This section with cover: 

\begin{itemize}
	\item Basic use
	\item Mapping variables to aesthetic attributes (colour, size, shape, etc)
	\item Creating many different types of plots by specifying different geoms
	\item Combining plots 
	\item Facetting, or conditioned plots
	\item Specifying some basic scale options
\end{itemize}

\section{Data sets}\label{sec:data_sets}

This mainly uses one dataset so you can get familiar with the details of the plot rather than having to familiarise yourself with different datasets.  The {\tt diamonds} dataset consists of prices and quality information about 54,000 diamonds.  The dataset has not been well cleaned, so as well as demonstrating interesting relationships about diamonds, it also demonstrates some data quality problems.  We'll also use another dataset, {\tt dsmall}, which is a random sample of 1000 points.  We'll use this for plots which are more appropriate for smaller datasets.

The first few rows of the data are shown in \ref{tab:diamonds}.  The diamonds dataset is included in the the ggplot package.

% decumar<<< 
% xtable(head(diamonds), digits=c(0,1,0,0,0,1,1,0,0,2,2,2), align="l|rrrrrrrrrrr", label="tab:diamonds", caption="{\tt diamonds} dataset")
% |||
% latex table generated in R 2.4.1 by xtable 1.3-2 package
% Tue Mar  6 21:40:26 2007
\begin{table}[ht]
\begin{center}
\begin{tabular}{l|rrrrrrrrrrr}
\hline
 & shape & carat & cut & colour & clarity & depth & table & price & x & y & z \\
\hline
1 & Round & 0 & Ideal & E & SI2 & 61.5 & 55 & 326 & 3.95 & 3.98 & 2.43 \\
2 & Round & 0 & Premium & E & SI1 & 59.8 & 61 & 326 & 3.89 & 3.84 & 2.31 \\
3 & Round & 0 & Good & E & VS1 & 56.9 & 65 & 327 & 4.05 & 4.07 & 2.31 \\
4 & Round & 0 & Premium & I & VS2 & 62.4 & 58 & 334 & 4.20 & 4.23 & 2.63 \\
5 & Round & 0 & Good & J & SI2 & 63.3 & 58 & 335 & 4.34 & 4.35 & 2.75 \\
6 & Round & 0 & Very Good & J & VVS2 & 62.8 & 57 & 336 & 3.94 & 3.96 & 2.48 \\
\hline
\end{tabular}
\caption{{	t diamonds} dataset}
\label{tab:diamonds}
\end{center}
\end{table}
% >>>

\section{Basic use}\label{sec:basic_use}

Just like {\tt plot}, the first two arguments to {\tt qplot} are {\tt x} and {\tt y}, giving the x- and y-coordinates for the objects on the plot. There is also an optional {\tt data} argument.  If this is specified, {\tt qplot} will look inside that data frame before looking for objects in your workspace.  It's generally a good idea to keep all the data for one plot in a data frame.

Here is a simple example of using {\tt qplot}, investigating the relationship between price and carats (weight) of a diamond.  

% decumar<<< 
% interweave({
% set.seed(1410)
% dsmall <- diamonds[sample(nrow(diamonds), 1000),]
% qplot(carat, price, data=diamonds)
% })
% |||
\begin{alltt}
> set.seed(1410)
> dsmall <- diamonds[sample(nrow(diamonds), 1000), ]
> qplot(carat, price, data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/0baf29f25c89677169ec435f350aa565.pdf}
\begin{alltt}

\end{alltt}
% >>>

You are not limited to specifying names of existing vectors: you can use functions of them as well.  Here we look at the relationship of log(price) to log(weight), and the relationship between weight and volume ($x * y * z$).

% decumar<<< 
% interweave({
% qplot(log(carat), log(price), data=diamonds)
% qplot(carat, x * y * z, data=diamonds)
% })
% |||
\begin{alltt}
> qplot(log(carat), log(price), data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/03f77ea59e293c88366f997d5d1fc6c9.pdf}
\begin{alltt}

> qplot(carat, x * y * z, data = diamonds)
\end{alltt}
\includegraphics[scale=0.5]{./include/949428bef1dd9d390e6b8622eabfda74.pdf}
\begin{alltt}

\end{alltt}
% >>>

These plots illustrate some unusual features of this dataset.  There seems to be a narrow bands of prices for which there are no diamonds, and there are some diamonds with very unusual volumes for their weight.  We will investigate these relationships more as we continue.

\section{Aesthetic attributes}\label{sec:aesthetic_attributes}

The first big difference with using {\tt qplot} compared to {\tt plot} when you want to assign colours, or sizes or shapes, to the points on your plot.  With {\tt plot}, it's your responsibility to change your data (eg. ``apples'', ``bananas'', ``pears'') into something that {\tt plot} knows how to use (eg. ``red'', ``yellow'', ``green'').  {\tt qplot} will do this for you automatically, and will automatically provide a legend to make it easier to map back from the plot to the original data values.  This makes it easy to include additional data on the plot.  In the next example, we augment the plot of carat and price with information about colour, clarity and cut of the diamonds.

% decumar<<< 
% interweave({
% qplot(carat, price, data=dsmall, colour=colour)
% qplot(carat, price, data=dsmall, size=clarity)
% qplot(carat, price, data=dsmall, shape=cut)
% })
% |||
\begin{alltt}
> qplot(carat, price, data = dsmall, colour = colour)
\end{alltt}
\includegraphics[scale=0.5]{./include/73588db0580f3ca4603f29174a0df502.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, size = clarity)
\end{alltt}
\includegraphics[scale=0.5]{./include/35e3ab5cbcfb1a1aae58b0b21307cb3f.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, shape = cut)
\end{alltt}
\includegraphics[scale=0.5]{./include/198a18bf1540b70cdfe0bcaea3fad7d4.pdf}
\begin{alltt}

\end{alltt}
% >>>

Colour, size and shape are all examples of aesthetic attributes.  An aesthetic attribute is some property that affects how the observations are displayed.  For every aesthetic attribute, there is some function, called a scale, which maps data values to valid values for that aesthetic.  It is this scale that controls how the points appear.  For example, in the above plots, the colour scale makes XXX.  We will learn how to configure this in Chapter XXX.

Different types of aesthetic attributes work better with different types of variables.  For example, colour and shape work well with categorical variables, while size works better with continuous variables.  Size works poorly when you have a lot of data, because you can't distinguish the individual points.  You can always convert a continuous variable to a categorical one using the {\tt chop} function.  These issues are discussed more in XXX.

\section{Plot geoms}\label{sec:plot_geoms}

{\tt qplot} is not limited to just producing scatterplots.  In fact, it can produce many plots, by varying the {\bf geom} used. Geom, short for geometric object, describes the type of object that is used to display the data.  Some geoms have an associated statistical transformation, for example, a histogram is a binning statistic plus a bar geometric object.  These different components are described in the next chapter.  Here we'll introduce you to the most common and useful geoms, categorised by whether they are primarily useful for 1D or 2D data.

The following geoms enable you to investigate 2D relationships:

\begin{itemize}
	\item {\tt geom="point"} draws points to produce a scatterplot (the default), described above.
	\item {\tt geom="smooth"} fits a smoother to the data and displays the smooth and its standard error.
	\item {\tt geom="quantiles"} displays conditional quantiles.
	\item {\tt geom="density2d"} adds contours of a 2d density estimate.  Useful when you have a lot of overplotting.
	\item {\tt geom="path"} and {\tt geom="line"} draw lines between the data points, traditionally used to explore relationships between time and another variable, but lines may to be use to join observations connected in some other way.  A line plot is constrained to produce lines that travel from left to right, while paths can go in any direction.
	\item {\tt geom="errorbar"} adds error bars to help indicate uncertainty associated with measurements.
	\item {\tt geom="boxplot"} produces a box and whisker plot to summarise the distribution of a set of points.
\end{itemize}

These geoms are useful for exploring 1d distributions:

\begin{itemize}
	\item {\tt geom="histogram"} draws a histogram of the $x$ variable
	\item {\tt geom="density"} creates a density plot for the $x$ variable
	\item {\tt geom="bar"} makes a barchart.
\end{itemize}

Each of these geoms are described in turn below.

\subsection{Adding a smoother to a plot}\label{sub:smooth}

If you have a scatterplot with many data points, it can be hard to see exactly what trend is shown by the data.  In this case you may want to add a smoothed line to the plot.  This is easily done using the {\tt smooth} geom:

% decumar<<< 
% interweave({
% qplot(mpg, wt, data=mtcars, geom=c("point", "smooth"))
% })
% |||
\begin{alltt}
> qplot(mpg, wt, data = mtcars, geom = c("point", "smooth"))
\end{alltt}
\includegraphics[scale=0.5]{./include/8bbe4ffff7984e9450e9102e77a55ff5.pdf}
\begin{alltt}

\end{alltt}
% >>>

Notice that we have combined multiple geoms by supplying a vector of geom names to {\tt qplot}.  The geoms will be overlaid in the order that you specified them.

There are many different smoothers you can choose between using the {\tt method} argument:

\begin{itemize}
	\item {\tt method="loess"} (the default) uses a smooth local regression.  More details about the algorithm used can be found in {\tt ?loess}.  You can modify the wiggliness of the line by varying the span between 0 (exceeding wiggly) and 1 (not so wiggly).  Loess does not work well for large datasets, so you'll need to use one of the other methods listed below.

  % decumar<<< 
  % interweave({
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"))
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"), span=0.2)
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"), span=1)
  % })
  % |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("point", "smooth"))
\end{alltt}
\includegraphics[scale=0.5]{./include/ca878a86ce2975319d3b3b8eb10528df-001.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, geom = c("point", "smooth"), 
+     span = 0.2)
\end{alltt}
\includegraphics[scale=0.5]{./include/fe7e76f86d0ec17f065ad5714be0755c-001.pdf}
\begin{alltt}

> qplot(carat, price, data = dsmall, geom = c("point", "smooth"), 
+     span = 1)
\end{alltt}
\includegraphics[scale=0.5]{./include/9c78cff70f86039e7e45e1a27bca03ea-001.pdf}
\begin{alltt}

\end{alltt}
  % >>>

	\item {\tt method="lm"} to fit a linear model.  The default will fit a straight line to your data, or you can specify {\tt formula = y $\sim$ poly(x, 2)} to specify a degree 2 polynomial, or better, load the {\tt splines} library and use a natural spline: {\tt formula = y $\sim$ ns(x, 2)}.  The second parameter is the degrees of freedom: a higher number will create a wigglier curve.

  % decumar<<< 
  % interweave({
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"), method="lm")
  % library(splines)
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"), method="lm", formula=y ~ ns(x,3))
  % })
  % |||
\begin{alltt}
> qplot(carat, price, data = dsmall, geom = c("point", "smooth"), 
+     method = "lm")
\end{alltt}
\includegraphics[scale=0.5]{./include/f095dd08ae5adf75b12648e213abd5d4-001.pdf}
\begin{alltt}

> library(splines)
> qplot(carat, price, data = dsmall, geom = c("point", "smooth"), 
+     method = "lm", formula = y ~ ns(x, 3))
\end{alltt}
\includegraphics[scale=0.5]{./include/bea4d8c27d1a350d8de884b5baad1721-001.pdf}
\begin{alltt}

\end{alltt}
  % >>>

	\item {\tt method="rlm"} works the same as {\tt lm}, but uses a robust fitting algorithm so that outliers don't affect the fit as much.

	\item You could also load the {\tt mgcv} library and use {\tt method="gam", formula = y $\sim$ s(x)} to fit a generalised additive model.  This is similar 
to using a spline with {\tt lm}, but the degree of smoothness is estimated from the data.  For large data, you should use the formula {\tt y $\sim$ s(x, bs="cr")}
 
  % decumar<<< 
  % interweave({
  % library(mgcv)
  % qplot(carat, price, data=dsmall, geom=c("point", "smooth"), method="gam", formula= y ~ s(x))
  % qplot(carat, price, data=diamonds, geom=c("point", "smooth"), method="gam", formula= y ~ s(x, bs="cr"))
  % })
  % |||
\begin{alltt}
> library(mgcv)
> qplot(carat, price, data = dsmall, geom = c("point", "smooth"), 
+     method = "gam", formula = y ~ s(x))
\end{alltt}
\includegraphics[scale=0.5]{./include/4b400d0c94e210c6c409a45970064e2e-001.pdf}
\begin{alltt}

> qplot(carat, price, data = diamonds, geom = c("point", "smooth"), 
+     method = "gam", formula = y ~ s(x, bs = "cr"))
\end{alltt}
\includegraphics[scale=0.5]{./include/02e7a01a5e243d194a0e498101ca60af-001.pdf}
\begin{alltt}

\end{alltt}
  % >>>

\end{itemize}

By default, the standard errors are shown with a grey band around the smoother.  If you want to turn them off, use {\tt se=FALSE}.

\subsection{Quantiles}\label{sub:quantiles}

A smoother displays a smoothed conditional mean.  It's often useful to see a smooth estimate of the spread of the data.  We can do this with quantile regression \citep{koenker:2005}.

Range of smoothes much more limited, but can see many quantiles.  

% qplot(carat, price, data=subset(diamonds, carat < 2), geom=c("point"), xlim=c(0,2)) + 
% stat_quantile(formula=y~ns(x,4))
% 
% qplot(carat, price, data=diamonds, geom=c("point"), xlim=c(0,2), log="xy") + stat_quantile(formula=y~ns(x,4))

For this example, we used the subset option

\subsection{2d density contours}

\subsection{Time series with line and path plots}\label{sub:line_plot}

Line and path plots are typically used for time series data.  Line plots always join the points from left to right, while path plots join them in the order that they appear in the data set (a line plot is just a path plot of the data sorted by x value).  Line plots usually have time on the x-axis, showing how a single variable has changed over time.  Path plots show how two variables have simultaneously changed over time, with time encoded in the way that the points are joined together.

Because there isn't a time variable in the diamonds data, we will create an example data frame to illustrate these types of plots.  This has a very simple sinusoidal pattern in two variables.

% decumar<<< 
% interweave({
% df <- data.frame(year = 1:20, a = sin(1:20 * pi / 5) + rnorm(20, 0, 0.15), b=cos(1:20 * pi / 5)  + rnorm(20, 0, 0.15))
% head(df)
% })
% |||
\begin{alltt}
> df <- data.frame(year = 1:20, a = sin(1:20 * pi/5) + rnorm(20, 
+     0, 0.15), b = cos(1:20 * pi/5) + rnorm(20, 0, 0.15))
> head(df)
  year       a      b
1    1  0.7029  0.655
2    2  0.8779  0.126
3    3  0.9256 -0.261
4    4  0.5448 -0.925
5    5 -0.0346 -1.022
6    6 -0.7987 -1.016

\end{alltt}
% >>>

Let's start with a time series plot of {\tt a}.

% decumar<<< 
% interweave({
% qplot(year, a, data=df, geom="line")
% })
% |||
\begin{alltt}
> qplot(year, a, data = df, geom = "line")
\end{alltt}
\includegraphics[scale=0.5]{./include/f5ebf3350aa117a47ec143f696fe3f38.pdf}
\begin{alltt}

\end{alltt}
% >>>

If we want to display the two variables on the same plot we need to reshape our dataset so that we have a new column which represents the variable the observation was taken on.  The {\tt melt} function from the {\tt reshape} package will do this for us.  Reshaping data is described more in XXX.  Notice that specifying {\tt colour} draws two series.  If we just want to separate series, we can use the {\tt group} aesthetic.

% decumar<<< 
% interweave({
% dfm <- melt(df, id="year")
% head(dfm)
% qplot(year, value, data=dfm, geom="line", colour=variable)
% qplot(year, value, data=dfm, geom="line", group=variable)
% })
% |||
\begin{alltt}
> dfm <- melt(df, id = "year")
> head(dfm)
  year variable   value
1    1        a  0.7029
2    2        a  0.8779
3    3        a  0.9256
4    4        a  0.5448
5    5        a -0.0346
6    6        a -0.7987

> qplot(year, value, data = dfm, geom = "line", colour = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/f36738c054cb10823ba35da0413e91e5.pdf}
\begin{alltt}

> qplot(year, value, data = dfm, geom = "line", group = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/106c1ca1c0e7b255812040e261728ebf.pdf}
\begin{alltt}

\end{alltt}
% >>>

These plots show the behaviour of {\tt a} and {\tt b} individually, but it is not so easy to see the joint pattern.  Each time point occupies a point on the 2d grid of {\tt a} and {\tt b}, and if we joint up each point to its neighbours we get a 2d trajectory.

This can be illustrated with a path plot.  Below we plot {\tt a} vs {\tt b} and then join the individual observations with a path to show the pattern over time.  To make it more obvious in which direction time flows, we can use the {\tt size} aesthetic, as in the second plot.   This allows us to see that it follows a cyclical pattern over time.

% decumar<<< 
% interweave({
% qplot(a, b, data=df, geom="path")
% qplot(a, b, data=df, geom="path", size=year)
% })
% |||
\begin{alltt}
> qplot(a, b, data = df, geom = "path")
\end{alltt}
\includegraphics[scale=0.5]{./include/854460e682bcd1d72e1fe70043c44ea9.pdf}
\begin{alltt}

> qplot(a, b, data = df, geom = "path", size = year)
\end{alltt}
\includegraphics[scale=0.5]{./include/be8e4cd8483f06746863adecc4036033.pdf}
\begin{alltt}

\end{alltt}
% >>>

The examples above illustrate the two most common aesthetics for path and line plots: {\tt colour}, and {\tt size}.  The final aesthetic attribute that line and path plots use is {\tt linetype}, which species the dashing pattern of the line: solid, dashed, dotted etc.

% decumar<<< 
% interweave({
% qplot(year, value, data=dfm, geom="line", linetype=variable)
% })
% |||
\begin{alltt}
> qplot(year, value, data = dfm, geom = "line", linetype = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/a9001be7da0e1bc54ac18f73075a2289.pdf}
\begin{alltt}

\end{alltt}
% >>>


\subsection{Boxplots and jittered points}\label{sub:boxplot}

If you have one categorical variable, and one or more continuous variables, you will probably be interested to know how the values of the continuous variables vary with the categorical.  Box plots and jittered points offer to ways to do this.  

% decumar<<< 
% interweave({
% qplot(colour, price/carat, data=diamonds, geom="jitter")
% qplot(colour, price/carat, data=diamonds, geom="boxplot")
% })
% |||
\begin{alltt}
> qplot(colour, price/carat, data = diamonds, geom = "jitter")
\end{alltt}
\includegraphics[scale=0.5]{./include/53e2b75943b5c36769d2d128a1da17a1.pdf}
\begin{alltt}

> qplot(colour, price/carat, data = diamonds, geom = "boxplot")
\end{alltt}
\includegraphics[scale=0.5]{./include/684ed0dcc04e2b9a43fe2c8e09bb80ce.pdf}
\begin{alltt}

\end{alltt}
% >>>

Both boxplots and jittered points will try to guess which orientation they should lie, and while most of the time they will get it right, sometimes you will need to say exactly what you want.  For the boxplot, use {\tt orientation="horizontal"} or {\tt orientation="vertical"}, and for the jittered points, use {\tt xjitter} and {\tt yjitter} to specify the amount of jittering to use. 

For jittered points, you have the same control over aesthetics as you do with a normal scatterplot: {\tt size}, {\tt colour}, {\tt shape}.  The options for boxplots are more limited (and it is hard to imagine when they would be useful), you can control only the outline colour ({\tt colour}) and the internal fill {\tt fill}.

Another approach is to use histograms facetted by another variable.

\subsection{Histogram and density plots}\label{sub:density}

Histogram and density plots show the distribution of a single variable.  They provide more information about the distribution of a single group than boxplots do, but it is harder to compare many groups (although we will look at one way to do so).

% decumar<<< 
% interweave({
% qplot(price/carat, data=diamonds, geom="histogram")
% qplot(price/carat, data=diamonds, geom="density")
% })
% |||
\begin{alltt}
> qplot(price/carat, data = diamonds, geom = "histogram")
\end{alltt}
\includegraphics[scale=0.5]{./include/0972c0949e081a114ae30f84cdfade30.pdf}
\begin{alltt}

> qplot(price/carat, data = diamonds, geom = "density")
\end{alltt}
\includegraphics[scale=0.5]{./include/903ccf31dfaad36c8c58d896bfc57b7d.pdf}
\begin{alltt}

\end{alltt}
% >>>

You can control the amount of smoothing using the {\tt binwidth} argument for the histogram, which specifies the bin size to use.  You can also specify the break points explicitly, using the {\tt breaks} argument.  For the density plot, you can use {\tt adjust} argument, which adjusts the bandwidth of the smoother (high values of {\tt adjust} produce smoother plots).  It is very important to experiment with the level of smoothing.  With a histogram you should try many bin widths before you decide on the one (or two, or three) which best describe the data.

Density plots are useful in that they are easier to overlay, but a generally less flexible than histograms, and it is more difficult to understand exactly what a density plot is showing.  (And we are {\bf not} trying to estimate a density - we're trying to see what's going on with our datasets)

% decumar<<< 
% interweave({
% qplot(carat, data=diamonds, geom="histogram", binwidth=1)
% qplot(carat, data=diamonds, geom="histogram", binwidth=0.1)
% qplot(carat, data=diamonds, geom="histogram", binwidth=0.01)
% })
% |||
\begin{alltt}
> qplot(carat, data = diamonds, geom = "histogram", binwidth = 1)
\end{alltt}
\includegraphics[scale=0.5]{./include/d0744f916c328539c0b47de1a28f207c.pdf}
\begin{alltt}

> qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.1)
\end{alltt}
\includegraphics[scale=0.5]{./include/8530aef3aa214cb655a9b49b3fce9f1c.pdf}
\begin{alltt}

> qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.01)
\end{alltt}
\includegraphics[scale=0.5]{./include/8ab02a4be4f90505708ad342116c64f7.pdf}
\begin{alltt}

\end{alltt}
% >>>

If you want to compare the distributions of different subgroups, all you need to do is add an aesthetic mapping that differentiates the different groups, as follows:

% decumar<<< 
% interweave({
% qplot(wt, data=mtcars, geom="density", colour=factor(cyl))
% })
% |||
\begin{alltt}
> qplot(wt, data = mtcars, geom = "density", colour = factor(cyl))
\end{alltt}
\includegraphics[scale=0.5]{./include/3b34151a9cf9bb93fcf0176abdd7dc4b.pdf}
\begin{alltt}

\end{alltt}
% >>>

\subsection{Displaying uncertainty with error bars and ribbons}\label{sub:error_bars}

+ Use with statistics

There are two ways to display standard errors with {\tt ggplot}.  For point standard errors, you can use the {\tt errorbar} geom.  For continuous or functional standard errors, you can use the {\tt ribbon} grob.  We've have already seen an example of this: the {\tt ribbon} grob is used inside {\tt smooth} to display the standard errors of the smooth.  Because there are so many different ways to calculate standard errors, the calculation is up to you.  {\tt ggplot} only provides facilities for displaying them once you have them.

For both {\tt ribbon} and {\tt errobar} you can specify confidence internals in two ways:

\begin{itemize}
	\item using {\tt upper} and {\tt lower} which specify the upper and lower edges of the confidence band

	\item using {\tt y}, {\tt plus} and {\tt minus} which specify the estimate and positive and negative displacements (if you only specify one of plus and minus, the other will default to the negative of the one that is supplied)
\end{itemize}

[Need an example here]

\section{Plots for weighted data}\label{sec:weighted_data}

When you have aggregated data where each row in the dataset represents multiple observations, you need some way to take into account the weighting variable.  For an example, we will use some data collected in Midwest states in the 2000 census.  The data consists mainly of percentages (eg. percent white, percent below poverty line, percentage with college degree) and some information for each county (area, total population, population density).

There are few different things we might want to weight by: 

\begin{itemize}
	\item nothing, to look at county numbers
	\item total population, to work with absolute numbers
	\item population density, to investigate relative densities
	\item area, to investigate geographic effects
\end{itemize}

\noindent The choice of a weighting variable profoundly effects what we are looking at in the plot and the conclusions that we will draw.  There are two aesthetic attributes that can be used to adjust for weights.  Firstly, for simple geoms like lines and points, you can make the size of the grob proportional to the number of points, using the {\tt size} aesthetic, as follows:

% decumar<<< 
% interweave({
% #midwest <- read.csv("~/desktop/midwest.csv")
% #qplot(percwhite, percbelowpoverty, data=midwest)
% #qplot(percwhite, percbelowpoverty, data=midwest, size=poptotal)
% #qplot(percwhite, percbelowpoverty, data=midwest, size=area)
% })
% |||
\begin{alltt}
> NULL
NULL
\end{alltt}
% >>>

For more complicated grobs which involve some statistical transformation, we specify weights with the {\tt weight} aesthetic.  These weights will be passed on to the statistical summary function.  Weights are supported for every case where it makes sense: smoothers ({\tt smooth}), quantile regressions ({\tt quantile}), box plots ({\tt boxplot}), hexagon plots ({\tt hexagon}), histograms ({\tt histogram}), and density plots ({\tt density}).  (Most of which we haven't mentioned yet - but you can read about them on pages X, Y, Z).  You can't see this weighting variable directly, and it doesn't produce a legend, but it will change the results of the statistical summary.

The following example shows how weighting by population density effects the relationship between percent white and percent below the poverty line.

% decumar<<< 
% interweave({
% #qplot(percwhite, percbelowpoverty, data=midwest, geom=c("point","smooth"), method=lm)
% #qplot(percwhite, percbelowpoverty, data=midwest, size=popdensity, weight=popdensity,geom=c("point","smooth"), method=lm)
% })
% |||
\begin{alltt}
> NULL
NULL
\end{alltt}
% >>>

When we weight a histogram or density plot by total population, we change from looking at the distribution of the number of counties, to the distribution of the number of people.  This example shows the difference this makes for a histogram and density plot of the percentage below the poverty line.

% decumar<<< 
% interweave({
% #qplot(percbelowpoverty, data=midwest, geom=c("histogram", "density"))
% #qplot(percbelowpoverty, data=midwest, geom=c("histogram", "density"), weight=poptotal/sum(poptotal))
% })
% |||
\begin{alltt}
> NULL
NULL
\end{alltt}
% >>>

Self weighted histogram.

\section{Combining plots}\label{sec:combining_plots}

As we have seen, you can combine multiple plot geoms by supplying a vector of geom names to {\tt qplot}.  The geoms will be overlaid in the order that you specified them:

% decumar<<< 
% interweave({
% qplot(year, value, data=dfm, geom=c("line", "point"), colour=variable)
% qplot(mpg, wt, data=mtcars, geom=c("point", "smooth"))
% qplot(mpg, factor(cyl), data=mtcars, geom=c("jitter", "boxplot"))
% qplot(mpg, factor(cyl), data=mtcars, geom=c("boxplot", "jitter"))
% })
% |||
\begin{alltt}
> qplot(year, value, data = dfm, geom = c("line", "point"), colour = variable)
\end{alltt}
\includegraphics[scale=0.5]{./include/9d7911a4f971b8417284c561d434a242.pdf}
\begin{alltt}

> qplot(mpg, wt, data = mtcars, geom = c("point", "smooth"))
\end{alltt}
\includegraphics[scale=0.5]{./include/48864e8c6fc4988e2872350516edaf7b.pdf}
\begin{alltt}

> qplot(mpg, factor(cyl), data = mtcars, geom = c("jitter", "boxplot"))
\end{alltt}
\includegraphics[scale=0.5]{./include/f8147ba454f6bb4409078c32f4fb733a.pdf}
\begin{alltt}

> qplot(mpg, factor(cyl), data = mtcars, geom = c("boxplot", "jitter"))
\end{alltt}
\includegraphics[scale=0.5]{./include/3703ac5ae18a972b256eac856d916fcc.pdf}
\begin{alltt}

\end{alltt}
% >>>

The limitation with this technique is that you are plotting exactly the same data, but just using a different geom.  You can also use the {\tt add} argument to add more elements to an existing plot.  This is useful when building up a plot from multiple data sources. Doing this is pretty easy: all you have to do is save the output of the {\tt qplot} function and pass it as the {\tt add} argument to the next {\tt qplot} call.

In this example, we add a rug plot to a density plot of weight.

% decumar<<< 
% interweave({
% (p <- qplot(wt, data=mtcars, geom="density", colour=factor(cyl)))
% qplot(wt, 0, add=p)
% qplot(wt, 0, add=p, geom="jitter")
% })
% |||
\begin{alltt}
> (p <- qplot(wt, data = mtcars, geom = "density", colour = factor(cyl)))
\end{alltt}
\includegraphics[scale=0.5]{./include/ba27c01a47edc4738f46b0af10244afe.pdf}
\begin{alltt}

> qplot(wt, 0, add = p)
\end{alltt}
\includegraphics[scale=0.5]{./include/f66ce4d2280108c8d13e6ac5270310c1.pdf}
\begin{alltt}

> qplot(wt, 0, add = p, geom = "jitter")
\end{alltt}
\includegraphics[scale=0.5]{./include/a38d9d44f95db60739b944a9e7474074.pdf}
\begin{alltt}

\end{alltt}
% >>>

In this example, we supplement the scatterplot of mpg vs wt with results from a linear model which fits a quadratic for each number of cylinder. This is a nice demonstration of the perils of extending polynomials outside the bounds of the data.

% decumar<<< 
% interweave({
% (p <- qplot(mpg, wt, data=mtcars, colour=factor(cyl)))
% model <- lm(wt ~ poly(mpg,2) * cyl, data=mtcars)
% grid <- expand.grid(mpg = 10:35, cyl=c(4,6,8))
% grid$fitted <- predict(model, grid)
% qplot(mpg, fitted, data=grid, colour=factor(cyl), geom="line", add=p)
% })
% |||
\begin{alltt}
> (p <- qplot(mpg, wt, data = mtcars, colour = factor(cyl)))
\end{alltt}
\includegraphics[scale=0.5]{./include/b530fd13979d56f57c6253ab36cfc77a.pdf}
\begin{alltt}

> model <- lm(wt ~ poly(mpg, 2) * cyl, data = mtcars)
> grid <- expand.grid(mpg = 10:35, cyl = c(4, 6, 8))
> grid$fitted <- predict(model, grid)
> qplot(mpg, fitted, data = grid, colour = factor(cyl), geom = "line", 
+     add = p)
\end{alltt}
\includegraphics[scale=0.5]{./include/d090358201fe030af4deec641f08947a.pdf}
\begin{alltt}

\end{alltt}
% >>>

Notice that the ranges of the axes automatically increase to make sure that all data points are displayed.

\section{Facetting}\label{sec:facetting}

Facetting allows you to display small multiples of subsets of your data, as in this example where we have a scatterplot of mpg vs wt for each value of cyl:

% decumar<<< 
% interweave({
% qplot(mpg, wt, data=mtcars, facets=. ~ cyl)
% })
% |||
\begin{alltt}
> qplot(mpg, wt, data = mtcars, facets = . ~ cyl)
\end{alltt}
\includegraphics[scale=0.5]{./include/67bf1684a5877a9c6b84d75d26224c45.pdf}
\begin{alltt}

\end{alltt}
% >>>

Each small multiple is called a facet, and contains the same plot for a different subset of the data.  The grid is specified with a facetting formula which looks like $row\_var \sim col\_var $.  You can specify as many row and column variables as you like, but in most cases more than one or two variables will produce a plot so large that it is difficult to see on screen.  If you want to facet on columns, or rows, not both, you can use {\tt .} as a place holder.  For example, $row\_var1 \sim .$ will facet by rows with a single variable.  

% decumar<<< 
% interweave({
% qplot(mpg, wt, data=mtcars, facets=vs ~ cyl)
% })
% |||
\begin{alltt}
> qplot(mpg, wt, data = mtcars, facets = vs ~ cyl)
\end{alltt}
\includegraphics[scale=0.5]{./include/74a602b934ab966ce22b654fa1a33ae8.pdf}
\begin{alltt}

\end{alltt}
% >>>

Facetting is used to investigate conditional relationships, e.g. conditional on sex, what is the relationship between amount of smoking and lung cancer.  Facetting can also be useful for creating tables of graphics.  For some examples of this, and more ways to use facetting, see chapter XXX.

\subsection{Margins}\label{sub:margins}

Facetting a plot is like creating a contingency table.  In contingency tables it is often useful to display marginal totals (totals over a row or column) as well as the individual cells.  It is also useful to be able to do this with graphics.  We can produce graphical margins using the the {\tt margins} argument.  This allows you to compare the conditional patterns with the marginal patterns.

You can either specify that all margins should be displayed, using {\tt margins = TRUE}, or by listing the names of the variables that you want margins for, {\tt margins = c("sex","age")}.  You can also use \verb|"grand_row"| or \verb|"grand_col"| to produce grand row and grand column margins respectively.

This example shows how the margins appear.  In the first plot, there are no margins, and we only see conditional plots.  In the second example, we see margins over columns, but not rows, and in the final example we see all possible margins.  The facet in the lower right corner displays all data points.

% decumar<<< 
% interweave({
% qplot(mpg, wt, facets=vs ~ am, data=mtcars, margins=TRUE)
% })
% |||
\begin{alltt}
> qplot(mpg, wt, facets = vs ~ am, data = mtcars, margins = TRUE)
\end{alltt}
\includegraphics[scale=0.5]{./include/36b316d9a752c19b1c78b9de27acd101.pdf}
\begin{alltt}

\end{alltt}
% >>>

Plots with many facets and margins may be more appropriate for printing, rather than on screen display, as the higher resolution allows you to compare many more subsets.

\section{Other options}\label{sec:other_options}

There are a few other options that {\tt qplot} provides to control the output of your graphic.  These all have the same effect as their {\tt plot} equivalents:

\begin{itemize}
	\item {\tt xlim}, {\tt ylim}: set limits for the x- and y-axes, each a numeric vector of length two, e.g. {\tt xlim=c(0, 20)} or {\tt ylim=c(-0.9, -0.5)}.
	\item {\tt log}: a character vector indicating which (if any) axes should be logged.  For example, {\tt log="x"} will log the x-axis, {\tt log="xy"} will log both.
	\item {\tt main}: main title for the plot, displayed in large text at the top-centre of the plot.  This can be a string (eg. {\tt main="plot title"}) or an expression (eg. {\tt main = expression(beta[1] == 1)}).  See {\tt ?plotmath} for more examples of using mathematical formulae.
	\item {\tt xlab}, {\tt ylab}: labels for the x- and y-axes.  As with the plot title, these can be character strings or mathematical expressions.
\end{itemize}

The following examples show the options in action.

% decumar<<< 
% interweave({
% qplot(wt, mpg, data=mtcars, xlab="miles per gallon", ylab="weight",  main="Fuel effeciency")
% qplot(wt, mpg, data=mtcars, xlab=expression(miles/gallon), ylab="weight",  main="Small cars", ylim=c(10,20))
% qplot(wt, mpg, data=mtcars, main="Small cars", ylim=c(10,20), log="xy")
% })
% |||
\begin{alltt}
> qplot(wt, mpg, data = mtcars, xlab = "miles per gallon", ylab = "weight", 
+     main = "Fuel effeciency")
\end{alltt}
\includegraphics[scale=0.5]{./include/b7f00191162bdab537c3263d679a261f.pdf}
\begin{alltt}

> qplot(wt, mpg, data = mtcars, xlab = expression(miles/gallon), 
+     ylab = "weight", main = "Small cars", ylim = c(10, 20))
\end{alltt}
\includegraphics[scale=0.5]{./include/457a8cb320dcc057ea85c42c9491c57d.pdf}
\begin{alltt}

> qplot(wt, mpg, data = mtcars, main = "Small cars", ylim = c(10, 
+     20), log = "xy")
\end{alltt}
\includegraphics[scale=0.5]{./include/36343c6b8b3947ae66cb9b6f95900b34.pdf}
\begin{alltt}

\end{alltt}
% >>>

\input{footer.tex}
