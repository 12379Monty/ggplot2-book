\input{_header.tex}

% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.5\textwidth
%   INLINE: FALSE
%   CACHE: TRUE
% 

% END

\chapter{Build a plot layer by layer}
\label{cha:layers}

\section{Introduction}

% This is not really true: layering was barely mentioned in the 
% previous chapter, so it needs to be defined here.
% As described in the previous chapter, layers can use different data sets and aesthetic mappings.  When creating a plot with \f{qplot}, you can't access these differences - all layers use the same default dataset and aesthetic mappings.  This means that you can't create certain more complex plots with \f{qplot}.  This chapter outlines an alternative method: building up the plot layer by layer.  

Layering is the mechanism by which additional elements are added to a plot.  Each added element can come from a different dataset and have a different aesthetic mapping, allowing us to create plots that could not be generated using \f{qplot}, which permits only a single dataset and a single aesthetic mapping.

Section~\ref{sec:ggplot} taught you how to initialise a plot object. The plot object is not yet ready to be displayed until at least one layer is added, as as described in Section~\ref{sec:layers}. Sections~\ref{sec:data} and \ref{sec:aes} describe the data and aesthetic mappings in more detail, including more information about how layer settings override the plot defaults, the difference between setting values and mapping aesthetics, and the important group aesthetic.  Sections~\ref{sec:geom} and \ref{sec:stat} list the geoms and stats available in \ggplot.  Section~\ref{sec:pull-together} concludes by introducing you to some plotting techniques that take advantage of what you have learned in this chapter.

This chapter is mainly a technical description of how layers, geoms and statistics work - how you call and customise them.  The next chapter, the \ggplot ``toolbox'', describes how you can use different geoms and stats to do data analysis. 
% In practice, I'd recommend flicking between these two chapters so you can learn both how layers work, and how you can use them to achieve your goals.
% dfs: This isn't a very appealing instruction, because it doesn't
% give you user a workable reading strategy.  I'll make a note here and 
% plan to revisit this later.
These two chapters are companions, with this one explaining how layers work and the next one how you can use layers to achieve your graphical goals.

\section{Creating a plot}
\label{sec:ggplot}

To build up a plot layer by layer, we start by creating a plot object. When discussing \f{qplot}, we didn't note that it creates a plot object, but it does. It creates a plot object, adds layers, and shows the result, applying a lot of default values along the way. To initialise a plot object without any shortcuts, simply call \f{ggplot} with no arguments; assign the result to a variable in order to add to it afterward.  ggplot accepts two optional arguments: {\bf data} and aesthetic {\bf mapping}.  The data argument needs little explanation: It's the data frame that you want to visualise.  You are already familiar with aesthetic mappings from \f{qplot}, and the syntax here is quite similar, although you need to wrap the pairs of aesthetic attribute and variable name in an \f{aes}:

% LISTING
% 
% p <- ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl))
\input{_include/6f261401f60cdaa47a1237db5d8ee741.tex}
% END

These arguments set up defaults for the plot and can be omitted if you specify data and aesthetics when adding each layer. 

This initial plot object can not be rendered until we add at least one layer.

\section{Layers}
\label{sec:layers}

A minimal layer may do nothing more than specify a {\bf geom}, a way of visually representing the data.  The plot object we just initialized can be rendered after this addition, specifying a scatterplot:

% LISTING
% 
% p <- p + layer(geom = ``point'')  
\input{_include/a43ca887828cec506e7bcfb85ab71230.tex}
% END
\input{_include/7fbdecf9d60a89c8e1d65cea679364e3.tex}
% p
% END
\noindent Note the use of \code{+} to add the layer to the plot.  This layer uses the plot defaults for data and aesthetic mapping and it uses default values for two optional arguments: the statistical transformation (the stat) and the position adjustment.  (Position adjustments are described in detail in Chapter~\ref{cha:position}; in brief, they shift objects on the plot to avoid overplotting.)  A more fully specified layer can take any or all of these arguments:

% LISTING
% 
% layer(geom, geom_params, stat, stat_params, data, mapping, position)
\input{_include/3412621051f43bb75c7babb74a86910b.tex}
% END

\noindent This more complicated layer calls for a histogram in ``steelblue'' and a bin width of 2:

% LISTING
% 
% p <- ggplot(mtcars, aes(x = mpg))
% p <- p + layer(
%   geom = ``histogram'', 
%   geom_params = list(fill = "steelblue"),
%   stat = ``bin'',
%   stat_params = list(binwidth = 2)
% )
% p
\input{_include/843c916b9c6116b3a6d1c4604a3682d0.tex}
% END

\noindent  This layer specification is precise but verbose. We can simplify it by using shortcuts that rely on the fact that every geom is associated with a default statistic and position, and every statistic with a default geom.  This means that you only need to specify one of \code{stat} or \code{geom} to get a completely specified layer, with parameters passed on to the geom or stat as appropriate.  This expression generates the same layer as the full layer command above:

% LISTING
% 
% geom_histogram(binwidth = 2, fill = "steelblue")
\input{_include/fcc02f4d63d997e85faf1a3d80093222.tex}
% END

\noindent All the shortcut functions have the same basic form, beginning with {\bf geom\_} or {\bf stat\_}:

% LISTING
% 
% geom_XXX(mapping, data, ..., geom, position)
% stat_XXX(mapping, data, ..., stat, position)
\input{_include/626a203880ff0c0f51cd9f78f70769c0.tex}
% END
\noindent Their common parameters define the components of the layer:

\begin{itemize}
	\item {\bf mapping} (optional): A set of aesthetic mappings, specified using the {\tt aes()} function and combined with the plot defaults as described in Section~\ref{sec:aes}.

	\item {\bf data} (optional): A data set which overrides the default plot data set.  It is most commonly omitted, in which case the layer will use the default plot data.
	
	\item {\bf ...}: Parameters for the geom or stat, such as bin width in the histogram or bandwidth for a loess smoother.  Any aesthetic that the geom recognises can also be specified as a parameter to the layer.  See Section~\ref{sub:setting-mapping}.
	
	\item {\bf geom} or {\bf stat} (optional):  You can override the default {\tt stat} for a {\tt geom}, or the default {\tt geom} for a {\tt stat}.  This is a text string containing the name of the geom to use.  Using the default will give you a standard plot; overriding the defaults allows you to achieve something more exotic, as described in Section~\ref{sub:new_plot_types}.
  
\end{itemize}

Simple layers can be used with \f{qplot}, without the option of changing the data or aesthetic mapping:

% LISTING
% 
% qplot(mtcars, aes(mpg, wt)) + geom_point()
% qplot(mtcars, aes(mpg, wt, colour = factor(cyl))) + geom_smooth()
\input{_include/c448e98670fe5482dcac3d8a1fda43e0.tex}
% END

You've seen that plot objects can be stored as variables. The summary function can be helpful for inspecting the structure of a plot without plotting it:

% INTERWEAVE
%
% p <- ggplot(data=mtcars, aes(mpg, wt))
% summary(p)
%
% p <- p + geom_point()
% summary(p)
\input{_include/2d835056505a754c93732e6e4bfd4b0a.tex}
% END

Layers can also be stored as variables, so that it is easy to write clean code that generates a family of related plots.  For example, a set of plots can be initialised using different data then enhanced identically with carefully constructed layers.

Note that the order of \code{data} and \code{mapping} arguments is switched between {\tt ggplot()} and the layer functions.  This should improve ease of use, because you almost always specify data for the plot, and almost always specify aesthetics ~--~ but {\em not} data ~--~ for the layers.  However, I suggest explicitly naming other arguments rather than relying on positional matching.  This makes the code more readable and it is the style followed in this book.

The following sections describe the data and aesthetic mappings in more detail, then go on to describe the available geoms and stats.

\section{Data}
\label{sec:data}

The restriction on the data is simple: It must be a data frame.  It is not necessary to specify a default dataset except when using facetting; facetting is a global operation (i.e., it works on all layers) and it needs to have some a dataset to add in any missing columns.  See Section~\ref{sub:missing_facetting_columns} for more details.  If the dataset is omitted, every layer must supply its own data.

It is important to remember that the data is stored in the plot object as a copy, not a reference.  This is important because ggplot2 objects are entirely self-contained.  You can save one to disk and later plot it without needing anything else from that session.

If you want to update (or change) the data later on, you can replace the default dataset with \code{\%+\%}:

% LISTING
% 
% p <- ggplot(mtcars, aes(mpg, wt, colour = cyl)) + geom_point()
% p
% mtcars <- transform(mtcars, mpg = mpg ^ 2)
% p %+% mtcars
\input{_include/c6437645230dbb93914a78989ca737c3.tex}
% END

\noindent Any change of values or dimensions is legitimate as long as the variables used in the plot are still part of the data, and the variables do not change from discrete to continuous or vice versa.  This facility can be useful if you need to produce the same plot for different datasets.  It's also an easy way to experiment with influential points or imputation schemes.

% HERE dfs

\section{Aesthetic mapping}
\label{sec:aes}

To describe the way that variables in the data are mapped to things that we can perceive on the plot (the ``aesthetics''), we use the {\tt aes} function.  The {\tt aes} function takes a list of aesthetic-variable pairs like these:

% LISTING
% 
% aes(x = weight, y = height, colour = age)
\input{_include/1ae4b195d10a936649daa716430eda8c.tex}
% END

Here we are mapping x-position to weight, y-position to height and colour to age.  The first two arguments can be left without names, in which case they are assumed to correspond to the x and y variables.  (This matches the way that \f{qplot} is normally used.)

% LISTING
% 
% aes(weight, height, colour = sqrt(age))
\input{_include/ed905dc95b606c445f3421dcd5086aa4.tex}
% END
\noindent Note that functions of variables can be used.

Any variable in an \f{aes} specification must be contained inside the plot or layer data.  This is one of the ways in which ggplot2 objects are guaranteed to be entirely self-contained, so that they can be stored and re-used.

\subsection{Plots and layers}
\label{sub:plots_and_layers}

When the aesthetic mappings are part of the plot defaults, they can be set when the plot is initialized or added later using \code{+}, as in this example:

% INTERWEAVE
% 
% p <- ggplot(mtcars)
% summary(p)
%
% p <- p + aes(wt, hp)
% summary(p)
\input{_include/f9c26f4d572d441ecf6d705d04ae39aa.tex}
% END

We have seen several examples of using the default mapping when adding a layer to a plot:

% INTERWEAVE
% 
% p <- ggplot(mtcars, aes(x = mpg, y = wt))
% p + geom_point()
\input{_include/a4eed8ae4fb1d75b6328594b1e39dfed.tex}
% END

As these two examples show, the default mappings in the plot $p$ just defined  can be extended or overridden in added layers:

% INTERWEAVE
% 
% p + geom_point(aes(colour = factor(cyl)))
% p + geom_point(aes(y = disp))
\input{_include/8b9c7e604635ca0aebaf81475770a316.tex}
% END

\noindent The rules are summarised in Table~\ref{tbl:aes-override}.  Note that you are overriding the aesthetics only in that layer.  Unless you specify otherwise, the axis and legend names, as well as mappings in subsequent layers, will use the default assignments. 

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Operation & Layer aesthetics  & Result \\
    \midrule
    Add       & colour = cyl & x = mpg, y = wt, colour = cyl \\
    Override  & y = disp     & x = mpg, y = disp \\
    Delete    & y = NULL     & x = mpg \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Rules for combining layer aesthetic mapping with default mapping of \code{aes(x = mpg, y= wt)}:  additional aesthetics can be added, overridden, and removed.}
  \label{tbl:aes-override}
\end{table}


\subsection{Setting vs. mapping}
\label{sub:setting-mapping}

For every aesthetic the geom function understands, you can also set that aesthetic as an parameter to the function.  Aesthetics can vary for each observation being plotted, while parameters can not.  For example, the following layer sets a parameter but not an aesthetic mapping:

% LISTING
% 
% p <- ggplot(mtcars, aes(x=mpg, y=wt))
% p + geom_point(colour="darkblue")  
\input{_include/06b091bc1f2bb3aa59c3fc420fca303d.tex}
% END

\noindent will set the point colour to be dark blue instead of black.  This is quite different to:

% LISTING
% 
% p + geom_point(aes(colour="darkblue"))
\input{_include/22dd5d3fae89c604c3186670482127f5.tex}
% END

\noindent This {\bf maps} (not sets) the colour to the value ``darkblue''.  This effectively creates a new variable containing only the value  ``darkblue'' and then maps colour to that new variable.  Because this value is discrete, the default colour scale uses evenly spaced colours on the colour wheel, and since there is only one value this colour is reddish.

When the string refers to a variable, it does what we've already described.  In this case, it doesn't correspond to a variable in the dataset but a constant, so the color scale uses its default highlighting color.  For the default color scale, that's the pinkish color you see in figure blah.

Chapter~\ref{cha:specifications} describes how values should be specified for the various aesthetics.  With qplot, you can do the same thing by putting the value inside of \f{I}, e.g.,\ \code{colour = I("darkblue")}.  The difference between setting and mapping is illustrated in Figure~\ref{fig:qplot-setting}.  

% FIGURE
%   LABEL: qplot-setting
%   CAPTION: The difference between \leftc setting colour to \code{"darkblue"}
%   and \rightc mapping colour to \code{"darkblue"}.  When \code{"darkblue"}
%   is mapped to colour, it is treated as a regular value and scaled with
%   the default colour scale.  This results in pinkish points and a legend.
% 
% qplot(mpg, wt, data=mtcars, colour = I("darkblue"))
% qplot(mpg, wt, data=mtcars, colour = "darkblue")
\input{_include/fb05728d30f2f62b13d9e333bd0258c0.tex}
% END

\subsection{Grouping}
\label{sub:grouping}

A number of geoms and stats work with multiple observations.  The line geom visually connects multiple observations, for example, in a medical experiment where measurements are taken on each subject at multiple times; and the boxplot geom summarises the distribution of a set of observations.  How do we control which observations go in which group?  This is the job of the {\tt group} aesthetic.

By default, the {\tt group} is set to the interaction of all discrete variables in the plot.  This often partitions the data correctly, but when it does not, or when no discrete variable is used in the plot, you will need to explicitly define the grouping structure.  There are three common cases where this occurs, and we will consider each one below.  In the following examples, we will use a simple longitudinal data set, \code{Oxboys}, from the \pkg{nlme} package.  It records the heights (\var{height}) and ages (\var{age}) of 26 boys (\var{Subject}), measured on nine occasions (\var{Occasion}). 

\paragraph{Multiple groups, one aesthetic.} In many situations, you want to separate your data into groups, but render them in the same way: when looking at the data in aggregate you want to be able to distinguish individual subjects, but not identify them.  This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots.  

The first plot in Figure~\ref{fig:group-lines} shows a set of time series plots, one for each boy. You can see the separate growth trajectories for each boy, but there is no way to see which boy belongs to which trajectory.  This plot was generated with:

% LISTING
%
% p <- ggplot(Oxboys, aes(age, height, group = Subject)) + 
%   geom_line()
% p
\input{_include/21e500936c8408724433c01b810fa611.tex}
% END

\noindent We specified the \var{Subject} as the grouping variable to get a line for each boy. The second plot in the figure shows the result of leaving this out: we get a single line which passes through all points.  This is not very useful! Plots with an incorrect grouping specification often look something like this.

% FIGURE
%   LABEL: group-lines
%   CAPTION: \Leftc correctly specifying {\tt group = Subject} produces
%   one line per subject.  \Rightc a single line connects all observations. 
%   This pattern is characteristic of an incorrect grouping aesthetic, and is
%   what we see if the group aesthetic is omitted.
% 
% data(Oxboys, package="nlme")
% qplot(age, height, data=Oxboys, group = Subject, geom="line")
% qplot(age, height, data=Oxboys, geom="line")
\input{_include/bef234767ad2d5f6aceb7b4e878a8f79.tex}
% END

\paragraph{Different groupings on different layers.}  Sometimes we want to plot summaries based on different levels of aggregation of the data. Different layers might have different grouping aesthetics, so that some display the full data while others display summaries of larger groups.

Building on the previous example, suppose we want to add a single smooth line to the plot just created, based on the ages and heights of {\em all} the boys.  If we use the same grouping for the smooth that we used for the line, we get the first plot in Figure~\ref{fig:group-smooths}.  

% LISTING
% 
% p + geom_smooth(aes(group = Subject), method="lm")
\input{_include/dd83b38c6f5d8c4e979f97d26d258e74.tex}
% END

This is not what we wanted; we have inadvertently added a smoothed line for each boy. This new layer needs a different group aesthetic, so that the new smoothed line will be based on all the data, as shown in the second plot in the figure:

% LISTING
% 
% p + geom_smooth(aes(group = 1), method="lm", size = 2)
\input{_include/741de8ed2e8ced007afd5bfca54780d5.tex}
% END

% FIGURE
%   LABEL: group-smooths
%   CAPTION: Adding smooths to the Oxboys data.  \Leftc using the 
%   same grouping as the lines results in a line of best fit for 
%   each boy.  \Rightc using {\tt aes(group = 1)} in the smooth layer
%   fits a single line of best fit across all boys.
% 
% qplot(age, height, data=Oxboys, group = Subject, geom="line") +
%   geom_smooth(method="lm")
% qplot(age, height, data=Oxboys, group = Subject, geom="line") +
%   geom_smooth(aes(group = 1), method="lm", size = 2)
\input{_include/580e339d53808c12d94eae87feb1f513.tex}
% END
 
Note that because the first plot was stored in the variable {\tt p}, we can experiment with the code to generate the second layer without having to re-enter any of the code for the first layer.  This is a useful technique.

\paragraph{Using the default group aesthetic.}  In this case, the plot has a discrete scale but you want to draw lines that connect {\em across} groups.  This is the strategy used in interaction plots, profile plots, and parallel coordinate plots, among others.  

We start with boxplots of height at each occasion of measurement, as shown in the first figure in Figure~\ref{fig:group-boxplots}, created with:

% LISTING
% 
% ggplot(Oxboys, aes(x=Occasion, y=height)) + geom_boxplot()
\input{_include/c6048499b550ccc8624a6f72003e78e4.tex}
% END

\noindent There is no need to specify the group aesthetic here; the default grouping works here because occasion is a discrete variable.  To overlay individual trajectories we again need to override the default grouping for that layer with {\tt aes(group = Subject)}, as shown in the second plot in the figure.  The {\tt interaction()} function is useful if a single pre-existing variable doesn't cleanly separate groups, but a combination does.

% LISTING
% 
% p <- ggplot(Oxboys, aes(x=Occasion, y=height)) +
%  geom_boxplot()
% p + geom_line(aes(group=Subject), colour="#3366FF")
\input{_include/06d86d0bfee0f3355fd083009702e98d.tex}
% END

We change the line colour in the second layer to make them distinct from the boxes.  This is an example of setting an aesthetic to a fixed value.  The colour is a rendering attribute, which has no corresponding variable in the data.

% FIGURE
%   LABEL: group-boxplots
%   CAPTION: \Leftc if boxplots are used to look at the distribution of
%   heights at each occasion (a discrete variable), the default grouping 
%   works correctly.  \Rightc if trajectories of individual boys are overlaid
%   with {\tt geom\_line()} then {\tt aes(group = Subject)} must be set 
%   for the new layer.
% 
% qplot(Occasion, height, data=Oxboys, geom="boxplot")
% qplot(Occasion, height, data=Oxboys, geom="boxplot") +
%  geom_line(aes(group = Subject), colour="#3366FF")
\input{_include/315233b21075adb70186ba258c0ec6b7.tex}
% END

\subsection{Matching aesthetics to graphic objects}
\label{sub:matching}

In ggplot2, geoms can be roughly divided into individual and collective geoms.  An individual geom has a distinctive graphical object for each row in the data frame.  For example, the point geom has a single point for each observation.  On the other hand, collective geoms represent multiple observations.  This maybe a result of a statistical summary, or may be fundamental to the display of the geom, as with polygons.  Lines and paths fall somewhere in between:  each overall line is composed of a set of straight segments, but each segment represents two points.  This is different to \code{geom_segment} where each segment represents a single row.  What happens when the aesthetic attributes of the observations are different?

% Need example of each: point, line, polygon

For individual geoms, this isn't a problem at the drawing level, but still may be a problem at the perceptual level - overplotting means that you can't distinguish between individual points and in some sense the point geom becomes a collective geom.

Lines and paths, operate on an off by one principle: there is one more observation than line segment.   The aesthetic for the first observation is used for the first segment, and the aesthetic for the last observation is not used, as shown in Figure~\ref{matching-lines}.  There is an additional limitation that line type must be constant over each individual line.

% FIGURE
%   LABEL: matching-lines
%   GG-HEIGHT: 3
%   CAPTION: For lines and paths, the aesthetics of the line segment are
%   determined by the aesthetic of the beginning observation.  \Leftc, 
%   if colour is categorical, there is no meaningful way to interpolate
%   between adjacent colours, \rightc, for continuous variables there is
%   but this is not done by default.
% 
% df <- data.frame(x = 1:3, y = 1:3, colour = c(1,3,5))
% qplot(x, y, data=df, colour=factor(colour), size = I(5)) + 
%   geom_line(aes(group = 1), size = 2)
% qplot(x, y, data=df, colour=colour, size = I(5)) + geom_line(size = 2)
\input{_include/a4f549b00beb10bfbea208c4348f1c9b.tex}
% END

You could imagine a more complicated system where segments smoothly blend from one aesthetic to another.  This would work for continuous variables like size or colour, but not for line type, and so is not used in \ggplot.  If this is the behaviour you want, you'll need to perform the linear interpolation yourself, as shown below.  

% INTERWEAVE
%   GG-HEIGHT: 3
% 
% xgrid <- with(df, seq(min(x), max(x), length = 50))
% interp <- data.frame(
%   x = xgrid,
%   y = approx(df$x, df$y, xout = xgrid)$y,
%   colour = approx(df$x, df$colour, xout = xgrid)$y  
% )
% qplot(x, y, data = df, colour = colour, size = I(5)) + 
%   geom_line(data = interp, size = 2)
\input{_include/b4a4dc8cd6a72eaf960c0c6b8da1e9ce.tex}
% END

For all other collective geoms, all aesthetic attributes must be the same, or the default value will be used.  This makes sense for fill as it is a property of the entire object - it doesn't make sense to think about having a different fill for each point on the border.

There is of course also an interaction with grouping.  This results in an intuitive display for bars and area plots because stacking the individual bars or areas results in the same shape as the original data.

% Need bar & area example, and line & polygon example

\section{Geoms}
\label{sec:geom}

Geoms, or geometric elements, perform the actual rendering of the plot. Geoms are also responsible for drawing legends, as explained in Section~\ref{sec:guides}.  Table~\ref{tbl:geoms} lists all of the geoms available in ggplot.  

\begin{table}
  \begin{center}
  \begin{tabular}{lp{3in}}
      \toprule
      Name & Description \\
      \midrule
      abline       & Line, specified by slope and intercept                                       \\
      area         & Area plots                                                                   \\
      bar          & Bars, rectangles with bases on y-axis                                        \\
      blank        & Blank, draws nothing                                                         \\
      boxplot      & Box and whiskers plot                                                        \\
      contour      & Display contours of a 3d surface in 2d                                       \\
      crossbar     & Hollow bar with middle indicated by horizontal line                          \\
      density      & Display a smooth density estimate                                            \\
      density\_2d & Contours from a 2d density estimate                                          \\
      errorbar     & Error bars                                                                   \\
      histogram    & Histogram                                                                    \\
      hline        & Line, horizontal                                                             \\
      interval     & Base for all interval (range) geoms                                          \\
      jitter       & Points, jittered to reduce overplotting                                      \\
      line         & Connect observations, in ordered by x value                                  \\
      linerange    & An interval represented by a vertical line                                   \\
      path         & Connect observations, in original order                                      \\
      point        & Points, as for a scatterplot                                                 \\
      pointrange   & An interval represented by a vertical line, with a point in the middle       \\
      polygon      & Polygon, a filled path                                                       \\
      quantile     & Add quantile lines from a quantile regression                                \\
      ribbon       & Ribbons, y range with continuous x values                                    \\
      rug          & Marginal rug plots                                                           \\
      segment      & Single line segments                                                         \\
      smooth       & Add a smoothed condition mean.                                               \\
      step         & Connect observations by stairs                                               \\
      text         & Textual annotations                                                          \\
      tile         & Tile plot as densely as possible, assuming that every tile is the same size. \\
      vline        & Line, vertical                                                               \\
  
      \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms in \ggplot}
  \label{tbl:geoms}
\end{table}


\section{Stat}
\label{sec:stat}

Statistical transformations, stats, summarise the data in some way.  All available stats are listed in Table~\ref{tbl:stats}. 

\begin{table}
  \begin{center}
  \begin{tabular}{lp{3in}}
    \toprule
    Name & Description \\
    \midrule
    bin          & Bin data                                                   \\
    boxplot      & Calculate components of box and whisker plot               \\
    contour      & Contours of 3d data                                        \\
    density      & Density estimation, 1D                                     \\
    density\_2d & Density estimation, 2D                                     \\
    function     & Superimpose a function                                     \\
    identity     & Don't transform data                                       \\
    qq           & Calculation for quantile-quantile plot                     \\
    quantile     & Continuous quantiles                                       \\
    smooth       & Add a smoother                                             \\
    spoke        & Convert angle and radius to xend and yend                  \\
    step         & Create stair steps                                         \\
    sum          & Sum unique values.  Useful for overplotting on scatterplots\\
    summary      & Summarise y values at every unique x                       \\
    unique       & Remove duplicates                                          \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Stats in \ggplot}
  \label{tbl:stats}
\end{table}

Each stat generates a number of output variables that can be used in aesthetic mappings.  For example, \code{stat_bin}, the statistic used to make histograms, produces the following variables:

\begin{itemize}
  \item \var{count}, the number of observations in each bin
  \item \var{density}, the density of observations in each bin (percentage of total / bar width)
  \item \var{x}, the centre of the bin
\end{itemize}

These generated variables can be used instead of the variables present in the original data set.  For example, the default histogram geom assigns the height of the bars to the number of observations (\var{count}), but if you'd prefer a more traditional histogram, you can use the density (\var{density}).   The following example shows a density histogram of \var{carat} from the diamonds dataset.

% INTERWEAVE
%   GG-WIDTH: 8
%   TEX-WIDTH: \textwidth
% 
% ggplot(diamonds, aes(x=carat)) + geom_histogram(aes(y=..density..), binwidth=.1)
\input{_include/ea29a89f62f55e59015d8f825294384b.tex}
% END

The names of generated variables must be surrounded with {\tt ..} when used.  This prevents confusion in case the original data set includes a variable with the same name as a generated variable, and it makes it clear to any later reader of the code that this variable was generated by a stat.

As a reminder, the same plot can be produced using qplot because it does not include any layer which changes the default aesthetic mappings:

% LISTING
% 
% qplot(carat, ..density.., data = diamonds, geom="histogram", binwidth = .1)
\input{_include/1fe86f50dbf704915a785d3221c8f262.tex}
% END

\section{Pulling it all together}
\label{sec:pull-together}

Once you have become comfortable with combining layers, you will be able to create graphics that are both intricate and useful.  The following examples demonstrate some of the ways to use the capabilities of layers that have been introduced in this chapter.  These are just to get you started ~--~ you are limited only by your imagination!

\subsection{Combining geoms and stats}
\label{sub:new_plot_types}

By connecting geoms with different statistics, you can easily create new graphics.  Figure~\ref{fig:hist-variations} shows three variations on a histogram.  They all use the same statistical transformation underlying a histogram (the bin stat), but use different geoms to display the results: the area geom, the point geom and the tile geom.  

% LISTING
% 
% d <- ggplot(diamonds, aes(x=carat)) + xlim(0, 3)
% d + stat_bin(aes(ymax = ..count..), binwidth = 0.1, geom = "area")
% d + stat_bin(
%   aes(size = ..density..), binwidth = 0.1, 
%   geom = "point", position="identity"
% )
% d + stat_bin(
%   aes(y = 1, fill = ..count..), binwidth = 0.1, 
%   geom = "tile", position="identity"
% )
\input{_include/3746b64fafa8be2fde05b172858ce9a7.tex}
% END

% dfs: I can't see any difference whether you use scale_area or not, or scale_y_continous or not,
% so I would like to leave them out, since they haven't yet been introduced.
% hw: I agree

(The use of xlim in ggplot will be discussed in \ref{cha:scales}, in the presentation of the use of scales and axes, but any R user can already guess that it is used here to fix the limits of the horizontal axis.)

% FIGURE
%   LABEL: hist-variations
%   TEX-WIDTH: 0.33\textwidth
%   CAPTION: Three variations on the histogram. \Leftc a frequency polygon;
%   \middlec a scatterplot with both size and height mapped to frequency; 
%   \rightc an heatmap representing frequency with colour.
% 
% d <- ggplot(diamonds, aes(carat)) + xlim(0, 3)
% d + stat_bin(aes(ymax = ..count..), binwidth = 0.1, geom = "area")
% d + stat_bin(aes(size = ..density..), binwidth = 0.1, geom = "point", position="identity")
% d + stat_bin(aes(y=1, fill = ..count..), binwidth = 0.1, geom = "tile", position="identity") + scale_y_continuous("")
\input{_include/0cc61a0af40b6bd2e31fdc453c3c5be6.tex}
% END

A number of the geoms available in ggplot were derived from other geoms in a process like the one just described, by starting with an existing geom and making a few changes in the default aesthetics or stat.  For example, the jitter geom is simply the point geom with the default position reset from NULL to jitter.  Once it becomes clear that a particular variant is going to be used a lot or used in a very different context, it makes sense to create a new geom. Table~\ref{tbl:aliased-geoms} lists these ``aliased'' geoms.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aliased geom & Base geom & Changes in default \\
    \midrule
    area      & ribbon & \verb!aes(min = 0, max = y), position = "stack"!  \\
    density   & area   & \verb!stat = "density"!    \\
    histogram & bar    & \verb!stat = "bin"!        \\
    jitter    & point  & \verb!position = "jitter"! \\
    quantile  & line   & \verb!stat = "quantile"!   \\
    smooth    & ribbon & \verb!stat = "smooth"!     \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms that were created by modifying the defaults of another geom.}
  \label{tbl:aliased-geoms}
\end{table}

\subsection{Varying aesthetics and data}
\label{sub:different_aesthetics}

One of the more powerful capabilities of \ggplot is the ability to plot different data sets on different layers.  This may seem strange: Why would you want to plot different data on the same plot?  In practice, you often have related data sets that should be shown together.  A very common example is supplementing the data with predictions from a model.  While the smooth geom can add a wide range of different smooths to your plot, it is no substitute for a external quantitative model that summarises your understanding of the data.

Let's look again at the \code{Oxboys} dataset which used in Section~\ref{sub:grouping}.  In Figure~\ref{fig:group-smooths}, we showed linear fits for individual boys (left) and for the whole group (right).  Neither model is particularly appropriate: The group model ignores the within--subject correlation and the individual model doesn't use information about the typical growth pattern to more accurately predict individuals.  In practice we might use a linear mixed effects model to do better.  This section explores how we can combine the output from this more sophisticated model with the original data to gain more insight into both the data and the model.

First we'll load the \pkg{nlme} package, and fit a model with varying intercepts and slopes.  (Exploring the fit of individual models shows that this is a reasonable first pass.)  We'll also create a plot to use as a template.  This regenerates the first plot in Figure~\ref{fig:qplot-setting}, but we're not going to render it in its default state.

% INTERWEAVE
% 
% require(nlme, quiet = TRUE, warn.conflicts = FALSE)
% model <- lme(height ~ age, data = Oxboys, random = ~ 1 + age | Subject)
% oplot <- ggplot(data=Oxboys, aes(x=age, y=height, group=Subject)) + 
%   geom_line()
\input{_include/c21103088db29b8b8057e41e26fbe634.tex}
% END

Next we'll compare the predicted trajectories to the actual trajectories.  We do this by building up a grid that contains all combinations of ages and subjects.  This is overkill for this simple linear case, where we only need two values of age to draw the predicted straight line, but we show it here because it is necessary when the model is more complex.  Next we add the predictions from the model back into this dataset, as a variable called \var{height}.  

% INTERWEAVE
% 
% age_grid <- seq(-1, 1, length = 10)
% subjects <- unique(Oxboys$Subject)
% 
% preds <- expand.grid(age = age_grid, Subject = subjects)
% preds$height <- predict(model, preds)
\input{_include/feb1c1e53237dbe1336dd9dfc1e03371.tex}
% END

Once we have the predictions we can display them along with the original data.  Because we have used the same variable names as the original \code{Oxboys} dataset, and we want the same group aesthetic, we don't need to specify any aesthetics; we only need to override the default dataset.  We also set two aesthetic parameters to make it a bit easier to compare the predictions to the actual values.

% INTERWEAVE
% 
% oplot + geom_line(data = preds, colour = "#3366FF", size= 0.4)
\input{_include/b6b2b24700818d7bad6023ecf56ad23b.tex}
% END

It seems that the model does a good job of capturing the high-level structure of the data, but it's hard to see the details ~--~ plots of longitudinal data are often called spaghetti plots, and with good reason.  Another way to compare the model to the data is to look at residuals, so let's do that.  We add the predictions from the model to the original data (\var{fitted}), calculate residuals (\var{resid}), and add the residuals as well.  The next plot is a little more complicated: We update the plot dataset (recall the use of \code{\%+\%} to update the default data), change the default y aesthetic to \var{resid}, and add a smooth line for all observations.

% INTERWEAVE
% 
% Oxboys$fitted <- predict(model)
% Oxboys$resid <- with(Oxboys, fitted - height)
% 
% oplot %+% Oxboys + aes(y = resid) + geom_smooth(aes(group=1))
\input{_include/b2185a0fdcf9af980bf5c70020f1ce50.tex}
% END

The smooth line makes it evident that the residuals are not random, showing a deficiency in the model.  We add a quadratic term, refit the model, recalculate predictions and residuals, and replot.  There now much less evidence of model inadequacy.

% INTERWEAVE
% 
% model2 <- update(model, height ~ age + I(age ^ 2))
% Oxboys$fitted2 <- predict(model2)
% Oxboys$resid2 <- with(Oxboys, fitted2 - height)
% 
% oplot %+% Oxboys + aes(y = resid2) + geom_smooth(aes(group=1))
\input{_include/5c71ccbb984268459afbd5458f7b0dba.tex}
% END

Notice how easily we were able to modify the plot object.  We updated the data and replotted twice without needing to reinitialize oplot.  Layering in ggplot is designed to work well with the iterative nature of fitting and evaluating models.

\input{_footer.tex}
