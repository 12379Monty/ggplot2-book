\input{_header.tex}

% SET_DEFAULTS
%   GG-WIDTH: 4  GG-HEIGHT: 4
%   TEX-WIDTH: 0.5\linewidth
%   CACHE: TRUE
%   INLINE: FALSE
% 

% END

\chapter{Build a plot layer by layer}
\label{cha:layers}

\section{Introduction}

Layering is the mechanism by which additional data elements are added to a plot.  Each layer can come from a different dataset and have a different aesthetic mapping, allowing us to create plots that could not be generated using \f{qplot}, which permits only a single dataset and a single set of aesthetic mappings.

This chapter is mainly a technical description of how layers, geoms, statistics and position adjustments work: how you call and customise them.  The next chapter, the ``toolbox'', describes how you can use different geoms and stats to solve particular visualisation problems.  These two chapters are companions, with this chapter explaining the theory and the next chapter explaining the practical aspects of using layers to achieve your graphical goals.

Section~\ref{sec:ggplot} will teach you how to initialise a plot object by hand, a task that \f{qplot} performs for us.  The plot is not ready to be displayed until at least one layer is added, as described in Section~\ref{sec:layers}.  This section first describes the complete layer specification, which helps you see exactly how the components of the grammar are realised in R code, and then shows you the shortcuts that will save you a lot of time.  As you have learned in the previous chapter, there are five components of a layer:

\begin{itemize}
  \item The data, \secref{sec:data}, which must be an R data frame, and can be changed after the plot is created.

  \item A set of aesthetic mappings, \secref{sec:aes}, which describe how variables in the data are mapped to aesthetic properties of the layer.  This section includes a description of how layer settings override the plot defaults, the difference between setting and mapping, and the important group aesthetic.

  \item The geom, \secref{sec:geom}, which describes the geometric used to draw the layer.  The geom defines the set of available aesthetic properties.

  \item The stat, \secref{sec:stat}, which takes the raw data and transforms it in some useful way.  The stat returns a data frame with new variables that can also be mapped to aesthetics with a special syntax.

  \item The position adjustment, \secref{sec:position}, which adjusts elements to avoid overplotting.
\end{itemize}

To conclude, Section~\ref{sec:pull-together} shows you some plotting techniques that pull together everything you have learned in this chapter to create novel visualisations and to visualise model information along with your data.

\section{Creating a plot}
\label{sec:ggplot}

When we used \f{qplot}, it did a lot of things for us: it created a plot object, added layers, and displayed the result, using many default values along the way. To create the plot object ourselves, we use \f{ggplot}.  This has two arguments: {\bf data} and aesthetic {\bf mapping}. These arguments set up defaults for the plot and can be omitted if you specify data and aesthetics when adding each layer.  The data argument needs little explanation: It's the data frame that you want to visualise.  You are already familiar with aesthetic mappings from \f{qplot}, and the syntax here is quite similar, although you need to wrap the pairs of aesthetic attribute and variable name in the \f{aes} function.  \f{aes} is described more fully in Section~\ref{sec:aes}, but it's not very tricky. The following example specifies a default mapping of x to \var{carat}, y to \var{price} and colour to \var{cut}. \indexf{ggplot}

% LISTING
% 
% p <- ggplot(diamonds, aes(carat, price, colour = cut))
\input{_include/a429149af3930bb8ef257444a58f18a1.tex}
% END

This plot object cannot be displayed until we add a layer: there is nothing to see!

\section{Layers}
\label{sec:layers}

A minimal layer may do nothing more than specify a {\bf geom}, a way of visually representing the data.  If we add a point geom to the plot we just created, we create a scatterplot, which can then be rendered. \indexf{layer}

% LISTING
% 
% p <- p + layer(geom = "point")  
\input{_include/eeb47cf65f9f19c16033c4f019ea924d.tex}
% END

\noindent Note how we use \code{+} to \textbf{add} the layer to the plot. \index{Layers!adding} \indexc{+} This layer uses the plot defaults for data and aesthetic mapping and it uses default values for two optional arguments: the statistical transformation (the stat) and the position adjustment.  A more fully specified layer can take any or all of these arguments:

% LISTING
% 
% layer(geom, geom_params, stat, stat_params, data, mapping, 
%   position)
\input{_include/9c143921cfd6cac6a346451be0e6291c.tex}
% END

\noindent Here is what a more complicated call looks like.  It produces a histogram (a combination of bars and binning) coloured ``steelblue'' with a bin width of 2:

% LISTING
% 
% p <- ggplot(diamonds, aes(x = carat))
% p <- p + layer(
%   geom = "bar", 
%   geom_params = list(fill = "steelblue"),
%   stat = "bin",
%   stat_params = list(binwidth = 2)
% )
% p
\input{_include/0cc7c84c84654f901ef07ea78553b43f.tex}
% END

\noindent  This layer specification is precise but verbose. We can simplify it by using shortcuts that rely on the fact that every geom is associated with a default statistic and position, and every statistic with a default geom.  This means that you only need to specify one of \code{stat} or \code{geom} to get a completely specified layer, with parameters passed on to the geom or stat as appropriate.  This expression generates the same layer as the full layer command above:

% LISTING
% 
% geom_histogram(binwidth = 2, fill = "steelblue")
\input{_include/e62d2440d41d5ff8e964413165bb9f54.tex}
% END

\noindent All the shortcut functions have the same basic form, beginning with \code{geom_} or \code{stat_}:

% LISTING
% 
% geom_XXX(mapping, data, ..., geom, position)
% stat_XXX(mapping, data, ..., stat, position)
\input{_include/afc35611a552f15b6ca610ad5119a3bb.tex}
% END
\noindent Their common parameters define the components of the layer:

\begin{itemize}
  \item {\bf mapping} (optional): A set of aesthetic mappings, specified using the {\tt aes()} function and combined with the plot defaults as described in Section~\ref{sec:aes}.

  \item {\bf data} (optional): A dataset which overrides the default plot dataset.  It is most commonly omitted, in which case the layer will use the default plot data. See Section~\ref{sec:data}.
  
  \item {\bf ...}: Parameters for the geom or stat, such as bin width in the histogram or bandwidth for a loess smoother.  You can also use aesthetic properties as parameters.  When you do this you \textbf{set} the property to a fixed value,  not \textbf{map} it to a variable in the dataset.  The example above showed setting the fill colour of the histogram to ``steelblue''. See Section~\ref{sub:setting-mapping} for more examples.
  
  \item {\bf geom} or {\bf stat} (optional):  You can override the default {\tt stat} for a {\tt geom}, or the default {\tt geom} for a {\tt stat}.  This is a text string containing the name of the geom to use.  Using the default will give you a standard plot; overriding the default allows you to achieve something more exotic, as shown in Section~\ref{sub:new_plot_types}.

  \item {\bf position} (optional): Choose a method for adjusting overlapping objects, as described in Section~\ref{sec:position}.
  
\end{itemize}

Note that the order of \code{data} and \code{mapping} arguments is switched between {\tt ggplot()} and the layer functions.  This is because you almost always specify data for the plot, and almost always specify aesthetics---but {\em not} data---for the layers.  We suggest explicitly naming all other arguments rather than relying on positional matching.  This makes the code more readable and is the style followed in this book.

Layers can be added to plots created with \f{ggplot} or \f{qplot}.  Remember, behind the scenes, \f{qplot} is doing exactly the same thing: it creates a plot object and then adds layers.  The following example shows the equivalence between these two ways of making plots.

% LISTING
% 
% ggplot(msleep, aes(sleep_rem / sleep_total, awake)) + 
%   geom_point()
% # which is equivalent to
% qplot(sleep_rem / sleep_total, awake, data = msleep)
% 
% # You can add layers to qplot too:
% qplot(sleep_rem / sleep_total, awake, data = msleep) + 
%   geom_smooth()
% # This is equivalent to 
% qplot(sleep_rem / sleep_total, awake, data = msleep, 
%   geom = c("point", "smooth"))
% # or
% ggplot(msleep, aes(sleep_rem / sleep_total, awake)) + 
%   geom_point() + geom_smooth()
\input{_include/9260eec336f41f0ed07e835011e3144b.tex}
% END

You've seen that plot objects can be stored as variables. The summary function can be helpful for inspecting the structure of a plot without plotting it, as seen in the following example. \index{Summary!of plot object} The summary shows information about the plot defaults, and then each layer. You will learn about scales and faceting in Chapters~\ref{cha:scales} and \ref{cha:position}.

% INTERWEAVE
%
% p <- ggplot(msleep, aes(sleep_rem / sleep_total, awake))
% summary(p)
%
% p <- p + geom_point()
% summary(p)
\input{_include/5e5fb70302edf1b32e17dc2558f8a37f.tex}
% END

Layers are regular R objects and so can be stored as variables, making it easy to write clean code that reduces duplication. \index{Layers!saving as variables} For example, a set of plots can be initialised using different data then enhanced with the same layer.  If you later decide to change that layer, you only need to do so in one place.  The following shows a simple example, where we create a layer that displays a translucent thick blue line of best fit.

% LISTING
% 
% bestfit <- geom_smooth(method = "lm", se = F, 
%   colour = alpha("steelblue", 0.5), size = 2)
% qplot(sleep_rem, sleep_total, data = msleep) + bestfit
% qplot(awake, brainwt, data = msleep, log = "y") + bestfit
% qplot(bodywt, brainwt, data = msleep, log = "xy") + bestfit
\input{_include/2712caee5d2709e89cc549bb9e8ee891.tex}
% END

The following sections describe data and mappings in more detail, then go on to describe the available geoms, stats and position adjustments.

\section{Data}
\label{sec:data}

The restriction on the data is simple: it must be a data frame. \index{Data} \indexc{data.frame} This is restrictive, and unlike other graphics packages in R.  Lattice functions can take an optional data frame or use vectors directly from the global environment.  Base methods often work with vectors, data frames or other R objects.  However, there are good reasons for this restriction. Your data is very important, and it's better to be explicit about exactly what is done with it.  It also allows a cleaner separation of concerns so that \ggplot deals only with plotting data, not wrangling it into different forms, for which you might find the \code{plyr} or \code{reshape} packages helpful.  A single data frame is also easier to save than a multitude of vectors, which means it's easier to reproduce your results or send your data to someone else.  

% \f{qplot} does work with vectors in your workspace, but it has to use some heuristics and it doesn't always get it right.  This means that is usually best to explicitly arrange your data in the format that \ggplot uses.  

This restriction also makes it very easy to produce the same plot for different data: you just change the data frame.  You can replace the old dataset with \code{\%+\%}, as shown in the following example. \index{Data!replacing} (You might expect that this would use \code{+} like all the other components, but unfortunately due to a restriction in R this is not possible.) \indexc{\%+\%} Swapping out the data makes it easy to experiment with imputation schemes or model fits, as shown in Section~\ref{sub:different_aesthetics}. 

% LISTING
% 
% p <- ggplot(mtcars, aes(mpg, wt, colour = cyl)) + geom_point()
% p
% mtcars <- transform(mtcars, mpg = mpg ^ 2)
% p %+% mtcars
\input{_include/b7bdb0833bd291f4270bba3b1875bb90.tex}
% END

\noindent Any change of values or dimensions is legitimate.  However, if a variable changes from discrete to continuous (or vice versa), you will need to change the default scales, as described in Section~\ref{sec:scale-usage}.  

It is not necessary to specify a default dataset except when using faceting; faceting is a global operation (i.e., it works on all layers) and it needs to have a base dataset which defines the set of facets for all datasets.  See Section~\ref{sub:missing_faceting_columns} for more details.  If the default dataset is omitted, every layer must supply its own data.

The data is stored in the plot object as a copy, not a reference.  This has two important consequences: if your data changes, the plot will not; and \ggplot objects are entirely self-contained so that they can be \f{save}d to disk and later \f{load}ed and plotted without needing anything else from that session.

\section{Aesthetic mappings}
\label{sec:aes}

To describe the way that variables in the data are mapped to things that we can perceive on the plot (the ``aesthetics''), we use the {\tt aes} function.  The {\tt aes} function takes a list of aesthetic-variable pairs like these: \index{Mappings} \index{Aesthetics!mappings|see{Mappings}} \indexf{aes}

% LISTING
% 
% aes(x = weight, y = height, colour = age)
\input{_include/1ae4b195d10a936649daa716430eda8c.tex}
% END

Here we are mapping x-position to weight, y-position to height and colour to age.  The first two arguments can be left without names, in which case they correspond to the x and y variables.  This matches the way that \f{qplot} is normally used.  You should never refer to variables outside of the dataset (e.g., with \verb|diamonds$carat|), as this makes it impossible to encapsulate all of the data needed for plotting in a single object.

% LISTING
% 
% aes(weight, height, colour = sqrt(age))
\input{_include/ed905dc95b606c445f3421dcd5086aa4.tex}
% END
\noindent Note that functions of variables can be used.

Any variable in an \f{aes} specification must be contained inside the plot or layer data.  This is one of the ways in which \ggplot objects are guaranteed to be entirely self-contained, so that they can be stored and re-used.

\subsection{Plots and layers}
\label{sub:plots_and_layers}

The default aesthetic mappings can be set when the plot is initialised or modified later using \code{+}, as in this example: \index{Mappings!defaults} \indexc{+}

% INTERWEAVE
% 
% p <- ggplot(mtcars)
% summary(p)
%
% p <- p + aes(wt, hp)
% summary(p)
\input{_include/fe332f45a17f1bb385252c4ff2ba43ce.tex}
% END

One reason you might want to do this is shown in Section~\ref{sub:different_aesthetics}.  We have seen several examples of using the default mapping when adding a layer to a plot:

% INTERWEAVE
% 
% p <- ggplot(mtcars, aes(x = mpg, y = wt))
% p + geom_point()
\input{_include/c23a69789d849d9712a35836c7d12271.tex}
% END

The default mappings in the plot \code{p} can be extended or overridden in the layers, as with the following code. \index{Mappings!overriding} The results are shown in Figure~\ref{fig:aes-override}.

% FIGLISTING
%   LABEL: aes-override
%   CAPTION: Overriding aesthetics.  (Left) Overriding colour with 
%   {\tt factor(cyl)} and (right) overriding y-position with {\tt disp}
% 
% p + geom_point(aes(colour = factor(cyl)))
% p + geom_point(aes(y = disp))
\input{_include/a1ea50b4992b86bf63e7a371acaaf881.tex}
% END

\noindent The rules are summarised in Table~\ref{tbl:aes-override}.  Aesthetic mappings specified in a layer affect only that layer.  For that reason,  unless you modify the default scales, axis labels and legend titles will be based on the plot defaults.  The way to change these is described in Section~\ref{sec:guides}.

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Operation & Layer aesthetics  & Result \\
    \midrule
    Add       & \code{aes(colour = cyl)} & 
      \code{aes(mpg, wt, colour = cyl)} \\
    Override  & \code{aes(y = disp)}     & 
      \code{aes(mpg, disp)} \\
    Remove    & \code{aes(y = NULL)}     & 
      \code{aes(mpg)} \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Rules for combining layer mappings with the default mapping of \code{aes(mpg, wt)}.  Layer aesthetics can add to, override, and remove the default mappings.}
  \label{tbl:aes-override}
\end{table}


\subsection{Setting vs. mapping}
\label{sub:setting-mapping}

Instead of mapping an aesthetic property to a variable, you can set it to a single value by specifying it in the layer parameters.  Aesthetics can vary for each observation being plotted, while parameters do not.  We \textbf{map} an aesthetic to a variable (e.g., \code(aes(colour = cut))) or \textbf{set}  it to a constant (e.g., \code{colour = "red"}).  For example, the following layer sets the colour of the points, using the colour parameter of the layer: \index{Aesthetics!setting|textbf}

% LISTING
% 
% p <- ggplot(mtcars, aes(mpg, wt))
% p + geom_point(colour = "darkblue")  
\input{_include/08e3328734aca7b0585cd9b677eaf4d5.tex}
% END

\noindent This sets the point colour to be dark blue instead of black.  This is quite different than

% LISTING
% 
% p + geom_point(aes(colour = "darkblue"))
\input{_include/cad15d2883365e53f42238fd58fe7d2c.tex}
% END

\noindent This {\bf maps} (not sets) the colour to the value ``darkblue''.  This effectively creates a new variable containing only the value  ``darkblue'' and then maps colour to that new variable.  Because this value is discrete, the default colour scale uses evenly spaced colours on the colour wheel, and since there is only one value this colour is pinkish.  The difference between setting and mapping is illustrated in Figure~\ref{fig:qplot-setting}.  

With \f{qplot}, you can do the same thing by putting the value inside of \f{I}, e.g.,\ \code{colour = I("darkblue")}.  Chapter~\ref{cha:specifications} describes how values should be specified for the various aesthetics. \indexf{I}

% FIGURE
%   LABEL: qplot-setting
%   CAPTION: The difference between (left) setting colour to
%   \code{"darkblue"} and (right) mapping colour to \code{"darkblue"}.  
%   When \code{"darkblue"} is mapped to colour, it is treated as a regular
%   value and scaled with the default colour scale.  This results in pinkish
%   points and a legend.
% 
% qplot(mpg, wt, data=mtcars, colour = I("darkblue"))
% qplot(mpg, wt, data=mtcars, colour = "darkblue")
\input{_include/34d37e27311c0abe1a63fce084152910.tex}
% END

\subsection{Grouping}
\label{sub:grouping}

In \ggplot, geoms can be roughly divided into individual and collective geoms.  An individual geom has a distinctive graphical object for each row in the data frame.  For example, the point geom has a single point for each observation.  On the other hand, collective geoms represent multiple observations.  This may be a result of a statistical summary, or may be fundamental to the display of the geom, as with polygons.  Lines and paths fall somewhere in between:  each overall line is composed of a set of straight segments, but each segment represents two points.  How do we control which observations go in which individual graphical element?  This is the job of the {\tt group} aesthetic.  \index{Grouping}

By default, the {\tt group} is set to the interaction of all discrete variables in the plot.  This often partitions the data correctly, but when it does not, or when no discrete variable is used in the plot, you will need to explicitly define the grouping structure, by mapping group to a variable that has a different value for each group.  The {\tt interaction()} function is useful if a single pre-existing variable doesn't cleanly separate groups, but a combination does.  

There are three common cases where the default is not enough, and we will consider each one below.  In the following examples, we will use a simple longitudinal dataset, \code{Oxboys}, from the \pkg{nlme} package.  It records the heights (\var{height}) and centered ages (\var{age}) of 26 boys (\var{Subject}), measured on nine occasions (\var{Occasion}). \index{Package!nlme}

\paragraph{Multiple groups, one aesthetic.} In many situations, you want to separate your data into groups, but render them in the same way.  When looking at the data in aggregate you want to be able to distinguish individual subjects, but not identify them.  This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots.  \index{Data!longitudinal}  

The first plot in Figure~\ref{fig:group-lines} shows a set of time series plots, one for each boy. You can see the separate growth trajectories for each boy, but there is no way to see which boy belongs to which trajectory.  This plot was generated with: \index{Time series}

% LISTING
%
% p <- ggplot(Oxboys, aes(age, height, group = Subject)) + 
%   geom_line()
\input{_include/c956404ce2a4b2d59db28fdf165e88e0.tex}
% END

\noindent We specified the \var{Subject} as the grouping variable to get a line for each boy. The second plot in the figure shows the result of leaving this out: we get a single line which passes through every point.  This is not very useful! Line plots with an incorrect grouping specification typically have this characteristic appearance. \indexf{geom_line}

% FIGURE
%   LABEL: group-lines
%   CAPTION: (Left) Correctly specifying {\tt group = Subject} produces
%   one line per subject.  (Right) A single line connects all observations. 
%   This pattern is characteristic of an incorrect grouping aesthetic, and is
%   what we see if the group aesthetic is omitted, which in this case is 
%   equivalent to {\tt group = 1}.
% 
% data(Oxboys, package="nlme")
% qplot(age, height, data=Oxboys, group = Subject, geom="line")
% qplot(age, height, data=Oxboys, geom="line")
\input{_include/8721e7fde54545d917bcaf39d25da0aa.tex}
% END

\paragraph{Different groups on different layers.}  Sometimes we want to plot summaries based on different levels of aggregation. Different layers might have different group aesthetics, so that some display individual level data while others display summaries of larger groups.

Building on the previous example, suppose we want to add a single smooth line to the plot just created, based on the ages and heights of {\em all} the boys.  If we use the same grouping for the smooth that we used for the line, we get the first plot in Figure~\ref{fig:group-smooths}.   \indexf{geom_smooth}

% LISTING
% 
% p + geom_smooth(aes(group = Subject), method="lm", se = F)
\input{_include/7019aa9175199d30eadd9e5d85a49d72.tex}
% END

This is not what we wanted; we have inadvertently added a smoothed line for each boy. This new layer needs a different group aesthetic, \code{group = 1}, so that the new line will be based on all the data, as shown in the second plot in the figure.  The modified layer looks like this:

% LISTING
% 
% p + geom_smooth(aes(group = 1), method="lm", size = 2, se = F)
\input{_include/03b0930266514b41450c2111348ee77a.tex}
% END

% FIGURE
%   LABEL: group-smooths
%   CAPTION: Adding smooths to the Oxboys data.  (Left) Using the 
%   same grouping as the lines results in a line of best fit for 
%   each boy.  (Right) Using {\tt aes(group = 1)} in the smooth layer
%   fits a single line of best fit across all boys.
% 
% qplot(age, height, data=Oxboys, group = Subject, geom="line") +
%   geom_smooth(method="lm", se = F)
% qplot(age, height, data=Oxboys, group = Subject, geom="line") +
%   geom_smooth(aes(group = 1), method="lm", size = 2, se = F)
\input{_include/51232d73ac23c7258abfa4ea1b8609cd.tex}
% END
 
Note how we stored the first plot in the variable {\tt p}, so we could experiment with the code to generate the second layer without having to re-enter any of the code for the first layer.  This is a useful time-saving technique, and is expanded upon in Chapter~\ref{cha:duplication}.

\paragraph{Overriding the default grouping.}  The plot has a discrete scale but you want to draw lines that connect {\em across} groups.  This is the strategy used in interaction plots, profile plots, and parallel coordinate plots, among others.  For example, we draw boxplots of height at each measurement occasion, as shown in the first figure in Figure~\ref{fig:group-boxplots}: \indexf{geom_boxplot}

% LISTING
% 
% boysbox <- ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot()
\input{_include/40561701a5b8a0acc2a8d86bb0edc991.tex}
% END

\noindent There is no need to specify the group aesthetic here; the default grouping works because occasion is a discrete variable.  To overlay individual trajectories we again need to override the default grouping for that layer with {\tt aes(group = Subject)}, as shown in the second plot in the figure.

% LISTING
% 
% boysbox + geom_line(aes(group = Subject), colour = "#3366FF")
\input{_include/0bd0e980e6f8d934170cdacba4091967.tex}
% END

We change the line colour in the second layer to make them distinct from the boxes.  This is another example of setting an aesthetic to a fixed value.  The colour is a rendering attribute, which has no corresponding variable in the data. \index{Aesthetics!setting}

% FIGURE
%   LABEL: group-boxplots
%   CAPTION: (Left) If boxplots are used to look at the distribution of
%   heights at each occasion (a discrete variable), the default grouping 
%   works correctly.  (Right) If trajectories of individual boys are overlaid
%   with {\tt geom\_line()}, then {\tt aes(group = Subject)} is needed for
%   the new layer.
% 
% qplot(Occasion, height, data=Oxboys, geom="boxplot")
% qplot(Occasion, height, data=Oxboys, geom="boxplot") +
%  geom_line(aes(group = Subject), colour="#3366FF")
\input{_include/92507b05107d5e48c737ce25fc09103e.tex}
% END

% The reason is simple, but fairly subtle - it's because of the default
% grouping behaviour.  By default ggplot splits up the data according to
% the combination of levels of all the categorical variables on the plot
% - so in your case you get a dataset for each bar, and so the density
% is just n / n = 1.  The way to get around this is to override the
% default grouping so that there is a single group for the whole
% dataset:

% % INTERWEAVE
% % 
% % qplot(cut, data = diamonds, geom = "bar")
% % qplot(cut, ..density.., data = diamonds, geom = "bar")
% % qplot(cut, ..density.., data = diamonds, geom = "bar", 
% %   group = 1)
% \input{_include/d48e2cbda69bd28b2c2634a203740a8c.tex}
% % END

\subsection{Matching aesthetics to graphic objects}
\label{sub:matching}

Another important issue with collective geom is how the aesthetics of the individual observations are mapped to the aesthetics of the complete entity.  For individual geoms, this isn't a problem, because each observation is represented by a single graphical element.  However, high data densities can make it difficult (or impossible) to distinguish between individual points and in some sense the point geom becomes a collective geom, a single blob of points. \index{Aesthetics!matching to geoms}

Lines and paths operate on an off-by-one principle: there is one more observation than line segment, and so the aesthetic for the first observation is used for the first segment, the second observation for the second segment and so on.  This means that the aesthetic for the last observation is not used, as shown in Figure~\ref{fig:matching-lines}.  An additional limitation for paths and lines is that that line type must be constant over each individual line, in R there is no way to draw a joined up line which has varying line type. \indexf{geom_line} \indexf{geom_path}

% FIGURE
%   LABEL: matching-lines
%   GG-HEIGHT: 3
%   CAPTION: For lines and paths, the aesthetics of the line segment are
%   determined by the aesthetic of the beginning observation.  
%   If colour is categorical (left) there is no meaningful way to interpolate
%   between adjacent colours.   If colour is continuous (right), there is,
%   but this is not done by default.
% 
% df <- data.frame(x = 1:3, y = 1:3, colour = c(1,3,5))
% qplot(x, y, data=df, colour=factor(colour), size = I(5)) + 
%   geom_line(aes(group = 1), size = 2)
% qplot(x, y, data=df, colour=colour, size = I(5)) + geom_line(size = 2)
\input{_include/800df80ca62fcadf7fe5005d2a443488.tex}
% END

You could imagine a more complicated system where segments smoothly blend from one aesthetic to another.  This would work for continuous variables like size or colour, but not for line type, and is not used in \ggplot.  If this is the behaviour you want, you can perform the linear interpolation yourself, as shown below.  

% INTERWEAVE
%   GG-HEIGHT: 3
% 
% xgrid <- with(df, seq(min(x), max(x), length = 50))
% interp <- data.frame(
%   x = xgrid,
%   y = approx(df$x, df$y, xout = xgrid)$y,
%   colour = approx(df$x, df$colour, xout = xgrid)$y  
% )
% qplot(x, y, data = df, colour = colour, size = I(5)) + 
%   geom_line(data = interp, size = 2)
\input{_include/42503f70fe9ff363f843c1c678d38628.tex}
% END

For all other collective geoms, like polygons, the aesthetics from the individual components are only used if they are all the same, otherwise the default value is used.  This makes sense for fill as it is a property of the entire object: it doesn't make sense to think about having a different fill colour for each point on the border of the polygon. \indexf{geom_polygon}

These issues are most relevant when mapping aesthetics to continuous variable, because, as described above, when you introduce a mapping to a discrete variable, it will by default split apart collective geoms into smaller pieces.  This works particularly well for bar and area plots, because stacking the individual pieces produces the same shape as the original ungrouped data.  This is illustrated in Figure~\ref{fig:bar-split}.

% FIGURE
%   LABEL: bar-split
%   CAPTION: Splitting apart a bar chart (left) produces a plot (right)
%   that has the same outline as the original.
% 
% qplot(color, data = diamonds)
% qplot(color, data = diamonds, fill = cut)
\input{_include/9f89761c933c500cbae11af243e675b7.tex}
% END

\section{Geoms}
\label{sec:geom}

Geometric objects, or {\bf geom}s for short, perform the actual rendering of the layer, control the type of plot that you create.  For example, using a point geom will create a scatterplot, while using a line geom will create a line plot.  Table~\ref{tbl:geoms} lists all of the geoms available in \ggplot. 

Each geom has a set of aesthetics that it understands, and a set that are required for drawing.  For example, a point requires x and y position, and understands colour, size and shape aesthetics.  A bar requires height ({\tt ymax}), and understands width, border colour and fill colour.  These are listed for all geoms in Table~\ref{tbl:geom-aesthetics}. \indexf{geom_bar}

Some geoms differ primarily in the way that they are parameterised.  For example, the tile geom is specified in terms of the location of its centre and its height and width, while the rect geom is parameterised in terms of its top (\code{ymax}), bottom (\code{ymin}), left (\code{xmin}) and right (\code{right}) positions. \indexf{geom_rect}  Internally, the rect geom is described as a polygon, and it is parameters are the locations of the four corners.  This is useful for non-Cartesian coordinate systems, as you will learn in Chapter~\ref{cha:position}. \index{Geoms!parameterisation}

Every geom has a default statistic, and every statistic a default geom.  For example, the bin statistic defaults to using the bar geom to produce a histogram.  These defaults are listed in Table~\ref{tbl:geom-aesthetics}.  Overriding these defaults will still produce valid plots, but they may violate graphical conventions.  See examples in Section~\ref{sub:new_plot_types}. \index{Geoms!defaults}

\begin{table}
  \begin{center}
 \begin{tabular}{lp{3in}}
  \toprule
  Name & Description \\
  \midrule
  abline       & Line, specified by slope and intercept                                       \\
  area         & Area plots                                                                   \\
  bar          & Bars, rectangles with bases on y-axis                                        \\
  blank        & Blank, draws nothing                                                         \\
  boxplot      & Box-and-whisker plot                                                        \\
  contour      & Display contours of a 3d surface in 2d                                       \\
  crossbar     & Hollow bar with middle indicated by horizontal line                          \\
  density      & Display a smooth density estimate                                            \\
  density\_2d & Contours from a 2d density estimate                                          \\
  errorbar     & Error bars                                                                   \\
  histogram    & Histogram                                                                    \\
  hline        & Line, horizontal                                                             \\
  interval     & Base for all interval (range) geoms                                          \\
  jitter       & Points, jittered to reduce overplotting                                      \\
  line         & Connect observations, in order of x value                                  \\
  linerange    & An interval represented by a vertical line                                   \\
  path         & Connect observations, in original order                                      \\
  point        & Points, as for a scatterplot                                                 \\
  pointrange   & An interval represented by a vertical line, with a point in the middle       \\
  polygon      & Polygon, a filled path                                                       \\
  quantile     & Add quantile lines from a quantile regression                                \\
  ribbon       & Ribbons, y range with continuous x values                                    \\
  rug          & Marginal rug plots                                                           \\
  segment      & Single line segments                                                         \\
  smooth       & Add a smoothed condition mean                                               \\
  step         & Connect observations by stairs                                               \\
  text         & Textual annotations                                                          \\
  tile         & Tile plot as densely as possible, assuming that every tile is the same size \\
  vline        & Line, vertical                                                               \\

  \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms in \ggplot}
  \label{tbl:geoms}
\end{table}

\begin{table}
  \begin{center}
  \begin{tabular}{llp{3in}}
  \toprule
  Name & Default stat & Aesthetics \\
  \midrule
  abline     & abline    & colour, linetype, size                                                                                                     \\
  area       & identity  & colour, fill, linetype, size, \textbf{x}, \textbf{y}                                                                     \\
  bar        & bin       & colour, fill, linetype, size, weight, \textbf{x}                                                                          \\
  bin2d      & bin2d     & colour, fill, linetype, size, weight, \textbf{xmax}, \textbf{xmin}, \textbf{ymax}, \textbf{ymin}                       \\
  blank      & identity  &                                                                                                                            \\
  boxplot    & boxplot   & colour, fill, \textbf{lower}, \textbf{middle}, size, \textbf{upper}, weight, \textbf{x}, \textbf{ymax}, \textbf{ymin}\\
  contour    & contour   & colour, linetype, size, weight, \textbf{x}, \textbf{y}                                                                   \\
  crossbar   & identity  & colour, fill, linetype, size, \textbf{x}, \textbf{y}, \textbf{ymax}, \textbf{ymin}                                     \\
  density    & density   & colour, fill, linetype, size, weight, \textbf{x}, \textbf{y}                                                             \\
  density2d  & density2d & colour, linetype, size, weight, \textbf{x}, \textbf{y}                                                                   \\
  errorbar   & identity  & colour, linetype, size, width, \textbf{x}, \textbf{ymax}, \textbf{ymin}                                                 \\
  freqpoly   & bin       & colour, linetype, size                                                                                                     \\
  hex        & binhex    & colour, fill, size, \textbf{x}, \textbf{y}                                                                               \\
  histogram  & bin       & colour, fill, linetype, size, weight, \textbf{x}                                                                          \\
  hline      & hline     & colour, linetype, size                                                                                                     \\
  jitter     & identity  & colour, fill, shape, size, \textbf{x}, \textbf{y}                                                                        \\
  line       & identity  & colour, linetype, size, \textbf{x}, \textbf{y}                                                                           \\
  linerange  & identity  & colour, linetype, size, \textbf{x}, \textbf{ymax}, \textbf{ymin}                                                        \\
  path       & identity  & colour, linetype, size, \textbf{x}, \textbf{y}                                                                           \\
  point      & identity  & colour, fill, shape, size, \textbf{x}, \textbf{y}                                                                        \\
  pointrange & identity  & colour, fill, linetype, shape, size, \textbf{x}, \textbf{y}, \textbf{ymax}, \textbf{ymin}                              \\
  polygon    & identity  & colour, fill, linetype, size, \textbf{x}, \textbf{y}                                                                     \\
  quantile   & quantile  & colour, linetype, size, weight, \textbf{x}, \textbf{y}                                                                   \\
  rect       & identity  & colour, fill, linetype, size, \textbf{xmax}, \textbf{xmin}, \textbf{ymax}, \textbf{ymin}                               \\
  ribbon     & identity  & colour, fill, linetype, size, \textbf{x}, \textbf{ymax}, \textbf{ymin}                                                  \\
  rug        & identity  & colour, linetype, size                                                                                                     \\
  segment    & identity  & colour, linetype, size, \textbf{x}, \textbf{xend}, \textbf{y}, \textbf{yend}                                           \\
  smooth     & smooth    & alpha, colour, fill, linetype, size, weight, \textbf{x}, \textbf{y}                                                      \\
  step       & identity  & colour, linetype, size, \textbf{x}, \textbf{y}                                                                           \\
  text       & identity  & angle, colour, hjust, \textbf{label}, size, vjust, \textbf{x}, \textbf{y}                                               \\
  tile       & identity  & colour, fill, linetype, size, \textbf{x}, \textbf{y}                                                                     \\
  vline      & vline     & colour, linetype, size                                                                                                     \\
  
  \bottomrule
  \end{tabular}
  \end{center}
  \caption{Default statistics and aesthetics.  Emboldened aesthetics are required.}
  \label{tbl:geom-aesthetics}
\end{table}


\section{Stat}
\label{sec:stat}

A statistical transformation, or {\bf stat}, transforms the data, typically by summarising it in some manner.  For example, a useful stat is the smoother, which calculates the mean of y, conditional on x, subject to some restriction that ensures smoothness. All currently available stats are listed in Table~\ref{tbl:stats}.  To make sense in a graphic context a stat must be location-scale invariant: $\mbox{f}(x + a) = \mbox{f}(x) + a$ and $\mbox{f}(b \cdot x) = b \cdot \mbox{f}(x)$.  This ensures that the transformation stays the same when you change the scales of the plot.

\begin{table}
  \begin{center}
  \begin{tabular}{lp{3in}}
    \toprule
    Name & Description \\
    \midrule
    bin          & Bin data                                                   \\
    boxplot      & Calculate components of box-and-whisker plot               \\
    contour      & Contours of 3d data                                        \\
    density      & Density estimation, 1d                                     \\
    density\_2d & Density estimation, 2d                                     \\
    function     & Superimpose a function                                     \\
    identity     & Don't transform data                                       \\
    qq           & Calculation for quantile-quantile plot                     \\
    quantile     & Continuous quantiles                                       \\
    smooth       & Add a smoother                                             \\
    spoke        & Convert angle and radius to xend and yend                  \\
    step         & Create stair steps                                         \\
    sum          & Sum unique values.  Useful for overplotting on scatterplots\\
    summary      & Summarise y values at every unique x                       \\
    unique       & Remove duplicates                                          \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Stats in \ggplot}
  \label{tbl:stats}
\end{table}

A stat takes a dataset as input and returns a dataset as output, and so a stat can add new variables to the original dataset.  It is possible to map aesthetics to these new variables.  For example, \code{stat_bin}, the statistic used to make histograms, produces the following variables: \index{Stats!creating new variables} \indexf{stat_bin}

\begin{itemize}
  \item \var{count}, the number of observations in each bin
  \item \var{density}, the density of observations in each bin (percentage of total / bar width)
  \item \var{x}, the centre of the bin
\end{itemize}

These generated variables can be used instead of the variables present in the original dataset.  For example, the default histogram geom assigns the height of the bars to the number of observations (\var{count}), but if you'd prefer a more traditional histogram, you can use the density (\var{density}).   The following example shows a density histogram of \var{carat} from the diamonds dataset.

% INTERWEAVE
%   GG-WIDTH: 8
%   TEX-WIDTH: \linewidth
% 
% ggplot(diamonds, aes(carat)) + 
%   geom_histogram(aes(y = ..density..), binwidth = 0.1)
\input{_include/926e05b5e722f1afc3047405e384101a.tex}
% END

The names of generated variables must be surrounded with {\tt ..} when used.  This prevents confusion in case the original dataset includes a variable with the same name as a generated variable, and it makes it clear to any later reader of the code that this variable was generated by a stat.  Each statistic lists the variables that it creates in its documentation. \indexc{..}

The syntax to produce this plot with \f{qplot} is very similar:

% LISTING
% 
% qplot(carat, ..density.., data = diamonds, geom="histogram", 
%   binwidth = 0.1)
\input{_include/708316b3ce33b0a6eb6c1febd4c4d62e.tex}
% END

\section{Position adjustments}
\label{sec:position}

Position adjustments apply minor tweaks to the position of elements within a layer.  Table~\ref{fig:position} lists all of the position adjustments available within \ggplot.  Position adjustments are normally used with discrete data.  Continuous data typically doesn't overlap exactly, and when it does (because of high data density) minor adjustments, like jittering, are usually insufficient to fix the problem. \index{Position adjustments} \index{Adjustments!position}  \index{Positioning!position adjustments}

\begin{table}
  \begin{center}
  \begin{tabular}{ll}
    \toprule
    Adjustment & Description  \\
    \midrule
    dodge     & Adjust position by dodging overlaps to the side \\
    fill      & Stack overlapping objects and standardise have equal height\\
    identity  & Don't adjust position \\
    jitter    & Jitter points to avoid overplotting \\
    stack     & Stack overlapping objects on top of one another \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{The five position adjustments.}
  \label{fig:position}
\end{table}

The different types of adjustment are best illustrated with a bar chart.  Figure~\ref{fig:position-bar} shows stacking, filling and dodging.  Stacking puts bars on the same x on top of one another; filling does the same, but normalises height to 1; and dodging places the bars side-by-side.  Dodging is rather similar to faceting, and the advantages and disadvantages of each method are described in Section~\ref{sub:dodge-vs-facet}. For these operations to work, each bar must have the same width and not overlap with any others.  The identity adjustment (i.e., do nothing) doesn't make much sense for bars, but is shown in Figure~\ref{fig:position-identity} along with a line plot of the same data for reference. \index{Dodging} \index{Side-by-side|see{Dodging}} \index{Stacking} \indexf{position_dodge} \indexf{position_fill}  \indexf{position_stack} \indexf{geom_bar}

% FIGURE
%   LABEL: position-bar
%   CAPTION: Three position adjustments applied to a bar chart.  From left to
%   right, stacking, filling and dodging.
%   COL: 3 TEX-WIDTH: 0.33 \linewidth
% 
% dplot <- ggplot(diamonds, aes(clarity, fill = cut))
% dplot + geom_bar(position = "stack")
% dplot + geom_bar(position = "fill")
% dplot + geom_bar(position = "dodge")
\input{_include/268f05dffbd5920eca2233dc4f395e6b.tex}
% END

% FIGURE
%   LABEL: position-identity
%   CAPTION: The identity positon adjustment is not useful for bars, (left) 
%   because each bar obscures the bars behind.  (Right) It is useful for
%   lines, however, because lines do not have the same problem.
% 
% dplot + geom_bar(position = "identity")
% qplot(clarity, data = diamonds, geom="line", colour = cut, 
%   stat="bin", group=cut)
\input{_include/878c9b84d2a8fbf81aa2764059aa671c.tex}
% END

\section{Pulling it all together}
\label{sec:pull-together}

Once you have become comfortable with combining layers, you will be able to create graphics that are both intricate and useful.  The following examples demonstrate some of the ways to use the capabilities of layers that have been introduced in this chapter.  These are just to get you started. You are limited only by your imagination!

\subsection{Combining geoms and stats}
\label{sub:new_plot_types}

By connecting geoms with different statistics, you can easily create new graphics.  Figure~\ref{fig:hist-variations} shows three variations on a histogram.  They all use the same statistical transformation underlying a histogram (the bin stat), but use different geoms to display the results: the area geom, the point geom and the tile geom.  \index{Geoms!combining with stats} \index{Stats!combining with geoms}

% LISTING
% 
% d <- ggplot(diamonds, aes(carat)) + xlim(0, 3)
% d + stat_bin(aes(ymax = ..count..), binwidth = 0.1, geom = "area")
% d + stat_bin(
%   aes(size = ..density..), binwidth = 0.1, 
%   geom = "point", position="identity"
% )
% d + stat_bin(
%   aes(y = 1, fill = ..count..), binwidth = 0.1, 
%   geom = "tile", position="identity"
% )
\input{_include/445f291f876e87a49a11f795b63c85fb.tex}
% END

% dfs: I can't see any difference whether you use scale_area or not, or scale_y_continous or not,
% so I would like to leave them out, since they haven't yet been introduced.
% hw: I agree

(The use of \f{xlim} will be discussed in Section~\ref{sub:scale-position}, in the presentation of the use of scales and axes, but you can already guess that it is used here to set the limits of the horizontal axis.)

% FIGURE
%   LABEL: hist-variations
%   TEX-WIDTH: 0.33\linewidth
%   CAPTION: Three variations on the histogram. (Left) A frequency polygon;
%   (middle) a scatterplot with both size and height mapped to frequency; 
%   (right) a heatmap representing frequency with colour.
% 
% d <- ggplot(diamonds, aes(carat)) + xlim(0, 3)
% d + stat_bin(aes(ymax = ..count..), binwidth = 0.1, geom = "area")
% d + stat_bin(aes(size = ..density..), binwidth = 0.1, geom = "point", position="identity")
% d + stat_bin(aes(y=1, fill = ..count..), binwidth = 0.1, geom = "tile", position="identity") + scale_y_continuous("")
\input{_include/257c2d996802d37e67c1fd1bda8dd7df.tex}
% END

A number of the geoms available in \ggplot were derived from other geoms in a process like the one just described, starting with an existing geom and making a few changes in the default aesthetics or stat.  For example, the jitter geom is simply the point geom with the default position adjustment set to jitter.  Once it becomes clear that a particular variant is going to be used a lot or used in a very different context, it makes sense to create a new geom. Table~\ref{tbl:aliased-geoms} lists these ``aliased'' geoms. \index{Geoms!aliases}

\begin{table}
  \begin{center}
  \begin{tabular}{lll}
    \toprule
    Aliased geom & Base geom & Changes in default \\
    \midrule
    area      & ribbon & \verb!aes(min = 0, max = y), position = "stack"!  \\
    density   & area   & \verb!stat = "density"!    \\
    freqpoly  & line   & \verb!stat = "bin"!        \\
    histogram & bar    & \verb!stat = "bin"!        \\
    jitter    & point  & \verb!position = "jitter"! \\
    quantile  & line   & \verb!stat = "quantile"!   \\
    smooth    & ribbon & \verb!stat = "smooth"!     \\
    \bottomrule
  \end{tabular}
  \end{center}
  \caption{Geoms that were created by modifying the defaults of another geom.}
  \label{tbl:aliased-geoms}
\end{table}

\subsection{Displaying precomputed statistics} 
\label{sub:precomputed}

If you have data which has already been summarised, and you just want to use it, you'll need to use \f{stat_identity}, which leaves the data unchanged, and then map the appropriate variables to the appropriate aesthetics. \index{Stats!precomputed} \indexf{stat_identity}

\subsection{Varying aesthetics and data}
\label{sub:different_aesthetics}

One of the more powerful capabilities of \ggplot is the ability to plot different datasets on different layers.  This may seem strange: Why would you want to plot different data on the same plot?  In practice, you often have related datasets that should be shown together.  A very common example is supplementing the data with predictions from a model.  While the smooth geom can add a wide range of different smooths to your plot, it is no substitute for an external quantitative model that summarises your understanding of the data.

Let's look again at the \code{Oxboys} dataset which was used in Section~\ref{sub:grouping}.  In Figure~\ref{fig:group-smooths}, we showed linear fits for individual boys (left) and for the whole group (right).  Neither model is particularly appropriate: The group model ignores the within-subject correlation and the individual model doesn't use information about the typical growth pattern to more accurately predict individuals.  In practice we might use a mixed model to do better.  This section explores how we can combine the output from this more sophisticated model with the original data to gain more insight into both the data and the model. \index{Model!diagnostics}

First we'll load the \pkg{nlme} package, and fit a model with varying intercepts and slopes.  (Exploring the fit of individual models shows that this is a reasonable first pass.)  We'll also create a plot to use as a template.  This regenerates the first plot in Figure~\ref{fig:group-lines}, but we're not going to render it until we've added data from the model.

% INTERWEAVE
% 
% require(nlme, quiet = TRUE, warn.conflicts = FALSE)
% model <- lme(height ~ age, data = Oxboys, 
%  random = ~ 1 + age | Subject)
% oplot <- ggplot(Oxboys, aes(age, height, group = Subject)) + 
%   geom_line()
\input{_include/167f90803c333596037fc2b2a50f6a03.tex}
% END

Next we'll compare the predicted trajectories to the actual trajectories.  We do this by building up a grid that contains all combinations of ages and subjects.  This is overkill for this simple linear case, where we only need two values of age to draw the predicted straight line, but we show it here because it is necessary when the model is more complex.  Next we add the predictions from the model back into this dataset, as a variable called \var{height}.  \indexf{geom_line}

% INTERWEAVE
% 
% age_grid <- seq(-1, 1, length = 10)
% subjects <- unique(Oxboys$Subject)
% 
% preds <- expand.grid(age = age_grid, Subject = subjects)
% preds$height <- predict(model, preds)
\input{_include/b5574838ff113f7ccff5043f24188640.tex}
% END

Once we have the predictions we can display them along with the original data.  Because we have used the same variable names as the original \code{Oxboys} dataset, and we want the same group aesthetic, we don't need to specify any aesthetics; we only need to override the default dataset.  We also set two aesthetic parameters to make it a bit easier to compare the predictions to the actual values.

% INTERWEAVE
% 
% oplot + geom_line(data = preds, colour = "#3366FF", size= 0.4)
\input{_include/c3bac4110594cb12ebfca3222b87b2ea.tex}
% END

It seems that the model does a good job of capturing the high-level structure of the data, but it's hard to see the details: plots of longitudinal data are often called spaghetti plots, and with good reason.  Another way to compare the model to the data is to look at residuals, so let's do that.  We add the predictions from the model to the original data (\var{fitted}), calculate residuals (\var{resid}), and add the residuals as well.  The next plot is a little more complicated: We update the plot dataset (recall the use of \code{\%+\%} to update the default data), change the default y aesthetic to \var{resid}, and add a smooth line for all observations. \indexf{geom_smooth}

% INTERWEAVE
% 
% Oxboys$fitted <- predict(model)
% Oxboys$resid <- with(Oxboys, fitted - height)
% 
% oplot %+% Oxboys + aes(y = resid) + geom_smooth(aes(group=1))
\input{_include/0448f66f9d51ed0e15518a224b55acba.tex}
% END

The smooth line makes it evident that the residuals are not random, showing a deficiency in the model.  We add a quadratic term, refit the model, recalculate predictions and residuals, and replot.  There is now less evidence of model inadequacy.

% INTERWEAVE
% 
% model2 <- update(model, height ~ age + I(age ^ 2))
% Oxboys$fitted2 <- predict(model2)
% Oxboys$resid2 <- with(Oxboys, fitted2 - height)
% 
% oplot %+% Oxboys + aes(y = resid2) + geom_smooth(aes(group=1))
\input{_include/5464ff3fc5578ef3bebe81ce0a915771.tex}
% END

Notice how easily we were able to modify the plot object.  We updated the data and replotted twice without needing to reinitialise \code{oplot}.  Layering in \ggplot is designed to work well with the iterative process of fitting and evaluating models.

\input{_footer.tex}
